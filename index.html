<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predict VIP King Pro - v17.8 (Reviewed)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Base Styles & Variables (Initial - will be overwritten by JS) --- */
        :root {
            --primary: #D4AF37;
            --secondary: #6A0DAD;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --violet-accent: #6A0DAD;

            --bg-main: #1A1A1A;
            --bg-card: #2A2A2A;
            --bg-header-footer: #101010;
            --bg-interactive: #383838;
            --bg-hover: #454545;
            --bg-admin-section-mobile: #303030;
            --bg-modal-overlay: rgba(0,0,0,0.88);
            --bg-gemini-modal: #252525;

            --text-primary: #E0E0E0;
            --text-secondary: #A0A0A0;
            --text-disabled: #555555;
            --text-on-accent: #FFFFFF;

            --text-win: var(--success);
            --text-loss: var(--danger);
            --text-partial: var(--secondary);
            --text-error: var(--warning);
            --text-num-red: var(--danger);
            --text-num-green: var(--success);

            --partial-bg: rgba(106, 13, 173, 0.15);
            --win-bg: rgba(40, 167, 69, 0.15);
            --loss-bg: rgba(220, 53, 69, 0.15);
            --error-bg: rgba(255, 193, 7, 0.15);

            --border-color: #504A4B;
            --shadow: '0 5px 18px rgba(0, 0, 0, 0.8)';
            --tick-color: var(--success);
            --cross-color: var(--danger);
            --body-bg-gradient-start: '#1A1A1A';
            --body-bg-gradient-end': '#101010';
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; }
        body {
            color: var(--text-primary);
            min-height: 100vh; overflow-x: hidden; font-size: 14px; line-height: 1.4;
            transition: background-color 0.3s, color 0.3s;
            background: linear-gradient(180deg, var(--body-bg-gradient-start) 0%, var(--body-bg-gradient-end) 100%);
        }
        .container { max-width: 1080px; width: 100%; margin: 0 auto; padding: 4px; }
        header { text-align: center; margin-bottom: 0.4rem; position: relative; padding: 0.4rem; background-color: var(--bg-card); border-radius: 5px; box-shadow: var(--shadow); border: 1px solid var(--border-color); }
        h1 { font-size: 1.75rem; margin-bottom: 0.1rem; color: var(--primary); font-weight: 700; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); }
        .app-logo { max-width: 50px; max-height: 50px; vertical-align: middle; margin-right: 10px; /* Adjust as needed */ }
        .header-title-container { display: flex; align-items: center; justify-content: center; }
        .header-subtitle-container { display: flex; align-items: center; justify-content: center; gap: 0.5rem; font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.05rem; font-weight: 400; flex-wrap: wrap; }
        .header-action-icon { color: var(--text-secondary); text-decoration: none; font-size: 1em; cursor: pointer; transition: color 0.3s ease, transform 0.2s ease; padding: 0 3px; }
        .header-action-icon:hover { color: var(--primary); transform: scale(1.1); }

        .info-modal, .gemini-modal {
            display: none; position: fixed; z-index: 1050;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: var(--bg-modal-overlay);
            align-items: center; justify-content: center;
        }
        .info-modal-content, .gemini-modal-content {
            color: var(--text-primary); margin: auto; padding: 15px;
            border: 1px solid var(--border-color); width: 90%;
            border-radius: 8px;
            box-shadow: var(--shadow); position: relative;
        }
        .info-modal-content { background: var(--bg-card); max-width: 420px; }
        .gemini-modal-content { background: var(--bg-gemini-modal); max-width: 500px; }

        .info-modal-content h3, .gemini-modal-content h3 {
            color: var(--primary); margin-top: 0; margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color); padding-bottom: 6px;
            font-size: 1rem; font-weight: 600;
            display: flex; align-items: center; gap: 8px;
        }
        .info-modal-content p { margin-bottom: 4px; line-height: 1.25; font-size: 0.72rem;}
        .info-modal-content ul { list-style-position: inside; padding-left: 0; margin-bottom: 4px;}
        .info-modal-content li { margin-bottom: 2.5px; font-size: 0.72rem;}
        .info-modal-content .disclaimer-icon { color: var(--warning); }
        .info-modal-content .disclaimer-text { font-weight: bold; }
        .info-modal-content .contact-item { margin-bottom: 5px; font-size: 0.75rem; }
        .info-modal-content .contact-item strong { color: var(--secondary); }

        .info-modal-close-button, .gemini-modal-close-button {
            color: #aaa; position: absolute; top: 8px; right: 12px;
            font-size: 24px; font-weight: bold; cursor: pointer;
            transition: color 0.2s ease;
        }
        .info-modal-close-button:hover, .gemini-modal-close-button:hover { color: var(--primary); }

        #geminiAnalysisText {
            font-size: 0.85rem; line-height: 1.5;
            max-height: 60vh; overflow-y: auto;
            padding: 10px; margin-bottom: 10px;
            background-color: var(--bg-main);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            white-space: pre-wrap;
        }
        #geminiAnalysisText .gemini-loading {
            display: flex; align-items: center; justify-content: center;
            padding: 20px; color: var(--text-secondary);
        }
        #geminiAnalysisText .gemini-loading i { margin-right: 10px; }


        .top-info-line { display: flex; justify-content: space-around; align-items: center; flex-wrap: nowrap; gap: 0.3rem; padding: 0.3rem 0.4rem; margin-bottom: 0.4rem; border-bottom: 1px solid var(--border-color); background-color: var(--bg-header-footer); border-radius: 4px; overflow-x: auto; }
        .top-info-line::-webkit-scrollbar { height: 2.5px; }
        .top-info-line::-webkit-scrollbar-track { background: var(--bg-header-footer); }
        .top-info-line::-webkit-scrollbar-thumb { background-color: var(--primary); border-radius: 1.5px;}
        .top-info-item { display: flex; align-items: center; justify-content: center; gap: 0.2rem; font-size: 0.8rem; color: var(--text-primary); white-space: nowrap; flex-grow: 1; flex-basis: 0; text-align: center; }
        .top-info-item .value { font-weight: 600; color: var(--text-primary); padding-left: 0.1em; font-size:0.85rem; }
        .top-info-item i { color: var(--primary); font-size: 0.9rem; margin-right: 0.1em; }
        .top-info-item#periodInfoItem { min-width: 130px; flex-shrink: 0;}
        .top-info-item:not(#periodInfoItem) { min-width: 60px; }
        #apiStatus.status-online { color: var(--success); font-weight: 600; }
        #apiStatus.status-offline { color: var(--danger); font-weight: 600; }
        .card { margin-bottom: 3px; padding: 6px; background-color: var(--bg-card); border-radius: 6px; box-shadow: var(--shadow); border: 1px solid var(--border-color); }
        .prediction-card { margin-bottom: 3px; }
        .card-title { font-size: 0.95rem; margin: -6px -6px 4px -6px; padding: 6px 8px; color: var(--primary); display: flex; align-items: center; justify-content: space-between; gap: 4px; font-weight: 600; border-bottom: 1px solid var(--border-color); border-radius: 6px 6px 0 0; background-color: var(--bg-header-footer); }
        .card-title > div { display: flex; align-items: center; gap: 4px; }
        .card-title i { font-size: 1rem; margin-right: 2.5px; }
        .card-title .header-action-icon { font-size: 0.9em; }
        .clear-btn { background: var(--danger); color: var(--text-on-accent); border: none; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; font-weight: 500; transition: background-color 0.2s; }
        .clear-btn i { margin-right: 3px; }
        .clear-btn:hover { background-color: #a00020; }
        body.light-theme .clear-btn:hover { background-color: #C62828; }

        .main-interactive-area { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; padding: 0.15rem 0; }
        .output-area { flex-grow: 1; width: 100%; max-width: 100%; min-width: 250px; padding: 0; border: none; }
        #currentResult { font-size: 0.95rem; line-height: 1.4; text-align: center; white-space: nowrap; overflow-x: auto; overflow-y: hidden; padding: 0.4rem 0.3rem; background-color: var(--bg-card); border-radius: 4px; color: var(--text-primary); border: 1px solid var(--border-color); }
        #currentResult::-webkit-scrollbar { height: 2.5px; }
        #currentResult::-webkit-scrollbar-track { background: var(--bg-interactive); }
        #currentResult::-webkit-scrollbar-thumb { background-color: var(--secondary); border-radius: 1.5px; }
        .prediction-output-item { display: inline-block; margin: 0 3px; vertical-align: middle; font-size: 1em; }
        .prediction-output-label { color: var(--text-secondary); margin-right: 2px; font-size: 0.9em; }
        .prediction-output-value { font-weight: 500; color: var(--text-primary); font-size: 1em; }
        .prediction-output-item.p-bs .prediction-output-value,
        .prediction-output-item.p-color .prediction-output-value { color: var(--primary); font-weight: 600; font-size: 1.15em; }
        .prediction-output-item.p-perc .prediction-output-value { color: var(--info); font-weight: 500; }
        .prediction-output-item.p-rev .prediction-output-value { color: var(--warning); font-weight: 500; }
        .prediction-output-item.p-nums .prediction-output-value { color: var(--secondary); font-weight: 500; font-size: 1.05em;}
        .prediction-output-item.p-color .color-dot { vertical-align: middle; margin-right: 2px;}
        .prediction-output-item.p-strat .prediction-output-value { color: var(--text-secondary); font-size: 0.9em; font-style: italic; max-width: 75px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; vertical-align: middle; }

        .gemini-button {
            background-color: var(--info); color: var(--text-on-accent); border: none;
            padding: 3px 8px; border-radius: 4px; cursor: pointer;
            font-size: 0.7rem; font-weight: 500; transition: background-color 0.2s;
            margin-left: 8px; vertical-align: middle;
        }
        .gemini-button:hover { background-color: #2980B9; }
        body.light-theme .gemini-button:hover { background-color: #0277BD; }
        .gemini-button i { margin-right: 4px;}

        .tabs { display: flex; margin-bottom: 0rem; border-bottom: 1px solid var(--border-color); gap: 1.5px; background-color: var(--bg-header-footer); border-radius: 4px 4px 0 0; }
        .tabs button { flex: 1; padding: 0.35rem; background: none; border: none; color: var(--text-secondary); font-weight: 500; cursor: pointer; position: relative; transition: background-color 0.2s, color 0.2s, border-bottom-color 0.2s; display: flex; align-items: center; justify-content: center; gap: 0.2rem; border-bottom: 2px solid transparent; font-size: 0.85rem; }
        .tabs button.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: 600; background-color: var(--bg-interactive); }
        .tabs button:hover:not(.active) { color: var(--primary); background-color: var(--bg-hover); }
        .my-history-controls { padding: 4px 8px; background-color: var(--bg-header-footer); display: flex; gap: 8px; align-items: center; font-size: 0.8rem; border-bottom: 1px solid var(--border-color); margin-bottom: 1px; }
        .my-history-controls label { color: var(--text-secondary); }
        .my-history-controls select { background-color: var(--bg-interactive); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 3px; padding: 2px 4px; font-size: 0.8rem; }
        .history-header { display: none; gap: 1px 2px; padding: 3px 4px; font-weight: 500; border-bottom: 1px solid var(--border-color); font-size: 0.65rem; color: var(--text-secondary); background: var(--bg-header-footer); text-transform: uppercase; margin-bottom: 1px; }
        #gameHistoryHeader, #myHistoryHeader, #adminDashboardHeader { border-top-left-radius: 0; border-top-right-radius: 0; }

        #gameHistoryHeader { grid-template-columns: 2.2fr 0.8fr 1.2fr 2.8fr; }
        .history-item.game-result-item { grid-template-columns: 2.2fr 0.8fr 1.2fr 2.8fr; }
        #myHistoryHeader { grid-template-columns: 2fr 0.8fr 1.3fr 1.7fr 1fr; }
        .history-item.my-prediction-item { grid-template-columns: 2fr 0.8fr 1.3fr 1.7fr 1fr; line-height: 1.15; padding: 1.5px 2.5px; font-size: 0.78rem; }

        #gameHistoryHeader .history-header-item, .history-item.game-result-item .history-value { text-align: center; justify-content: center; }
        #gameHistoryHeader .history-header-item:first-child, .history-item.game-result-item .history-value:first-child { text-align: left; justify-content: flex-start; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .history-item.game-result-item .gh-num { font-weight: 600; }
        .history-item.game-result-item .gh-num-red { color: var(--text-num-red); }
        .history-item.game-result-item .gh-num-green { color: var(--text-num-green); }
        .history-item.game-result-item .gh-bs { font-weight: 600; }
        .history-item.game-result-item .gh-bs-big { color: var(--warning); }
        .history-item.game-result-item .gh-bs-small { color: var(--info); }
        .history-item.game-result-item .gh-color { display: flex; align-items: center; justify-content: center; gap: 3px; }
        .history-item.game-result-item .gh-color .color-dot { margin-right: 0px; margin-left: 2px; }
        #myHistoryHeader .history-header-item { text-align: center; white-space: nowrap; }
        #myHistoryHeader .history-header-item:first-child { text-align: left; }
        .history-item.my-prediction-item .history-value { font-size: 0.72rem; padding: 0px 1px; line-height: 1.1; }
        .history-item.my-prediction-item .history-value:first-child { text-align: left; justify-content: flex-start; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 85px; }
        .history-item.my-prediction-item .history-value.predicted-bs-value,
        .history-item.my-prediction-item .history-value.predicted-color-value .color-dot { margin-right: 2px; }
        .history-item.my-prediction-item .history-value.predicted-color-value, .history-item.my-prediction-item .history-value.status-value, .history-item.my-prediction-item .history-value.predicted-num-value { text-align: center; justify-content: center; }
        #adminDashboardHeader { display: none; }

        .history-content {
            background: var(--bg-main);
            border-radius: 0 0 5px 5px;
            padding: 0.15rem 0;
            min-height: 170px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) var(--bg-main);
            transition: max-height 0.3s ease-out;
        }
        .history-content::-webkit-scrollbar { width: 3px; }
        .history-content::-webkit-scrollbar-track { background: var(--bg-main); border-radius: 3px; }
        .history-content::-webkit-scrollbar-thumb { background-color: var(--primary); border-radius: 3px; }

        .history-item { background: var(--bg-interactive); border: 1px solid var(--border-color); border-radius: 3px; margin: 0 0.1rem 1.5px 0.1rem; display: grid; gap: 1px 2px; align-items: center; transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease; box-shadow: 0 0.5px 0.5px rgba(0,0,0,0.05); }
        .history-item:not(.my-prediction-item) { padding: 2.5px 3.5px; font-size: 0.8rem; }
        .history-item:hover { border-color: var(--primary); background-color: var(--bg-hover); }
        .history-item.my-prediction-item.row-win { background-color: var(--win-bg); border-color: rgba(76, 175, 80, 0.2); }
        .history-item.my-prediction-item.row-loss { background-color: var(--loss-bg); border-color: rgba(220, 20, 60, 0.2); }
        .history-item.my-prediction-item.row-partial { background-color: var(--partial-bg); border-color: rgba(184, 134, 11, 0.2); }
        .history-item.my-prediction-item.row-error { background-color: var(--error-bg); border-color: rgba(255, 193, 7, 0.2); }
        .history-item .history-value {
            font-weight: 400; display: flex; align-items: center; word-break: break-word;
            color: var(--text-primary); text-align: center; justify-content: center;
            padding: 0.5px 1.5px; line-height: 1.15; font-size: 0.75rem;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .history-item .history-value.action-cell { justify-content: center; }
        .history-item .status-win { color: var(--text-win); font-weight: bold; }
        .history-item .status-loss { color: var(--text-loss); font-weight: bold; }
        .history-item .status-partial { color: var(--text-partial); font-weight: 500; }
        .history-item .status-error { color: var(--text-error); font-style: italic; }
        .tick-mark { color: var(--tick-color); margin-left: 1.5px; font-weight: bold; font-size: 0.85em; }
        .cross-mark { color: var(--cross-color); margin-left: 1.5px; font-weight: bold; font-size: 0.85em; }
        .color-dot { display: inline-block; width: 6.5px; height: 6.5px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.15); vertical-align: middle; margin-right: 1px; margin-left: 1px; }
        body.light-theme .color-dot { border: 1px solid rgba(44,62,80,0.1); }
        .color-red { background-color: var(--danger); }
        .color-green { background-color: var(--success); }
        .color-violet { background-color: var(--violet-accent); }
        .stats-bar { background-color: var(--bg-header-footer); padding: 5.5px 8.5px; margin-top: 0; margin-bottom: 3.5px; border-radius: 0 0 4px 4px; border: 1px solid var(--border-color); border-top: none; box-shadow: var(--shadow); display: flex; justify-content: space-around; align-items: center; flex-wrap: nowrap; overflow-x: auto; gap: 6.5px 10.5px; font-size: 0.85rem; }
        .stats-bar-item { display: flex; align-items: center; gap: 3.5px; color: var(--text-secondary); flex-shrink: 0; }
        .stats-bar-item strong { color: var(--text-primary); font-weight: 500; }
        .stats-bar-item .value { font-weight: 500; } .stats-bar-item .win { color: var(--success); } .stats-bar-item .loss { color: var(--danger); } .stats-bar-item .acc { color: var(--primary); } .stats-bar-item .rev { color: var(--warning); } .stats-bar-item .level { color: var(--info); font-weight: bold;} .stats-bar-item .partial { color: var(--text-partial); }
        .analytics-grid { display: grid; grid-template-columns: auto auto 1fr; gap: 3px 6px; align-items: center; font-size: 0.75rem; margin-top: 3.5px; padding: 8px; background: var(--bg-interactive); border-radius: 4px; }
        .analytics-grid > div { padding: 2px 0; }
        .analytics-grid > div:nth-child(3n+1) { font-weight: 500; display: flex; align-items: center; color:var(--text-secondary); }
        .analytics-grid > div:nth-child(3n+1) strong {color: var(--text-primary);}
        .analytics-grid > div:nth-child(3n+2) { font-weight: 600; text-align: right; color:var(--text-primary); }
        .analytics-grid > div:nth-child(3n) { text-align: right; color: var(--secondary); }
        .analytics-grid h4 { grid-column: 1 / -1; margin-bottom: 6px; color: var(--primary); border-bottom: 1px solid var(--border-color); padding-bottom: 3px; font-size: 0.85rem; }
        .analytics-grid .outcome-icon { display: inline-block; width: 10.5px; height: 10.5px; line-height: 10.5px; text-align: center; border-radius: 2px; margin-right: 3.5px; font-weight: bold; color: var(--bg-card); font-size: 0.55rem;}
        .analytics-grid .outcome-icon.big { background-color: var(--warning); }
        .analytics-grid .outcome-icon.small { background-color: var(--info); }
        .analytics-grid .session-accuracy-footer { grid-column: 1 / -1; text-align: center; margin-top: 6px; padding-top: 6px; border-top: 1px solid var(--border-color); color: var(--primary); font-weight: 500; font-size: 0.8rem;}

        #jarvisAnalyticsCard { margin-top: 0; margin-bottom: 4px; background-color: var(--bg-card); }
        #jarvisAnalyticsContent { padding: 8px 10px; }
        .jarvis-stats-bar { display: flex; justify-content: flex-start; align-items: center; flex-wrap: nowrap; overflow-x: auto; background-color: var(--bg-interactive); padding: 5px 4px; border-radius: 4px; margin-bottom: 10px; }
        .jarvis-stats-bar::-webkit-scrollbar { height: 3px; }
        .jarvis-stats-bar::-webkit-scrollbar-track { background: var(--bg-interactive); }
        .jarvis-stats-bar::-webkit-scrollbar-thumb { background-color: var(--primary); border-radius: 1.5px;}
        .jarvis-stat-item { display: flex; align-items: baseline; padding: 2px 8px; font-size: 0.72rem; color: var(--text-primary); white-space: nowrap; flex-shrink: 0; border-right: 1px solid var(--border-color); }
        .jarvis-stat-item:last-child { border-right: none; }
        .jarvis-label { font-weight: 500; color: var(--text-secondary); margin-right: 3px; }
        .jarvis-value { font-weight: 600; color: var(--primary); font-size: 0.8rem; }
        .jarvis-details { font-size: 0.68rem; color: var(--text-secondary); margin-left: 3px; }
        #jarvisAlertsContainer .jarvis-alert { padding: 7px 10px; margin-top: 6px; border-radius: 4px; font-size: 0.78rem; display: flex; align-items: center; gap: 6px; border: 1px solid transparent; }
        #jarvisAlertsContainer .jarvis-alert.danger { background-color: rgba(220, 53, 69, 0.2); color: #F5C6CB; border-color: rgba(220,53,69,0.5); }
        body.light-theme #jarvisAlertsContainer .jarvis-alert.danger { background-color: rgba(211, 47, 47, 0.1); color: #C62828; border-color: rgba(211,47,47,0.4); }
        #jarvisAlertsContainer .jarvis-alert.warning { background-color: rgba(255, 193, 7, 0.2); color: #FFDA6B; border-color: rgba(255,193,7,0.5); }
        body.light-theme #jarvisAlertsContainer .jarvis-alert.warning { background-color: rgba(251, 192, 45, 0.1); color: #D35400; border-color: rgba(251,192,45,0.4); }
        #jarvisAlertsContainer .jarvis-alert i { font-size: 0.95em; }
        #jarvisOverall { font-weight: bold; }

        .pagination { display: flex; justify-content: center; gap: 0.25rem; margin-top: 0.4rem; padding-bottom: 4px; }
        .pagination button { padding: 0.25rem 0.4rem; background: var(--bg-interactive); border: 1px solid var(--border-color); border-radius: 3.5px; color: var(--primary); cursor: pointer; transition: background-color 0.3s, border-color 0.3s; font-size: 0.85rem; }
        .pagination button:hover:not(:disabled) { background-color: var(--bg-hover); border-color: var(--secondary); }
        .pagination button.active { background-color: var(--primary); color: var(--text-on-accent); border-color: var(--primary); }
        .pagination button:disabled { opacity: 0.4; cursor: not-allowed; background-color: var(--bg-interactive); color: var(--text-disabled); }
        .floating-notification { position: fixed; bottom: 8px; right: 8px; color: var(--text-on-accent); padding: 0.4rem 0.6rem; border-radius: 4px; box-shadow: var(--shadow); transform: translateY(70px); opacity: 0; transition: all 0.4s ease-out; z-index: 1050; display: flex; align-items: center; gap: 0.2rem; font-size: 0.75rem; background-color: var(--bg-header-footer); }
        .floating-notification.show { transform: translateY(0); opacity: 1; }
        .floating-notification i { margin-right: 0.2rem; }
        .floating-notification.success-bg { background-color: var(--success); }
        .floating-notification.error-bg { background-color: var(--danger); }
        .floating-notification.info-bg { background-color: var(--info); }

        /* --- Admin Panel --- */
        .admin-section {
            margin-bottom: 12px; padding: 10px; background-color: var(--bg-interactive);
            border-radius: 6px; border: 1px solid var(--border-color);
        }
        .admin-section h5 {
            color: var(--primary); margin-top: 0; margin-bottom: 8px;
            border-bottom: 1px solid var(--border-color); padding-bottom: 6px; font-size: 0.9rem;
        }
        #adminUserManagementTopControls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; align-items: flex-end; }
        #adminUserStats { display: flex; flex-wrap: wrap; gap: 8px 12px; align-items: center; background-color: var(--bg-header-footer); padding: 6px 10px; border-radius: 4px; flex-shrink: 0; margin-bottom: 6px;}
        #adminUserStats span { font-size: 0.75rem; }
        #createUserFormContainer { flex-grow: 1; display: flex; flex-direction: column; gap: 6px; background-color: var(--bg-header-footer); padding: 8px 10px; border-radius: 4px; min-width: auto; }
        #createUserFormContainer h6 { font-size: 0.75rem; margin:0 0 5px 0; color: var(--text-secondary); }

        #createUserFormControls { display: flex; flex-direction: row; align-items: center; gap: 6px; flex-wrap: nowrap; }
        #createUserFormControls label { color: var(--text-secondary); font-size: 0.7rem; margin-right: 3px; flex-shrink: 0; }
        #createUserFormControls select {
            padding: 4px 6px; background-color: var(--bg-card); color: var(--text-primary);
            border: 1px solid var(--border-color); border-radius: 3px; font-size: 0.7rem;
            flex-grow: 1; min-width: 80px; height: 28px;
        }
        #createUserFormControls button {
            padding: 4px 8px; font-size: 0.7rem; flex-shrink: 0;
            background-color: var(--success) !important; height: 28px;
            border: none; color: var(--text-on-accent); cursor: pointer;
        }
        #generatedUserKey { margin-top: 6px; font-size: 0.75rem; min-height: 1em; color: var(--success); word-break: break-all;}

        #managedUsersListContainer {
             max-height: 350px;
             overflow-y: auto;
             border: 1px solid var(--border-color);
             border-radius: 4px;
        }

        #managedUsersListContainer .admin-list-header,
        #managedUsersListContainer .history-item.managed-user-item {
            display: grid;
            /* D&T | User | Key | St | Exp | Act */
            grid-template-columns: minmax(55px, 0.7fr) minmax(50px, 0.9fr) minmax(70px, 1.2fr) minmax(30px, 0.4fr) minmax(55px, 0.7fr) minmax(38px, 0.4fr);
            gap: 0.25px; /* Very tight gap */
            padding: 0.5px 1px; /* Extremely tight padding */
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            font-size: 0.52rem; /* Aggressively small font for items */
            line-height: 1.1; /* Tight line height */
        }
        #managedUsersListContainer .admin-list-header {
            font-weight: bold;
            color: var(--primary);
            font-size: 0.50rem; /* Header slightly smaller or same */
            background-color: var(--bg-header-footer) !important;
            text-transform: uppercase;
            padding: 2px 1px; /* Header padding */
            white-space: nowrap;
        }

        #managedUsersListContainer .admin-list-header .history-header-item,
        #managedUsersListContainer .history-item.managed-user-item .history-value {
            text-align: left;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 1px 2px; /* Minimal cell padding */
            vertical-align: middle;
        }
         #managedUsersListContainer .history-item.managed-user-item .history-value.key-cell {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.48rem; /* Even smaller for keys if needed */
        }

        #managedUsersListContainer .admin-list-header .history-header-item { color: var(--primary); }
        #managedUsersListContainer .history-item.managed-user-item {
            background-color: var(--bg-interactive);
            margin-bottom: 0;
            border-radius: 0;
        }
        #managedUsersListContainer .history-item.managed-user-item:last-child {
            border-bottom: none;
        }
        #managedUsersListContainer .history-item.managed-user-item:hover { background-color: var(--bg-hover); }

        #managedUsersListContainer .admin-list-header .history-header-item:nth-child(4),
        #managedUsersListContainer .history-item.managed-user-item .history-value:nth-child(4),
        #managedUsersListContainer .admin-list-header .history-header-item:last-child,
        #managedUsersListContainer .history-item.managed-user-item .history-value:last-child {
            text-align: center;
            justify-content: center;
        }
        #managedUsersListContainer .history-item.managed-user-item .history-value button.admin-action-btn {
            font-size: 0.75em; /* Small icons for buttons */
            padding: 0 1.5px; /* Tight padding for buttons */
            margin: 0 0.25px; /* Minimal margin */
            background-color: var(--bg-card);
            color:var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius:1px; /* Minimal radius */
            cursor:pointer;
            min-width: 12px; /* Smallest clickable size */
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        #managedUsersListContainer .history-item.managed-user-item .history-value button.ban-btn { border-color: var(--danger); color: var(--danger); }
        #managedUsersListContainer .history-item.managed-user-item .history-value button.unban-btn { border-color: var(--success); color: var(--success); }
        #managedUsersListContainer .history-item.managed-user-item .history-value button.delete-btn { border-color: var(--warning); color: var(--warning); }
        #managedUsersListContainer .history-item.managed-user-item .history-value button.rename-btn { border-color: var(--info); color: var(--info); }


        @media (max-width: 768px) {
            /* Styles from previous responses for other elements */
            .main-interactive-area { flex-direction: column; align-items: stretch; }
            .output-area { max-width: 100%; margin-top: 0.5rem; }
            #currentResult { white-space: normal; overflow-x: hidden; font-size: 0.9rem; }
            .admin-section { background-color: var(--bg-admin-section-mobile); padding: 8px; margin-bottom: 10px;}
            #adminUserManagementTopControls { flex-direction: column; align-items: stretch; gap: 8px; }

            #managedUsersListContainer { max-height: 280px; }
            #managedUsersListContainer .admin-list-header,
            #managedUsersListContainer .history-item.managed-user-item {
                grid-template-columns: minmax(50px, 0.7fr) minmax(45px, 0.8fr) minmax(65px, 1.1fr) minmax(25px, 0.4fr) minmax(50px, 0.7fr) minmax(40px, 0.4fr);
                font-size: 0.48rem;
            }
             #managedUsersListContainer .admin-list-header { font-size: 0.46rem; }
             #managedUsersListContainer .history-item.managed-user-item .history-value.key-cell { font-size: 0.46rem; }
             #managedUsersListContainer .history-item.managed-user-item .history-value button.admin-action-btn { font-size: 0.7em; min-width: 12px; padding: 0.5px 1px;}
        }

        @media (max-width: 576px) {
             /* Styles from previous responses for other elements */
            body { font-size: 13px; }
            h1 { font-size: 1.3rem; }
            .admin-section { padding: 5px; margin-bottom: 8px; }

            #managedUsersListContainer { max-height: 250px; }
            #managedUsersListContainer .admin-list-header,
            #managedUsersListContainer .history-item.managed-user-item {
                grid-template-columns: minmax(40px, 0.65fr) minmax(35px, 0.7fr) minmax(50px, 1.1fr) minmax(20px, 0.3fr) minmax(40px, 0.65fr) minmax(35px, 0.35fr);
                font-size: 0.42rem; /* Extremely small for smallest screens */
                line-height: 1;
            }
             #managedUsersListContainer .admin-list-header { font-size: 0.40rem; padding: 1px;}
             #managedUsersListContainer .history-item.managed-user-item .history-value.key-cell { font-size: 0.40rem; }
             #managedUsersListContainer .history-item.managed-user-item .history-value button.admin-action-btn { font-size: 0.65em; min-width: 10px; padding: 0;}
        }
    </style>
</head>
<body>
    <div id="loginModal" class="info-modal" style="display: none;">
        <div class="info-modal-content" style="width: 90%; max-width: 320px;">
            <h3 style="text-align: center;">Enter Access Key</h3>
            <input type="password" id="accessKeyInput" placeholder="Access Key" style="width: 100%; padding: 10px; margin-bottom: 12px; background-color: var(--bg-interactive); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 0.9rem;">
            <button id="loginButton" style="width: 100%; padding: 10px; background-color: var(--primary); color: var(--text-on-accent); border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">Login</button>
            <p id="loginError" style="color: var(--danger); font-size: 0.8rem; margin-top: 8px; text-align: center; display: none;">Invalid Access Key</p>
        </div>
    </div>

    <div id="geminiAnalysisModal" class="gemini-modal">
        <div class="gemini-modal-content">
            <span class="gemini-modal-close-button" id="geminiModalCloseButton">&times;</span>
            <h3><i class="fas fa-magic"></i> Gemini AI Analysis</h3>
            <div id="geminiAnalysisText">
                <div class="gemini-loading"><i class="fas fa-spinner fa-spin"></i> Loading analysis...</div>
            </div>
        </div>
    </div>

    <div id="renameUserModal" class="info-modal" style="display: none;">
        <div class="info-modal-content" style="max-width: 380px;">
            <span class="info-modal-close-button" id="renameUserModalCloseButton">&times;</span>
            <h3><i class="fas fa-edit"></i> Rename User</h3>
            <p style="font-size: 0.8rem; margin-bottom: 8px;">Current User: <strong id="currentUsernameRename">N/A</strong></p>
            <input type="text" id="newUsernameInput" placeholder="Enter new username" style="width: 100%; padding: 8px; margin-bottom: 12px; background-color: var(--bg-interactive); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 0.85rem;">
            <input type="hidden" id="userAccessKeyToRename">
            <div style="display: flex; justify-content: flex-end; gap: 8px;">
                <button id="cancelRenameBtn" class="clear-btn" style="background-color: var(--secondary);">Cancel</button>
                <button id="saveRenameBtn" class="gemini-button" style="background-color: var(--success);">Save Name</button>
            </div>
        </div>
    </div>


    <div class="container" id="appContainer" style="display: none;">
        <header>
            <div class="header-title-container">
                <h1>Predict VIP King Pro</h1>
            </div>
            <div class="header-subtitle-container">
                <span>AI GOLD EDITION (v17.8 Reviewed)</span>
                <a href="https://www.bdgin03.com//#/register?invitationCode=3783710836033" target="_blank" class="header-action-icon" title="Register"> <i class="fas fa-user-plus"></i> </a>
                <a href="#" id="soundToggleBtn" class="header-action-icon" title="Mute Sound"> <i class="fas fa-volume-up"></i> </a>
                <a href="#" id="contactModalLink" class="header-action-icon" title="Contact Details"> <i class="fas fa-envelope"></i> </a>
                <a href="#" id="aboutModalLink" class="header-action-icon" title="About & How to Use"> <i class="fas fa-info-circle"></i> </a>
                <a href="#" id="themeToggleBtn" class="header-action-icon" title="Toggle Theme"> <i class="fas fa-sun"></i> </a>
                <a href="#" id="logoutButton" class="header-action-icon" title="Logout" style="display: none; margin-left: 5px;"> <i class="fas fa-sign-out-alt"></i> </a>
            </div>
        </header>

        <div id="aboutModal" class="info-modal">
             <div class="info-modal-content">
                <span class="info-modal-close-button" id="aboutModalCloseButton">&times;</span>
                <h3><i class="fas fa-info-circle"></i> How to Use Predict VIP King Pro</h3>
                <p>The system automatically analyzes game history to predict Big/Small and Color status, now with enhanced AI and Voice Output.</p>
                <ul>
                    <li><strong>UI Themes:</strong> Supports "Crimson Night" (dark) and "Ocean Breeze" (light) themes. Toggle with the sun/moon icon.</li>
                    <li><strong>AI Engine:</strong> Primary B/S, Color trend from last 10 games. Number prediction uses up to 100 games from cache. Reversal logic (enhanced) applied after losses.</li>
                    <li><strong>Prediction Output:</strong> Shows B/S, Color, Predicted Numbers (3), Confidence (Per), Reversal (Rev), and Strategy (Stgy).</li>
                    <li><strong>Voice Output:</strong> Key predictions & number wins are announced. Sound can be toggled.</li>
                    <li><strong>History Tabs:</strong> Game History (latest 10), Deep (latest 100), My Predictions (paginated), Analytics.</li>
                    <li><strong>Jarvis AI Analytics:</strong> Redesigned card showing AI performance (L10-L50 with W/L/P) and alerts. Can be toggled.</li>
                    <li><strong>Gemini Analysis:</strong> Get deeper insights into AI predictions by clicking the "✨ Deeper Analysis" button on the main prediction. Requires your own Gemini API Key.</li>
                    <li><strong>API Status:</strong> Shows 'Online' if internet is connected, 'Offline' if internet is disconnected.</li>
                </ul>
                <p><i class="fas fa-exclamation-triangle disclaimer-icon"></i> <span class="disclaimer-text">Disclaimer:</span> AI predictions are for analysis and educational purposes only. Use responsibly.</p>
            </div>
        </div>
        <div id="contactModal" class="info-modal">
            <div class="info-modal-content">
                <span class="info-modal-close-button" id="contactModalCloseButton">&times;</span>
                <h3><i class="fas fa-envelope"></i> Contact Information</h3>
                <div class="contact-item"> <strong>Email:</strong> vippredictking@zohomail.in </div>
                <div class="contact-item"> <strong>Developer:</strong> Kumghato </div>
                <p style="font-size: 0.7rem; margin-top: 10px; color: var(--text-secondary);">For support or inquiries, please use the email above.</p>
            </div>
        </div>

        <div class="card" id="jarvisAnalyticsCard">
            <div class="card-title">
                <div><i class="fas fa-robot"></i> Jarvis AI Analytics</div>
                <div>
                    <a href="#" id="toggleJarvisCard" class="header-action-icon" title="Toggle Analytics">
                        <i class="fas fa-eye"></i>
                    </a>
                </div>
            </div>
            <div id="jarvisAnalyticsContent" style="padding: 8px 10px;">
                <div class="jarvis-stats-bar">
                    <div class="jarvis-stat-item">
                        <span class="jarvis-label">L10:</span>
                        <span class="jarvis-value" id="jarvisL10Rate">N/A</span>
                        <span class="jarvis-details" id="jarvisL10Details">(0W/0L/0P)</span>
                    </div>
                    <div class="jarvis-stat-item">
                        <span class="jarvis-label">L20:</span>
                        <span class="jarvis-value" id="jarvisL20Rate">N/A</span>
                        <span class="jarvis-details" id="jarvisL20Details">(0W/0L/0P)</span>
                    </div>
                    <div class="jarvis-stat-item">
                        <span class="jarvis-label">L30:</span>
                        <span class="jarvis-value" id="jarvisL30Rate">N/A</span>
                        <span class="jarvis-details" id="jarvisL30Details">(0W/0L/0P)</span>
                    </div>
                    <div class="jarvis-stat-item">
                        <span class="jarvis-label">L50:</span>
                        <span class="jarvis-value" id="jarvisL50Rate">N/A</span>
                        <span class="jarvis-details" id="jarvisL50Details">(0W/0L/0P)</span>
                    </div>
                </div>
                <div id="jarvisAlertsContainer" style="margin-top: 8px;">
                    </div>
                <div style="text-align: right; margin-top: 5px; font-size: 0.75rem;">
                    Overall: <strong id="jarvisOverall" style="font-weight: bold;">N/A</strong>
                </div>
            </div>
        </div>

        <div class="top-info-line">
            <div class="top-info-item" id="timerInfoItem"> <i class="fas fa-clock"></i><span class="value" id="timer">00s</span> </div>
            <div class="top-info-item" id="periodInfoItem"> <i class="fas fa-hashtag"></i><span class="value" id="period">N/A</span> </div>
            <div class="top-info-item" id="statusInfoItem"> <i class="fas fa-bolt"></i><span class="value" id="status">Active</span> </div>
            <div class="top-info-item" id="apiStatusInfoItem"> <i class="fas fa-server"></i><span class="value" id="apiStatus">Checking...</span> </div>
        </div>

        <div class="prediction-section">
            <div class="prediction-card card">
                <div class="card-title">
                    <div><i class="fas fa-brain"></i> AI Prediction Output</div>
                    <button id="deeperAnalysisBtn" class="gemini-button" title="Get Deeper Analysis of AI Prediction">✨ Deeper Analysis</button>
                </div>
                <div class="main-interactive-area">
                    <div class="output-area">
                        <div class="result-display" style="margin-top:0; padding: 0.3rem;">
                            <div id="currentResult">
                                <i class="fas fa-hourglass-half fa-spin"></i> Waiting for next prediction...
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="card">
            <h2 class="card-title">
                <div><i class="fas fa-history"></i> History & Analytics</div>
                <button id="clearMyPredictionsBtn" class="clear-btn" title="Clear My Predictions Log">
                    <i class="fas fa-trash-alt"></i> Clear
                </button>
            </h2>
            <div class="stats-bar" id="sessionStatsBar">
                <div class="stats-bar-item">Wins: <strong id="statsWins" class="win">0</strong></div>
                <div class="stats-bar-item">Loss: <strong id="statsLosses" class="loss">0</strong></div>
                <div class="stats-bar-item">Part: <strong id="statsPartials" class="partial">0</strong></div>
                <div class="stats-bar-item">Acc: <strong id="statsAccuracy" class="acc">0%</strong></div>
                <div class="stats-bar-item">Rev: <strong id="statsAiRev" class="rev">0%</strong></div>
                <div class="stats-bar-item">Lv: <strong id="statsLevel" class="level">Normal</strong></div>
            </div>
            <div class="tabs">
                <button class="active" onclick="fetchData(1, 'game')"> <i class="fas fa-gamepad"></i> Game </button>
                <button onclick="fetchData(1, 'deep')"> <i class="fas fa-layer-group"></i> Deep (100) </button>
                <button onclick="fetchData(1, 'chart')"> <i class="fas fa-chart-line"></i> Chart </button>
                <button onclick="fetchData(1, 'my')"> <i class="fas fa-user-clock"></i> History </button>
                <button id="adminDashboardTab" onclick="fetchData(1, 'admin_dashboard')" style="display: none;"> <i class="fas fa-user-shield"></i> Admin </button>
            </div>
            <div class="my-history-controls" id="myHistoryControls" style="display: none;">
                <label for="entriesPerPage">Show:</label>
                <select id="entriesPerPage" onchange="changeMyHistoryEntriesPerPage(this.value)">
                    <option value="10">10 entries</option>
                    <option value="25">25 entries</option>
                    <option value="50">50 entries</option>
                </select>
            </div>
            <div class="history-header" id="gameHistoryHeader">
                </div>
            <div class="history-header" id="myHistoryHeader">
                </div>
            <div id="adminDashboardHeader" style="display: none;"></div>

            <div class="history-content" id="historyContent">
                <div style="text-align: center; padding: 2rem;"> <i class="fas fa-spinner fa-spin fa-lg" style="color: var(--primary);"></i> Loading data... </div>
            </div>
            <div class="pagination" id="paginationControls" style="display:none;">
                <button id="prevPageBtn" onclick="changePage(-1)" disabled><i class="fas fa-chevron-left"></i></button>
                <button id="currentPageBtn" class="active">1</button>
                <button id="nextPageBtn" onclick="changePage(1)"><i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
    </div>

    <div class="floating-notification" id="notification">
        <i class="fas fa-check-circle"></i>
        <span id="notificationText">Notification Text</span>
    </div>

<script>
    // --- Global Variables ---
    let lastCompletedPeriodNumber = null;
    let history = [];
    let cachedData = [];
    let currentPredictionData = {};
    let currentPage = 1;
    let currentTab = 'game';
    let isFetchingPage = false;
    let isWaitingForResult = false;
    let consecutiveLosses = 0;
    let consecutiveWins = 0;
    let sessionStats = { wins: 0, losses: 0, partials: 0 };
    let lastAiReversalChance = 0;
    let currentStrategyLevel = "Normal";
    let lastTimerUpdate = 0;
    const POLLING_INTERVAL = 750;
    const POLLING_TIMEOUT = 15000;
    const fixedSelectedServerName = 'AutoAnalysisEngine';
    let myHistoryItemsPerPage = 10;
    const GAME_HISTORY_ITEMS_PER_PAGE = 10;
    const DEEP_HISTORY_ITEMS_PER_PAGE = 100;
    let isSoundOn = true;


    // --- Admin & Storage Keys ---
    const ADMIN_ACCESS_KEY = "ADMIN123";
    let currentUserRole = null;
    const STORAGE_KEY_USER_ROLE = 'predictVIPKingPro_userRole_v3';
    const STORAGE_KEY_CURRENT_USER_KEY = 'predictVIPKingPro_currentUserKey_v2';
    const STORAGE_KEY_MANAGED_USERS = 'predictVIPKingPro_managedUsers_v3';
    const STORAGE_KEY_THEME = 'predictVIPKingPro_theme_v17';
    const STORAGE_KEY_MY_HISTORY = 'predictVIPKingPro_myHistory_v4';
    const STORAGE_KEY_SESSION_STATS = 'predictVIPKingPro_sessionStats_v2';
    const STORAGE_KEY_CONSECUTIVE_WINS = 'predictVIPKingPro_consecutiveWins_v2';
    const STORAGE_KEY_CONSECUTIVE_LOSSES = 'predictVIPKingPro_consecutiveLosses_v2';
    const STORAGE_KEY_MY_HISTORY_ITEMS_PER_PAGE = 'predictVIPKingPro_myHistoryItemsPerPage_v2';
    const STORAGE_KEY_JARVIS_VISIBLE = 'predictVIPKingPro_jarvisCardVisible_v1';
    const STORAGE_KEY_SOUND_ON = 'predictVIPKingPro_soundOn_v1';

    // --- API Status Function (Simplified as per request) ---
    function setApiStatus() {
        const el = document.getElementById('apiStatus'); if (!el) return;
        const iconEl = el.previousElementSibling;
        el.classList.remove('status-online', 'status-offline', 'status-error'); // Ensure error class is removed
        let baseStatusText = '';
        let statusClass = '';
        let colorVar = 'var(--text-secondary)';
        let newIconClass = 'fas fa-server';

        if (navigator.onLine) {
            baseStatusText = 'Online';
            statusClass = 'status-online';
            colorVar = 'var(--success)';
            newIconClass = 'fas fa-signal';
        } else {
            baseStatusText = 'Offline';
            statusClass = 'status-offline';
            colorVar = 'var(--danger)';
            newIconClass = 'fas fa-times-circle';
        }

        el.textContent = baseStatusText;
        if (statusClass) el.classList.add(statusClass);
        el.style.color = colorVar;
        if (iconEl && iconEl.tagName === 'I') {
            iconEl.className = newIconClass;
        }
    }

    // --- Theme Management ---
    let currentTheme = 'dark'; // Default theme key
    const themes = {
        dark: { // New "Crimson Night"
            '--primary': '#C62828',       // Crimson Red
            '--secondary': '#FF8F00',      // Amber/Dark Orange
            '--success': '#2E7D32',       // Dark Green
            '--danger': '#D32F2F',        // Standard Red
            '--warning': '#F9A825',       // Standard Yellow/Amber
            '--info': '#0277BD',         // Standard Blue
            '--violet-accent': '#D84315', /* Deep Orange as violet replacement */

            '--bg-main': '#121212',         /* Very Dark Grey/Almost Black */
            '--bg-card': '#1E1E1E',         /* Dark Grey */
            '--bg-header-footer': '#0D0D0D',/* Near Black */
            '--bg-interactive': '#2C2C2C',   /* Slightly Lighter Grey */
            '--bg-hover': '#383838',         /* Lighter Grey on Hover */
            '--bg-admin-section-mobile': '#252525',
            '--bg-modal-overlay': 'rgba(0,0,0,0.9)',
            '--bg-gemini-modal': '#1A1A1A',

            '--text-primary': '#E0E0E0',     /* Light Grey */
            '--text-secondary': '#B0B0B0',     /* Medium Grey */
            '--text-disabled': '#505050',      /* Darker Grey */
            '--text-on-accent': '#FFFFFF',

            '--text-win': 'var(--success)',
            '--text-loss': 'var(--danger)',
            '--text-partial': 'var(--secondary)', // Use new secondary
            '--text-error': 'var(--warning)',
            '--text-num-red': 'var(--danger)',
            '--text-num-green': 'var(--success)',

            '--partial-bg': 'rgba(255, 143, 0, 0.15)', /* Amber bg for partial */
            '--win-bg': 'rgba(46, 125, 50, 0.15)',
            '--loss-bg': 'rgba(211, 47, 47, 0.15)',
            '--error-bg': 'rgba(249, 168, 37, 0.15)',

            '--border-color': '#333333',      /* Darker border */
            '--shadow': '0 5px 20px rgba(0, 0, 0, 0.85)',
            '--tick-color': 'var(--success)',
            '--cross-color': 'var(--danger)',
            '--body-bg-gradient-start': '#100000', /* Very dark red-ish black */
            '--body-bg-gradient-end': '#000000'    /* Black */
        },
        light: { // New "Ocean Breeze"
            '--primary': '#00838F',       // Cyan/Teal
            '--secondary': '#FFC107',      // Amber/Gold
            '--success': '#4CAF50',       // Standard Light Green
            '--danger': '#F44336',        // Standard Light Red
            '--warning': '#FFEB3B',       // Standard Light Yellow
            '--info': '#2196F3',         // Standard Light Blue
            '--violet-accent': '#673AB7', /* Deep Purple accent */

            '--bg-main': '#E0F7FA',         /* Very Light Cyan */
            '--bg-card': '#FFFFFF',         /* White */
            '--bg-header-footer': '#B2EBF2',/* Light Cyan */
            '--bg-interactive': '#CFD8DC',   /* Light Blue Grey */
            '--bg-hover': '#B0BEC5',         /* Slightly darker Blue Grey */
            '--bg-admin-section-mobile': '#D7EEF2',
            '--bg-modal-overlay': 'rgba(0, 77, 64, 0.6)', /* Tealish overlay */
            '--bg-gemini-modal': '#FAFAFA',

            '--text-primary': '#263238',     /* Dark Blue Grey */
            '--text-secondary': '#546E7A',     /* Blue Grey */
            '--text-disabled': '#9E9E9E',      /* Grey */
            '--text-on-accent': '#FFFFFF',    /* White on accent colors */

            '--text-win': 'var(--success)',
            '--text-loss': 'var(--danger)',
            '--text-partial': 'var(--secondary)', // Use new secondary
            '--text-error': 'var(--warning)',
            '--text-num-red': 'var(--danger)',
            '--text-num-green': 'var(--success)',

            '--partial-bg': 'rgba(255, 193, 7, 0.1)', /* Amber bg for partial */
            '--win-bg': 'rgba(76, 175, 80, 0.1)',
            '--loss-bg': 'rgba(244, 67, 54, 0.08)',
            '--error-bg': 'rgba(255, 235, 59, 0.1)',

            '--border-color': '#90A4AE',      /* Blue Grey border */
            '--shadow': '0 3px 10px rgba(0, 0, 0, 0.1)',
            '--tick-color': 'var(--success)',
            '--cross-color': 'var(--danger)',
            '--body-bg-gradient-start': '#A7FFEB', /* Very light teal */
            '--body-bg-gradient-end': '#E0F2F1'    /* Almost white teal */
        }
    };
    function applyTheme(themeName) {
        const theme = themes[themeName];
        if (!theme) {
            console.warn(`Theme "${themeName}" not found. Defaulting to "dark" (Crimson Night).`);
            applyTheme('dark');
            return;
        }
        document.body.classList.remove('dark-theme', 'light-theme'); // Generic classes for potential global overrides
        document.body.classList.add(themeName + '-theme'); // Specific theme class if needed

        for (const variable in theme) {
            if (variable.startsWith('--body-bg-gradient')) continue;
            document.documentElement.style.setProperty(variable, theme[variable]);
        }
        document.body.style.background = `linear-gradient(180deg, ${theme['--body-bg-gradient-start']} 0%, ${theme['--body-bg-gradient-end']} 100%)`;
        document.body.style.color = theme['--text-primary'];
        currentTheme = themeName; // This will be 'dark' or 'light'
        robustLocalStorageSetItem(STORAGE_KEY_THEME, themeName);

        const themeToggleIcon = document.querySelector('#themeToggleBtn i');
        if (themeToggleIcon) {
            if (themeName === 'dark') { // "Crimson Night" is our 'dark' key
                themeToggleIcon.classList.remove('fa-moon'); themeToggleIcon.classList.add('fa-sun');
                if(themeToggleIcon.parentElement) themeToggleIcon.parentElement.title = "Switch to Ocean Breeze (Light)";
            } else { // "Ocean Breeze" is our 'light' key
                themeToggleIcon.classList.remove('fa-sun'); themeToggleIcon.classList.add('fa-moon');
                if(themeToggleIcon.parentElement) themeToggleIcon.parentElement.title = "Switch to Crimson Night (Dark)";
            }
        }
    }
    function toggleTheme() {
        applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
    }

    // --- Local Storage Utilities ---
    function robustJsonParse(key, defaultValue) { try { const val = localStorage.getItem(key); return val === null ? defaultValue : JSON.parse(val) || defaultValue; } catch (e) { return defaultValue; } }
    function robustLocalStorageGetItem(key, defaultValue, isNum = false) { try { const val = localStorage.getItem(key); if (val === null) return defaultValue; if (isNum) { const num = parseInt(val); return isNaN(num) ? defaultValue : num; } return val; } catch (e) { return defaultValue; } }
    function robustLocalStorageSetItem(key, value) { try { localStorage.setItem(key, value); } catch (e) { console.warn("Error setting localStorage:", e); } }
    function saveMyHistoryToStorage() { robustLocalStorageSetItem(STORAGE_KEY_MY_HISTORY, JSON.stringify(history)); }
    function loadMyHistoryFromStorage() { history = robustJsonParse(STORAGE_KEY_MY_HISTORY, []); }
    function saveSessionStateToStorage() { robustLocalStorageSetItem(STORAGE_KEY_SESSION_STATS, JSON.stringify(sessionStats)); robustLocalStorageSetItem(STORAGE_KEY_CONSECUTIVE_WINS, consecutiveWins.toString()); robustLocalStorageSetItem(STORAGE_KEY_CONSECUTIVE_LOSSES, consecutiveLosses.toString()); }
    function loadSessionStateFromStorage() { sessionStats = robustJsonParse(STORAGE_KEY_SESSION_STATS, { wins: 0, losses: 0, partials: 0 }); consecutiveWins = robustLocalStorageGetItem(STORAGE_KEY_CONSECUTIVE_WINS, 0, true); consecutiveLosses = robustLocalStorageGetItem(STORAGE_KEY_CONSECUTIVE_LOSSES, 0, true); }
    function resetSessionStatistics() { sessionStats = { wins: 0, losses: 0, partials: 0 }; consecutiveWins = 0; consecutiveLosses = 0; lastAiReversalChance = 0; currentStrategyLevel = "Normal"; saveSessionStateToStorage(); if (document.getElementById('statsWins')) { updateSessionStatsBar(); updateJarvisCard(); } }
    function saveMyHistoryItemsPerPageToStorage() { robustLocalStorageSetItem(STORAGE_KEY_MY_HISTORY_ITEMS_PER_PAGE, myHistoryItemsPerPage.toString()); }
    function loadMyHistoryItemsPerPageFromStorage() { myHistoryItemsPerPage = robustLocalStorageGetItem(STORAGE_KEY_MY_HISTORY_ITEMS_PER_PAGE, 10, true); const selectEl = document.getElementById('entriesPerPage'); if (selectEl) selectEl.value = myHistoryItemsPerPage; }

    // --- API & Game Data Handling ---
    async function fetchPage(pageNoToFetch, isPriority = false) {
        if (!navigator.onLine) {
            setApiStatus(); // Will reflect 'Offline'
            return [];
        }
        if (isFetchingPage && !isPriority && pageNoToFetch > 1) { // Allow priority fetch for page 1 even if another is ongoing
            console.log(`Workspace for page ${pageNoToFetch} skipped, another fetch in progress.`);
            return [];
        }

        isFetchingPage = true;
        // console.log(`Workspaceing page: ${pageNoToFetch}`);
        try {
            const resp = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({
                    pageSize: 10,
                    pageNo: pageNoToFetch,
                    typeId: 1,
                    language: 0,
                    random: "4a0522c6ecd8410496260e686be2a57c",
                    signature: "334B5E70A0C9B8918B0B15E517E2069C",
                    timestamp: Math.floor(Date.now() / 1000)
                })
            });

            setApiStatus(); // Reflect navigator.onLine (likely 'Online' if this part is reached)

            if (!resp.ok) {
                const errorText = await resp.text();
                console.error(`API request failed: ${resp.status} ${resp.statusText} for page ${pageNoToFetch}. Response: ${errorText}`);
                return []; // Do not change API status display from 'Online' if internet is on
            }

            const data = await resp.json();
            if (data.code === 0 && data.data && Array.isArray(data.data.list)) {
                const fetchedMap = new Map(data.data.list.map(item => [item.issueNumber, item]));
                const cachedMap = new Map(cachedData.map(item => [item.issueNumber, item]));
                const combinedMap = new Map([...cachedMap, ...fetchedMap]);
                cachedData = Array.from(combinedMap.values())
                                .sort((a,b) => parseInt(b.issueNumber||0) - parseInt(a.issueNumber||0))
                                .slice(0, DEEP_HISTORY_ITEMS_PER_PAGE + 20); // Keep slightly more than 100 for buffer

                if (isPriority && currentUserRole && (getActiveTab() === 'game' || getActiveTab() === 'deep')) {
                    // Data has been updated, re-render the current view for game/deep if it was a priority fetch (e.g. new period)
                    fetchData(currentPage, getActiveTab(), true);
                }
                return data.data.list;
            } else {
                console.error(`API data error (Code: ${data.code}) on page ${pageNoToFetch}:`, data);
                return []; // Do not change API status display from 'Online'
            }
        } catch (e) {
            console.error("fetchPage critical error:", e);
            setApiStatus(); // Reflect navigator.onLine
            return [];
        } finally {
            isFetchingPage = false;
        }
    }
    async function fetchOptimizedData(itemsNeeded = DEEP_HISTORY_ITEMS_PER_PAGE) {
        if (cachedData.length < itemsNeeded) {
            // Fetch enough pages to likely cover the deficit
            const pagesToFetch = Math.max(1, Math.ceil((itemsNeeded - cachedData.length) / 10));
            console.log(`Optimized fetch: Need ${itemsNeeded}, have ${cachedData.length}. Fetching ${pagesToFetch} more pages.`);
            for (let i = 1; i <= pagesToFetch; i++) {
                if (cachedData.length >= itemsNeeded + 10) break; // Break if we have enough plus a small buffer
                await fetchPage(i); // This fetches page i from API and updates global cachedData
            }
        }
        return cachedData.slice(0, itemsNeeded);
    }
    function getNumberDetails(numStr) {
        const num = parseInt(numStr, 10);
        if (isNaN(num) || num === null || num < 0 || num > 9) {
            return { numberVal: '?', bigSmall: '?', colorDisplayHTML: '?', colorForHistory: '?', rawColor: 'Unknown', isViolet: false, numberClass: '', bsClass: '', bsResultClass: '' };
        }
        const bigSmall = num >= 5 ? 'Big' : 'Small';
        let colorDisplayHTML = '', colorForHistory = '', rawColor = 'Unknown', isViolet = false, numberClass = '', bsClass = '', bsResultClass = '';
        bsClass = bigSmall === 'Big' ? 'gh-bs-big' : 'gh-bs-small';
        bsResultClass = bigSmall === 'Big' ? 'result-bs-big' : 'result-bs-small';
        let colorName = '';
        let dotClasses = [];
        if (num === 0) {
            rawColor = 'Red'; isViolet = true; numberClass = 'gh-num-red';
            colorName = 'Red+Violet';
            dotClasses.push('color-red', 'color-violet');
        } else if (num === 5) {
            rawColor = 'Green'; isViolet = true; numberClass = 'gh-num-green';
            colorName = 'Green+Violet';
            dotClasses.push('color-green', 'color-violet');
        } else if ([2,4,6,8].includes(num)) {
            rawColor = 'Red'; numberClass = 'gh-num-red';
            colorName = 'Red';
            dotClasses.push('color-red');
        } else if ([1,3,7,9].includes(num)) {
            rawColor = 'Green'; numberClass = 'gh-num-green';
            colorName = 'Green';
            dotClasses.push('color-green');
        } else {
            colorName = '?';
        }
        let dotsHTML = dotClasses.map(cls => `<span class="color-dot ${cls}"></span>`).join('');
        colorDisplayHTML = `${dotsHTML}${colorName}`;
        colorForHistory = `${dotsHTML} ${colorName}`;
        return { numberVal: num, bigSmall, colorDisplayHTML, colorForHistory, rawColor, isViolet, numberClass, bsClass, bsResultClass };
    }
    async function fetchGameResult(period) { try { let found = cachedData.find(item => item.issueNumber === period); if (found && typeof found.number !== 'undefined' && found.number !== null) { return getNumberDetails(found.number); } await fetchPage(1, true); found = cachedData.find(item => item.issueNumber === period); if (found && typeof found.number !== 'undefined' && found.number !== null) { return getNumberDetails(found.number); } return null; } catch (e) { console.error(`WorkspaceGameResult err for period ${period}:`, e); return null; } }

    // --- AI Prediction Engine ---
    function analyzeForTypeInternal(type, gameHistory, gamesToConsider) { const recentGames = gameHistory.slice(0, gamesToConsider).filter(item => item && typeof item.number !== 'undefined' && item.number !== null); if(recentGames.length === 0) return { trend: null, probability: 0, count: 0, total: 0, streak: 0 }; let outcomes = []; if (type === 'bigsmall') { outcomes = recentGames.map(item => getNumberDetails(item.number).bigSmall); } else { outcomes = recentGames.map(item => getNumberDetails(item.number).rawColor); } outcomes = outcomes.filter(o => o !== '?' && o !== 'Unknown'); if (outcomes.length < Math.min(3, gamesToConsider)) return { trend: null, probability: 0, count: 0, total: outcomes.length, streak: 0 }; const counts = outcomes.reduce((acc, value) => { acc[value] = (acc[value] || 0) + 1; return acc; }, {}); let trend = null; let maxCount = 0; for (const outcome in counts) { if (counts[outcome] > maxCount) { maxCount = counts[outcome]; trend = outcome; } else if (counts[outcome] === maxCount) { if(outcomes.length > 0 && outcomes[0] === outcome) trend = outcome; }} const probability = outcomes.length > 0 ? (maxCount / outcomes.length) * 100 : 0; let currentStreak = 0; if (trend && outcomes.length > 0) { for (let i = 0; i < outcomes.length; i++) { if (outcomes[i] === trend) currentStreak++; else break; } } return { trend, probability: parseFloat(probability.toFixed(1)), count: maxCount, total: outcomes.length, streak: currentStreak }; }
    function predictNumbersForTrend(trend, type, gameHistory, gamesToConsider = 100) {
        const recentValidGames = gameHistory.filter(item => item && typeof item.number !== 'undefined' && item.number !== null).slice(0, gamesToConsider);
        let candidateNumbers = [];
        for (let item of recentValidGames) {
            const details = getNumberDetails(item.number);
            if (type === 'bigsmall' && details.bigSmall === trend) {
                candidateNumbers.push(details.numberVal);
            } else if (type === 'redgreen' && details.rawColor === trend) {
                candidateNumbers.push(details.numberVal);
            }
        }
        const numCounts = candidateNumbers.reduce((acc, value) => { acc[value] = (acc[value] || 0) + 1; return acc; }, {});
        const sortedNumbers = Object.keys(numCounts).map(num => ({ num: parseInt(num), count: numCounts[num] })).sort((a, b) => b.count - a.count).map(item => item.num);
        let finalNumbers = [...new Set(sortedNumbers)];
        const allMatchingNumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].filter(n => {
            const d = getNumberDetails(n);
            return ((type === 'bigsmall' && d.bigSmall === trend) || (type === 'redgreen' && d.rawColor === trend)) && !finalNumbers.includes(n);
        });
        finalNumbers.push(...allMatchingNumbers);
        finalNumbers = [...new Set(finalNumbers)];
        let fallbackOrder = [];
        if (finalNumbers.length < 3) {
            if (type === 'bigsmall') {
                fallbackOrder = (trend === 'Big') ? [5,6,7,8,9,0,1,2,3,4] : [0,1,2,3,4,5,6,7,8,9];
            } else {
                if (trend === 'Red') {
                    fallbackOrder = [0,2,4,6,8,1,3,5,7,9];
                } else {
                    fallbackOrder = [1,3,5,7,9,0,2,4,6,8];
                }
            }
            let fallbackIndex = 0;
            while (finalNumbers.length < 3 && fallbackIndex < fallbackOrder.length) {
                let nextNum = fallbackOrder[fallbackIndex];
                if (!finalNumbers.includes(nextNum)) {
                    finalNumbers.push(nextNum);
                }
                fallbackIndex++;
            }
        }
        let absoluteFillValue = 0;
        while (finalNumbers.length < 3) {
            let nextNum = absoluteFillValue % 10;
            if (!finalNumbers.includes(nextNum)) {
                finalNumbers.push(nextNum);
            }
            absoluteFillValue++;
        }
        return finalNumbers.slice(0, 3);
    }
    async function intelligentPredictionEngine(gameHistoryCache) {
        if (!gameHistoryCache || gameHistoryCache.length === 0) {
            console.warn("intelligentPredictionEngine called with empty or invalid gameHistoryCache.");
            const defaultNums = [Math.floor(Math.random()*5), Math.floor(Math.random()*10), Math.floor(Math.random()*10)%5 + 5].sort(); // Random but somewhat plausible
            const defaultDetails = getNumberDetails(defaultNums[0]);
            return { predictedBS: defaultDetails.bigSmall, predictedRawColor: defaultDetails.rawColor, predictedColorHTML: defaultDetails.colorDisplayHTML, predictedNumber: defaultNums[0], predictedNumbersArray: defaultNums, reversalChance: 10, probability: 20, message: "InsufficientData", determinedPredictionType: 'bigsmall' };
        }

        const shortTermGamesToAnalyze = 10;
        const longTermGamesToAnalyzeForNumbers = Math.min(gameHistoryCache.length, 100);
        let applyReverseLogic = false;
        if (consecutiveLosses === 1) { applyReverseLogic = true; currentStrategyLevel = `Auto (Rev L1 Strong)`; }
        else if (consecutiveLosses >= 2) { applyReverseLogic = true; currentStrategyLevel = `Auto (Rev L${consecutiveLosses} V.Strong)`; }
        else { currentStrategyLevel = "Auto"; }

        const actualShortTermGamesToAnalyze = Math.max(1, Math.min(gameHistoryCache.length, shortTermGamesToAnalyze));


        let bsAnalysis = analyzeForTypeInternal('bigsmall', gameHistoryCache, actualShortTermGamesToAnalyze);
        let rgAnalysis = analyzeForTypeInternal('redgreen', gameHistoryCache, actualShortTermGamesToAnalyze);
        let chosenAnalysis, determinedType, primaryCategoryResult; let messageNote = ""; let reversalChance = 15 + Math.random() * 10;

        if (applyReverseLogic) {
            let trendToReverse, typeToReverse, originalAnalysis;
            if (bsAnalysis.probability > rgAnalysis.probability + 5 || (bsAnalysis.probability > rgAnalysis.probability && bsAnalysis.streak >= rgAnalysis.streak)) { originalAnalysis = bsAnalysis; typeToReverse = 'bigsmall'; }
            else if (rgAnalysis.probability > bsAnalysis.probability + 5 || (rgAnalysis.probability > bsAnalysis.probability && rgAnalysis.streak >= bsAnalysis.streak)) { originalAnalysis = rgAnalysis; typeToReverse = 'redgreen'; }
            else { originalAnalysis = (bsAnalysis.total >= rgAnalysis.total) ? bsAnalysis : rgAnalysis; typeToReverse = (bsAnalysis.total >= rgAnalysis.total) ? 'bigsmall' : 'redgreen'; }
            trendToReverse = originalAnalysis.trend;

            if (!trendToReverse) { // Fallback if no trend found in original analysis
                typeToReverse = (bsAnalysis.total >= rgAnalysis.total && bsAnalysis.trend) ? 'bigsmall' : 'redgreen';
                const lastGameDetail = gameHistoryCache[0] ? getNumberDetails(gameHistoryCache[0].number) : null;
                trendToReverse = typeToReverse === 'bigsmall' ? (lastGameDetail ? (lastGameDetail.bigSmall === 'Big' ? 'Big' : 'Small') : 'Small') : (lastGameDetail ? lastGameDetail.rawColor : 'Green');
                if(trendToReverse === 'Unknown' || trendToReverse === '?') trendToReverse = typeToReverse === 'bigsmall' ? 'Small' : 'Green';
                originalAnalysis = { probability: 50, streak: 0, total: actualShortTermGamesToAnalyze, trend: trendToReverse};
            }
            determinedType = typeToReverse;
            primaryCategoryResult = (determinedType === 'bigsmall') ? (trendToReverse === 'Big' ? 'Small' : 'Big') : (trendToReverse === 'Red' ? 'Green' : 'Red');
            let reversedProbability = 50 + (5 * consecutiveLosses) - (originalAnalysis.probability / 5) + (originalAnalysis.streak * 1.5);
            reversedProbability = Math.min(75, Math.max(40, reversedProbability));
            chosenAnalysis = {
                trend: primaryCategoryResult,
                probability: parseFloat(reversedProbability.toFixed(1)),
                count: originalAnalysis.count || 0,
                total: originalAnalysis.total || actualShortTermGamesToAnalyze,
                streak: 0
            };
            messageNote = `(Reversing L${consecutiveLosses} from ${trendToReverse})`;
            reversalChance = 65 + consecutiveLosses * 8;
            reversalChance = Math.min(92, reversalChance);
        } else {
            if (bsAnalysis.trend && rgAnalysis.trend) {
                 if (bsAnalysis.streak > rgAnalysis.streak + 1 && bsAnalysis.probability > 55) {
                    chosenAnalysis = bsAnalysis; determinedType = 'bigsmall'; messageNote = `(Strong B/S Strk ${bsAnalysis.streak})`;
                } else if (rgAnalysis.streak > bsAnalysis.streak + 1 && rgAnalysis.probability > 55) {
                    chosenAnalysis = rgAnalysis; determinedType = 'redgreen'; messageNote = `(Strong R/G Strk ${rgAnalysis.streak})`;
                } else if (Math.abs(bsAnalysis.probability - rgAnalysis.probability) > 12) {
                    chosenAnalysis = bsAnalysis.probability > rgAnalysis.probability ? bsAnalysis : rgAnalysis;
                    determinedType = bsAnalysis.probability > rgAnalysis.probability ? 'bigsmall' : 'redgreen';
                } else {
                    chosenAnalysis = bsAnalysis.probability >= rgAnalysis.probability ? bsAnalysis : rgAnalysis;
                    determinedType = bsAnalysis.probability >= rgAnalysis.probability ? 'bigsmall' : 'redgreen';
                    messageNote = "(Trend Mixed)";
                }
                primaryCategoryResult = chosenAnalysis.trend;
            } else if (bsAnalysis.trend) { chosenAnalysis = bsAnalysis; determinedType = 'bigsmall'; primaryCategoryResult = bsAnalysis.trend; }
            else if (rgAnalysis.trend) { chosenAnalysis = rgAnalysis; determinedType = 'redgreen'; primaryCategoryResult = rgAnalysis.trend; }
            else { // Fallback if no clear trend
                determinedType = 'bigsmall'; primaryCategoryResult = 'Small';
                chosenAnalysis = { probability: 20, total: actualShortTermGamesToAnalyze, streak:0, trend: primaryCategoryResult };
                messageNote = "(NoClearTrend/LowData)";
            }
            if (chosenAnalysis.streak >= 3) { reversalChance = 50 + (chosenAnalysis.streak - 2) * 8; }
            else if (chosenAnalysis.streak === 2) { reversalChance = 30 + Math.random() * 15; }
            else { reversalChance = 10 + Math.random() * 15; }
            if (reversalChance > 80) reversalChance = 80;
        }

        if (!primaryCategoryResult || !determinedType) { // Additional fallback
            console.warn("Primary category or type not determined, using fallback prediction.");
            primaryCategoryResult = 'Small';
            determinedType = 'bigsmall';
            chosenAnalysis = { probability: 10, ...chosenAnalysis }; // Keep existing probability if available
            messageNote += " (FallbackUsed)";
        }

        const predictedNumbersArray = predictNumbersForTrend(primaryCategoryResult, determinedType, gameHistoryCache, longTermGamesToAnalyzeForNumbers);
        const predictedNumber = predictedNumbersArray[0];
        const numDetails = getNumberDetails(predictedNumber);
        let finalPredictedBS = numDetails.bigSmall;
        let finalPredictedRawColor = numDetails.rawColor;
        let displayableColorHTML = numDetails.colorDisplayHTML;
        let finalMessage = currentStrategyLevel.includes("Rev") ? currentStrategyLevel + ` ${messageNote}` : `Auto ${messageNote}`;
        if (finalMessage.trim() === "Auto") finalMessage = "Auto (Stable)";

        return {
            predictedBS: finalPredictedBS || '?',
            predictedRawColor: finalPredictedRawColor || '?',
            predictedColorHTML: displayableColorHTML || '?',
            predictedNumber: predictedNumber !== undefined ? predictedNumber : '?',
            predictedNumbersArray: predictedNumbersArray.length === 3 ? predictedNumbersArray : [0,1,2],
            reversalChance: parseFloat(reversalChance.toFixed(1)),
            probability: parseFloat((chosenAnalysis.probability || 0).toFixed(1)),
            message: finalMessage.trim().replace(/\(\)/g, '').replace(/\s\s+/g, ' '),
            determinedPredictionType: determinedType || 'bigsmall'
        };
    }
    async function generateAndStorePrediction(period) {
        const currentResultEl = document.getElementById('currentResult');
        if(currentResultEl) currentResultEl.innerHTML = '<i class="fas fa-cog fa-spin fa-lg" style="color: var(--primary);"></i> AI thinking...';
        let predictionInputData;
        try {
            const startTime = Date.now();
            if (cachedData.length < 3 && navigator.onLine) { // Ensure data before predicting, only if online
                await fetchOptimizedData(3); // Fetch at least 3 items
            }
            if(cachedData.length === 0 && !navigator.onLine){
                 if(currentResultEl) currentResultEl.innerHTML = '<i class="fas fa-wifi-slash"></i> Offline. Waiting for data...';
                 return; // Don't proceed if offline and no data
            }

            const enginePrediction = await intelligentPredictionEngine(cachedData);
            predictionInputData = {
                period,
                predictedBS: enginePrediction.predictedBS,
                predictedRawColor: enginePrediction.predictedRawColor,
                predictedColorHTML: enginePrediction.predictedColorHTML,
                predictedNumber: enginePrediction.predictedNumber,
                predictedNumbersArray: enginePrediction.predictedNumbersArray,
                reversalChance: enginePrediction.reversalChance,
                probability: enginePrediction.probability,
                message: enginePrediction.message,
                resultType: enginePrediction.determinedPredictionType || 'auto',
                server: fixedSelectedServerName
            };
            lastAiReversalChance = enginePrediction.reversalChance || 0;
            const elapsed = Date.now() - startTime;
            await new Promise(resolve => setTimeout(resolve, Math.max(0, 250 - elapsed))); // Ensure a minimum display time for "thinking"

            const prob = predictionInputData.probability || 0;
            const revChance = predictionInputData.reversalChance || 0;
            const msg = predictionInputData.message || "?";
            const nums = predictionInputData.predictedNumbersArray || ['?'];
            const bsPart = `<span class="prediction-output-item p-bs"><span class="prediction-output-label">B/S:</span><span class="prediction-output-value">${predictionInputData.predictedBS || '?'}</span></span>`;
            const colorPart = `<span class="prediction-output-item p-color"><span class="prediction-output-label">Color:</span><span class="prediction-output-value">${predictionInputData.predictedColorHTML || '?'}</span></span>`;
            const numsPart = `<span class="prediction-output-item p-nums"><span class="prediction-output-label">Nums:</span><span class="prediction-output-value">${nums.join(', ')}</span></span>`;
            const percentPart = `<span class="prediction-output-item p-perc"><span class="prediction-output-label">Per:</span><span class="prediction-output-value">(${prob > 0 ? prob.toFixed(1) : 'N/A'}%)</span></span>`;
            const revPart = `<span class="prediction-output-item p-rev"><span class="prediction-output-label">Rev:</span><span class="prediction-output-value">(${revChance > 0 ? revChance.toFixed(1) : 'N/A'}%)</span></span>`;
            const strategyPart = `<span class="prediction-output-item p-strat"><span class="prediction-output-label">Stgy:</span><span class="prediction-output-value" title="${msg}">${msg}</span></span>`;

            if(currentResultEl) currentResultEl.innerHTML = `${bsPart} ${colorPart} ${numsPart} ${percentPart} ${revPart} ${strategyPart}`;
            currentPredictionData[period] = predictionInputData;
            showNotification(`Prediction for ${period}: ${predictionInputData.predictedBS}, ${predictionInputData.predictedRawColor}, Nums: ${nums.join(',')}`, 'info');
            speakPrediction(predictionInputData);
            updateSessionStatsBar();
        } catch (error) {
            console.error("generateAndStorePrediction error:", error.message, error.stack);
            if(currentResultEl) currentResultEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Prediction Error: ${error.message}`;
            showNotification(`Prediction generation failed: ${error.message}`, 'error');
            currentPredictionData[period] = { period, error: true, message: `Generation Failed: ${error.message}` };
            lastAiReversalChance = 0;
            updateSessionStatsBar();
        }
    }


    // --- Sound & UI Feedback ---
    function speak(text, lang = 'en-US') { if (!isSoundOn) return; if ('speechSynthesis' in window) { try { window.speechSynthesis.cancel(); const utterance = new SpeechSynthesisUtterance(text); utterance.lang = lang; utterance.rate = 1.0; utterance.pitch = 1.0; window.speechSynthesis.speak(utterance); } catch (e) { console.error("Speech Synthesis error:", e); } } else { console.warn("Speech Synthesis not supported by this browser."); } }
    function speakPrediction(predictionData) { if (!predictionData) return; let confidenceMsg = "Normal"; if (predictionData.message && predictionData.message.includes("Rev")) { confidenceMsg = "Reversal Active"; } else if (predictionData.probability > 75) { confidenceMsg = "High Confidence"; } else if (predictionData.probability > 60) { confidenceMsg = "Medium Confidence"; } else { confidenceMsg = "Low Confidence"; } const nums = predictionData.predictedNumbersArray || []; const speakText = `Prediction: ${predictionData.predictedBS}. ${predictionData.predictedRawColor}. Numbers: ${nums.join(', ')}. Status: ${confidenceMsg}.`; speak(speakText); }

    // --- Jarvis AI Analytics & Session Stats ---
    function calculateJarvisStats() { const getStatsForLimit = (limit) => { const relevantHistory = history.filter(h => ['Win', 'Loss', 'Partial'].includes(h.status)).slice(0, limit); if (relevantHistory.length === 0) return { rate: '0.0', wins: 0, losses: 0, partials: 0, actualCount: 0 }; const wins = relevantHistory.filter(h => h.status === 'Win').length; const losses = relevantHistory.filter(h => h.status === 'Loss').length; const partials = relevantHistory.filter(h => h.status === 'Partial').length; const totalConsidered = wins + losses + partials; const rate = totalConsidered > 0 ? ((wins / totalConsidered) * 100).toFixed(1) : '0.0'; return { rate, wins, losses, partials, actualCount: relevantHistory.length }; }; const l10 = getStatsForLimit(10); const l20 = getStatsForLimit(20); const l30 = getStatsForLimit(30); const l50 = getStatsForLimit(50); let overallAssessment = "Low"; const overallRateNum = parseFloat(l50.rate) || parseFloat(l30.rate) || parseFloat(l20.rate) || parseFloat(l10.rate) || 0; if (overallRateNum >= 75) overallAssessment = "Excellent"; else if (overallRateNum >= 60) overallAssessment = "Good"; else if (overallRateNum >= 45) overallAssessment = "Average"; let l10LossStreak = 0; const last10Actual = history.filter(h => ['Win', 'Loss', 'Partial'].includes(h.status)).slice(0, 10); for (let i = 0; i < last10Actual.length; i++) { if (last10Actual[i].status === 'Loss') { l10LossStreak++; } else { break; } } let l10StreakAlert = null; if (l10LossStreak >= 3) { l10StreakAlert = `L10 Streak: ${l10LossStreak} Losses! Play Cautiously!`; } let l50PerformanceAlert = null; if (l50.actualCount >= 20 && parseFloat(l50.rate) < 40) { l50PerformanceAlert = `L50 Performance: Low (${l50.rate}%) - High Risk!`; } else if (l50.actualCount >= 20 && parseFloat(l50.rate) < 50 && parseFloat(l50.rate) >= 40 ) { l50PerformanceAlert = `L50 Performance: Average (${l50.rate}%) - Consider Strategy.`; } return { l10, l20, l30, l50, overallAssessment, l10StreakAlert, l50PerformanceAlert }; }
    function updateJarvisCard() { if(!document.getElementById('jarvisL10Rate')) return; const stats = calculateJarvisStats(); document.getElementById('jarvisL10Rate').textContent = `${stats.l10.rate}%`; document.getElementById('jarvisL10Details').textContent = `(${stats.l10.wins}W/${stats.l10.losses}L/${stats.l10.partials}P)`; document.getElementById('jarvisL20Rate').textContent = `${stats.l20.rate}%`; document.getElementById('jarvisL20Details').textContent = `(${stats.l20.wins}W/${stats.l20.losses}L/${stats.l20.partials}P)`; document.getElementById('jarvisL30Rate').textContent = `${stats.l30.rate}%`; document.getElementById('jarvisL30Details').textContent = `(${stats.l30.wins}W/${stats.l30.losses}L/${stats.l30.partials}P)`; document.getElementById('jarvisL50Rate').textContent = `${stats.l50.rate}%`; document.getElementById('jarvisL50Details').textContent = `(${stats.l50.wins}W/${stats.l50.losses}L/${stats.l50.partials}P)`; const jarvisOverallEl = document.getElementById('jarvisOverall'); if(jarvisOverallEl) { jarvisOverallEl.textContent = stats.overallAssessment; if (stats.overallAssessment === "Excellent") jarvisOverallEl.style.color = 'var(--success)'; else if (stats.overallAssessment === "Good") jarvisOverallEl.style.color = 'var(--primary)'; else if (stats.overallAssessment === "Average") jarvisOverallEl.style.color = 'var(--warning)'; else jarvisOverallEl.style.color = 'var(--danger)'; } const alertsContainer = document.getElementById('jarvisAlertsContainer'); alertsContainer.innerHTML = ''; if (stats.l10StreakAlert) { const alertDiv = document.createElement('div'); alertDiv.className = 'jarvis-alert danger'; alertDiv.innerHTML = `<i class="fas fa-triangle-exclamation"></i> ${stats.l10StreakAlert}`; alertsContainer.appendChild(alertDiv); } if (stats.l50PerformanceAlert) { const alertDiv = document.createElement('div'); alertDiv.className = `jarvis-alert ${parseFloat(stats.l50.rate) < 40 ? 'danger' : 'warning'}`; alertDiv.innerHTML = `<i class="fas fa-triangle-exclamation"></i> ${stats.l50PerformanceAlert}`; alertsContainer.appendChild(alertDiv); } }
    function toggleJarvisCardVisibility(show, save = true) { const content = document.getElementById('jarvisAnalyticsContent'); const icon = document.querySelector('#toggleJarvisCard i'); if (!content || !icon) return; if (show) { content.style.display = 'block'; icon.classList.remove('fa-eye-slash'); icon.classList.add('fa-eye'); if(save) robustLocalStorageSetItem(STORAGE_KEY_JARVIS_VISIBLE, 'true'); } else { content.style.display = 'none'; icon.classList.remove('fa-eye'); icon.classList.add('fa-eye-slash'); if(save) robustLocalStorageSetItem(STORAGE_KEY_JARVIS_VISIBLE, 'false'); } }
    function updateAccuracyDisplay() { if (currentUserRole) { updateSessionStatsBar(); updateJarvisCard(); } }
    function updateSessionStatsBar() {
        const statsWinsEl = document.getElementById('statsWins'); const statsLossesEl = document.getElementById('statsLosses'); const statsPartialsEl = document.getElementById('statsPartials'); const statsAccuracyEl = document.getElementById('statsAccuracy'); const statsAiRevEl = document.getElementById('statsAiRev'); const statsLevelEl = document.getElementById('statsLevel'); if (!statsWinsEl || !statsLossesEl || !statsPartialsEl || !statsAccuracyEl || !statsAiRevEl || !statsLevelEl) { return; } statsWinsEl.textContent = sessionStats.wins; statsLossesEl.textContent = sessionStats.losses; statsPartialsEl.textContent = sessionStats.partials || 0; const totalCompleted = sessionStats.wins + sessionStats.losses + (sessionStats.partials || 0); let accuracyText = "0%"; if (totalCompleted > 0) { const accuracy = Math.round((sessionStats.wins / totalCompleted) * 100); accuracyText = `${isNaN(accuracy) ? '0' : accuracy}%`; } statsAccuracyEl.textContent = accuracyText; statsAiRevEl.textContent = `${lastAiReversalChance.toFixed(1)}%`;
        let levelText = currentStrategyLevel;
        const lvMatch = currentStrategyLevel.match(/(?:Martingale L|Anti-Martingale L|Auto \(Rev L|Auto \(L)(\d+)\)?/i);
        if (lvMatch && lvMatch[1]) {
            levelText = `Lv${lvMatch[1]}`;
        } else if (currentStrategyLevel === "Auto" && consecutiveWins > 0 && !currentStrategyLevel.includes("Rev") ) {
             levelText = `Auto (W${consecutiveWins})`;
        }
        statsLevelEl.textContent = levelText;
    }
    async function finalizeAndRecordResult(periodToFinalize) {
        if (isWaitingForResult) return; isWaitingForResult = true;
        const predictionData = currentPredictionData[periodToFinalize];
        if (!predictionData || predictionData.error) {
            if (predictionData?.error) {
                const errorEntry = { period: periodToFinalize, predictedNumber: '?', predictedBS: '?', predictedRawColor: '?', predictedColorHTML: '?', actualResultDisplay: 'Prediction Error', status: 'Error', bsWin: false, colorWin: false, numWin: false, resultType: '?', server: fixedSelectedServerName, probability: 0 };
                history.unshift(errorEntry); saveMyHistoryToStorage();
                if (getActiveTab() === 'my' && currentUserRole) fetchData(1, 'my', true);
                updateAccuracyDisplay(); delete currentPredictionData[periodToFinalize];
            }
            isWaitingForResult = false; return;
        }
        let gameOutcome = null; const startTime = Date.now();
        while (Date.now() - startTime < POLLING_TIMEOUT) { gameOutcome = await fetchGameResult(periodToFinalize); if (gameOutcome) break; await new Promise(resolve => setTimeout(resolve, POLLING_INTERVAL)); }
        let historyEntry;
        if (gameOutcome) {
            const actualBS = gameOutcome.bigSmall;
            const actualColorForHistory = gameOutcome.colorForHistory;
            const actualNum = gameOutcome.numberVal;
            const bsWin = predictionData.predictedBS === actualBS;
            let colorWin = predictionData.predictedRawColor === gameOutcome.rawColor;
            const numWin = predictionData.predictedNumber === actualNum;
            let status;
            if (bsWin && colorWin) { status = "Win"; sessionStats.wins++; consecutiveLosses = 0; consecutiveWins++; }
            else if (!bsWin && !colorWin) { status = "Loss"; sessionStats.losses++; consecutiveWins = 0; consecutiveLosses++; }
            else { status = "Partial"; if(!sessionStats.partials) sessionStats.partials = 0; sessionStats.partials++; consecutiveWins = 0; consecutiveLosses = 0; }
            saveSessionStateToStorage();
            historyEntry = {
                period: periodToFinalize,
                predictedNumber: predictionData.predictedNumber,
                predictedBS: predictionData.predictedBS,
                predictedRawColor: predictionData.predictedRawColor,
                predictedColorHTML: predictionData.predictedColorHTML,
                actualResultDisplay: `<span class="${gameOutcome.bsResultClass}">${actualBS}</span>, ${actualColorForHistory}`,
                status, bsWin, colorWin, numWin,
                resultType: predictionData.resultType,
                server: predictionData.server,
                probability: predictionData.probability
            };
            if (numWin && (status === "Win" || status === "Partial" )) {
                const cheerMessages = ["Excellent! Number prediction hit!", "Fantastic! You got the number!", "Great call on the number! Jackpot!"];
                speak(cheerMessages[Math.floor(Math.random() * cheerMessages.length)]);
            }
        } else {
            console.warn(`Result for period ${periodToFinalize} timed out.`);
            historyEntry = { period: periodToFinalize, predictedNumber: predictionData.predictedNumber, predictedBS: predictionData.predictedBS, predictedRawColor: predictionData.predictedRawColor, predictedColorHTML: predictionData.predictedColorHTML, actualResultDisplay: 'Result N/A', status: 'Error', bsWin: false, colorWin: false, numWin: false, resultType: predictionData.resultType, server: predictionData.server, probability: predictionData.probability };
            consecutiveLosses = 0; consecutiveWins = 0; saveSessionStateToStorage(); showNotification(`Result for ${periodToFinalize} unavailable.`, 'error');
        }
        history.unshift(historyEntry); if(history.length > 200) history.splice(200); saveMyHistoryToStorage();
        delete currentPredictionData[periodToFinalize]; updateAccuracyDisplay();
        if (getActiveTab() === 'my' && currentUserRole) fetchData(1, 'my', true);
        isWaitingForResult = false;
    }

    // --- Main Loop & Tab/UI Management ---
    function updatePeriodAndTimer() { try { if (!currentUserRole) return; if (currentUserRole === 'user') { const storedUserKey = robustLocalStorageGetItem(STORAGE_KEY_CURRENT_USER_KEY, null); if (storedUserKey) { const managedUsers = getManagedUsers(); const currentUserObject = managedUsers.find(u => u.accessKey === storedUserKey); if (currentUserObject) { if (currentUserObject.isBanned) { showNotification("Your access has been revoked (banned). Logging out.", "error"); handleLogout(); return; } if (currentUserObject.expiresAt && Date.now() > currentUserObject.expiresAt) { showNotification("Your session has expired. Please login again.", "error"); handleLogout(); return; } } else { showNotification("Your access key is no longer valid. Logging out.", "error"); handleLogout(); return; } } else { console.warn("User role active but no key stored. Forcing logout."); handleLogout(); return; } } const now = new Date(), ct = now.getTime(); if (ct - lastTimerUpdate < 980) return; lastTimerUpdate = ct; const y = now.getUTCFullYear(), m = String(now.getUTCMonth() + 1).padStart(2, '0'), d = String(now.getUTCDate()).padStart(2, '0'); const hrs = now.getUTCHours(), mins = now.getUTCMinutes(), secsValue = now.getUTCSeconds(); const totMins = hrs * 60 + mins; const periodSuffix = 10001 + totMins; const currentPeriod = `${y}${m}${d}1000${periodSuffix}`; const secsRemaining = 60 - secsValue; const periodJustCompleted = lastCompletedPeriodNumber; if (currentPeriod !== lastCompletedPeriodNumber) { if (periodJustCompleted && currentPredictionData[periodJustCompleted]) { finalizeAndRecordResult(periodJustCompleted).catch(e => { console.error("Error in finalizeAndRecordResult:", e); isWaitingForResult = false; }); } lastCompletedPeriodNumber = currentPeriod; const periodEl = document.getElementById('period'); if (periodEl) periodEl.textContent = `${currentPeriod || 'N/A'}`; generateAndStorePrediction(currentPeriod).catch(e => { console.error("Error in generateAndStorePrediction:", e); }); fetchPage(1, true).then(() => { if (getActiveTab() === 'game' || getActiveTab() === 'deep') {
                    fetchData(1, getActiveTab(), true); // Fetch with page 1 for game/deep if active
                } }).catch(e => console.error("Error fetching page 1 on new period:", e)); } const timerEl = document.getElementById('timer'); if (timerEl) timerEl.textContent = `${String(secsRemaining).padStart(2, '0')}s`; const statusEl = document.getElementById('status'); if (statusEl) statusEl.textContent = secsRemaining < 10 ? 'Closing' : 'Active'; } catch (e) { console.error("Critical error in updatePeriodAndTimer, attempting to prevent stop:", e); } }
    function getActiveTab() { const activeButton = document.querySelector('.tabs button.active'); if (activeButton) { const onclickAttr = activeButton.getAttribute('onclick'); if (onclickAttr?.includes("'game'")) return 'game'; if (onclickAttr?.includes("'deep'")) return 'deep'; if (onclickAttr?.includes("'my'")) return 'my'; if (onclickAttr?.includes("'chart'")) return 'chart'; if (onclickAttr?.includes("'admin_dashboard'")) return 'admin_dashboard'; } return currentTab; }

    async function fetchData(page, tab = currentTab, forceRender = false) {
        if (!currentUserRole) {
            document.getElementById('historyContent').innerHTML = '<p style="text-align:center; padding:1rem; color:var(--warning);">Please login to view data.</p>';
            return;
        }
        const contentEl = document.getElementById('historyContent');
        if (!contentEl) return;

        const myHistoryControlsEl = document.getElementById('myHistoryControls');
        if (myHistoryControlsEl) {
            myHistoryControlsEl.style.display = (tab === 'my') ? 'flex' : 'none';
        }

        if (!forceRender && currentPage === page && currentTab === tab && contentEl.innerHTML !== '' && !contentEl.innerHTML.includes('Loading ')) {
             if (tab === 'game' || tab === 'deep') { /* These tabs might need refresh if cachedData changed */ }
             else { return; }
        }

        const localCallTab = tab;
        if (localCallTab !== 'my') { // For game, deep, chart, admin - page is always 1 effectively
            currentPage = 1;
        } else {
            currentPage = page; // For 'my' tab, respect the passed page number
        }
        currentTab = tab;

        contentEl.innerHTML = `<div style="text-align: center; padding: 2rem;"><i class="fas fa-spinner fa-spin fa-lg" style="color: var(--primary);"></i> Loading ${localCallTab}...</div>`;

        document.querySelectorAll('.tabs button').forEach(btn => btn.classList.remove('active'));
        const activeTabButton = document.querySelector(`.tabs button[onclick*="'${localCallTab}'"]`);
        if(activeTabButton) activeTabButton.classList.add('active');

        const gameHead = document.getElementById('gameHistoryHeader');
        const myHead = document.getElementById('myHistoryHeader');
        const adminHead = document.getElementById('adminDashboardHeader');
        if (gameHead) gameHead.style.display = (localCallTab === 'game' || localCallTab === 'deep') ? 'grid' : 'none';
        if (myHead) myHead.style.display = (localCallTab === 'my') ? 'grid' : 'none';
        if (adminHead) adminHead.style.display = 'none'; // Admin header managed inside its section

        const paginationEl = document.getElementById('paginationControls');
        if (paginationEl) {
            if (localCallTab === 'my') { // Only show pagination for 'my' history
                paginationEl.style.display = 'flex';
                document.getElementById('prevPageBtn').disabled = (currentPage <= 1);
                document.getElementById('currentPageBtn').textContent = currentPage;
                // next button disable logic will be handled later in 'my' history rendering
            } else {
                paginationEl.style.display = 'none';
            }
        }


        if (localCallTab === 'my') {
            if (myHistoryItemsPerPage == 10) contentEl.style.maxHeight = '200px';
            else if (myHistoryItemsPerPage == 25) contentEl.style.maxHeight = '480px';
            else if (myHistoryItemsPerPage == 50) contentEl.style.maxHeight = '920px';
            else contentEl.style.maxHeight = 'none';
        } else if (localCallTab === 'game') {
            contentEl.style.maxHeight = '200px';
        } else if (localCallTab === 'deep') {
            contentEl.style.maxHeight = '400px';
        } else if (localCallTab === 'admin_dashboard') {
            contentEl.style.maxHeight = 'none'; // Let admin panel define its own height/scroll
        } else {
            contentEl.style.maxHeight = '300px';
        }

        try {
            if (localCallTab === 'game') {
                if (currentTab !== localCallTab) return;
                contentEl.innerHTML = '';
                if (gameHead) {
                    gameHead.innerHTML = `<div class="history-header-item">Period</div><div class="history-header-item">Num</div><div class="history-header-item">Big/Small</div><div class="history-header-item">Color</div>`;
                }
                const list = cachedData.slice(0, GAME_HISTORY_ITEMS_PER_PAGE);

                if (list.length === 0) {
                    contentEl.innerHTML = `<p style="text-align:center; padding:1rem;">No game history available. System is fetching...</p>`;
                    if(navigator.onLine) await fetchPage(1, true); // Attempt to fetch if empty and online
                } else {
                    list.forEach(item => {
                        const details = getNumberDetails(item.number);
                        const div = document.createElement('div');
                        div.className = 'history-item game-result-item';
                        div.innerHTML = `<div class="history-value">${item.issueNumber||'?'}</div><div class="history-value gh-num ${details.numberClass}">${details.numberVal}</div><div class="history-value gh-bs ${details.bsClass}">${details.bigSmall}</div><div class="history-value gh-color">${details.colorForHistory}</div>`;
                        contentEl.appendChild(div);
                    });
                }
            } else if (localCallTab === 'deep') {
                if (currentTab !== localCallTab) return;
                contentEl.innerHTML = '';
                 if (gameHead) {
                    gameHead.innerHTML = `<div class="history-header-item">Period</div><div class="history-header-item">Num</div><div class="history-header-item">Big/Small</div><div class="history-header-item">Color</div>`;
                }
                const list = cachedData.slice(0, DEEP_HISTORY_ITEMS_PER_PAGE);

                if (list.length === 0) {
                     contentEl.innerHTML = `<p style="text-align:center; padding:1rem;">No deep history available. System is fetching...</p>`;
                     if(navigator.onLine) await fetchOptimizedData(DEEP_HISTORY_ITEMS_PER_PAGE); // Attempt to fetch if empty and online
                } else {
                    list.forEach(item => {
                        const details = getNumberDetails(item.number);
                        const div = document.createElement('div');
                        div.className = 'history-item game-result-item';
                        div.innerHTML = `<div class="history-value">${item.issueNumber||'?'}</div><div class="history-value gh-num ${details.numberClass}">${details.numberVal}</div><div class="history-value gh-bs ${details.bsClass}">${details.bigSmall}</div><div class="history-value gh-color">${details.colorForHistory}</div>`;
                        contentEl.appendChild(div);
                    });
                }
            } else if (localCallTab === 'my') {
                if (currentTab !== localCallTab) return;
                if (myHead) myHead.innerHTML = `<div class="history-header-item">Period</div><div class="history-header-item">Num</div><div class="history-header-item">Pred B/S</div><div class="history-header-item">Pred Color</div><div class="history-header-item">Status</div>`;
                contentEl.innerHTML = '';
                const startIndex = (currentPage - 1) * myHistoryItemsPerPage;
                const endIndex = startIndex + myHistoryItemsPerPage;
                const paginatedHistory = history.slice(startIndex, endIndex);
                document.getElementById('nextPageBtn').disabled = (endIndex >= history.length);
                if (paginatedHistory.length === 0) contentEl.innerHTML = `<p style="text-align:center; padding:1rem;">${currentPage === 1 ? 'No predictions recorded.' : 'No more predictions.'}</p>`;
                else {
                    paginatedHistory.forEach(item => {
                        const div = document.createElement('div');
                        let rowClass = 'history-item my-prediction-item';
                        if (item.status === 'Win') rowClass += ' row-win';
                        else if (item.status === 'Loss') rowClass += ' row-loss';
                        else if (item.status === 'Partial') rowClass += ' row-partial';
                        else if (item.status === 'Error') rowClass += ' row-error';
                        div.className = rowClass;
                        const bsTickCross = item.status !== 'Error' && item.status !== '?' && typeof item.bsWin !== 'undefined' ? (item.bsWin ? '<span class="tick-mark">✅</span>' : '<span class="cross-mark">❌</span>') : '';
                        const colorTickCross = item.status !== 'Error' && item.status !== '?' && typeof item.colorWin !== 'undefined' ? (item.colorWin ? '<span class="tick-mark">✅</span>' : '<span class="cross-mark">❌</span>') : '';
                        const numTickCross = item.status !== 'Error' && item.status !== '?' && typeof item.numWin !== 'undefined' ? (item.numWin ? '<span class="tick-mark">✅</span>' : '<span class="cross-mark">❌</span>') : '';
                        const predictedNumDisplay = `${item.predictedNumber ?? '?'}${numTickCross}`;
                        const predictedBSDisplay = `${item.predictedBS || '?'}${bsTickCross}`;
                        const predictedColorDisplay = `${item.predictedColorHTML || '?'}${colorTickCross}`;
                        const statusDisplay = item.status || '?';
                        div.innerHTML = `<div class="history-value" title="${item.period}">${item.period}</div><div class="history-value predicted-num-value">${predictedNumDisplay}</div><div class="history-value predicted-bs-value">${predictedBSDisplay}</div><div class="history-value predicted-color-value">${predictedColorDisplay}</div><div class="history-value status-value status-${item.status?.toLowerCase()}">${statusDisplay}</div>`;
                        contentEl.appendChild(div);
                    });
                }
            } else if (localCallTab === 'chart') {
                const analyticsData = await fetchOptimizedData(DEEP_HISTORY_ITEMS_PER_PAGE);
                if (currentTab !== localCallTab) return;
                if (analyticsData && analyticsData.length > 0) {
                    let rC=0, gC=0, vC=0, bC=0, sC=0;
                    const nums = analyticsData.map(item => parseInt(item.number, 10)).filter(n => !isNaN(n) && n >=0 && n <=9);
                    nums.forEach(n => {
                        const details = getNumberDetails(n);
                        if(details.rawColor === 'Red') rC++;
                        if(details.rawColor === 'Green') gC++;
                        if(details.isViolet) vC++;
                        if(details.bigSmall === 'Big') bC++;
                        else if(details.bigSmall === 'Small') sC++;
                    });
                    const totalValidGames = nums.length;
                    const pct = (count) => totalValidGames ? ((count/totalValidGames)*100).toFixed(1) : 0;
                    const totalSessionGames = sessionStats.wins + sessionStats.losses + (sessionStats.partials || 0);
                    const sessionAccuracyValue = totalSessionGames > 0 ? Math.round((sessionStats.wins / totalSessionGames) * 100) : 0;
                    const sessionAccuracyDisplay = totalSessionGames > 0 ? `${sessionAccuracyValue}% (W:${sessionStats.wins} L:${sessionStats.losses} P:${sessionStats.partials || 0})` : 'N/A';
                    contentEl.innerHTML = `<h4 style="font-size: 0.9rem; color: var(--primary); margin:0.4rem; padding-bottom:4px; border-bottom: 1px solid var(--border-color);">Recent Trends (Last ${totalValidGames} Games)</h4><div class="analytics-grid" style="padding: 0.6rem;"><div><strong>Outcome</strong></div><div><strong>Count</strong></div><div><strong>Percent</strong></div><div><span class="color-dot color-red"></span> Red</div><div>${rC}</div><div>${pct(rC)}%</div><div><span class="color-dot color-green"></span> Green</div><div>${gC}</div><div>${pct(gC)}%</div><div><span class="color-dot color-violet"></span> Violet</div><div>${vC}</div><div>${pct(vC)}%</div><div style="grid-column: 1 / -1; height: 8px;"></div><div><span class="outcome-icon big">B</span> Big (5-9)</div><div>${bC}</div><div>${pct(bC)}%</div><div><span class="outcome-icon small">S</span> Small (0-4)</div><div>${sC}</div><div>${pct(sC)}%</div></div><div class="session-accuracy-footer"><strong>Session Accuracy:</strong> ${sessionAccuracyDisplay}</div>`;
                } else contentEl.innerHTML = '<p style="text-align:center; padding:1rem;">Not enough data for analytics.</p>';
            } else if (localCallTab === 'admin_dashboard') {
                if (currentUserRole !== 'admin') {
                    contentEl.innerHTML = '<p style="text-align:center; padding:1rem; color:var(--danger);">Access Denied.</p>';
                    return;
                }
                if (currentTab !== localCallTab) return;
                contentEl.innerHTML = `<div id="adminPanelContainer" style="padding: 8px; font-size:0.75rem;"><div class="admin-section"><h5 style="font-size:0.9rem;">User Management</h5><div id="adminUserManagementTopControls"><div id="adminUserStats"><span>Total: <strong id="totalManagedUsers" style="color:var(--primary)">0</strong></span><span>Banned: <strong id="bannedManagedUsers" style="color:var(--danger)">0</strong></span></div><div id="createUserFormContainer"><h6>Create New User Access Key</h6><div id="createUserFormControls"><label for="userValidityPeriod">Validity:</label><select id="userValidityPeriod"><option value="30m">30 Min</option><option value="1h">1 Hour</option><option value="1d">1 Day</option><option value="7d">7 Day</option><option value="60d">60 Day</option><option value="180d">180 Day</option><option value="365d">365 Day</option><option value="720d">720 Day</option><option value="lifetime">Lifetime</option></select><button id="createUserKeyButton"><i class="fas fa-plus-circle"></i> Create</button></div></div></div><div id="generatedUserKey"></div></div><div class="admin-section" style="margin-top: 8px;"><h5>Managed Users List</h5><div id="managedUsersListContainer"></div></div></div>`;
                renderAdminDashboard();
            }
        } catch (renderError) {
            if (currentTab === localCallTab) {
                contentEl.innerHTML = `<p style="text-align:center; padding:1rem; color:var(--danger);">Error displaying ${localCallTab} data. Check console.</p>`;
            }
            console.error(`Error in fetchData for tab ${localCallTab}:`, renderError);
        }
    }
    function changeMyHistoryEntriesPerPage(value) { myHistoryItemsPerPage = parseInt(value); saveMyHistoryItemsPerPageToStorage(); if (currentUserRole) fetchData(1, 'my', true); }
    function changePage(delta) { const newPage = currentPage + delta; if (newPage <= 0) return; const activeTabForPaging = getActiveTab(); if (!currentUserRole || activeTabForPaging !== 'my') { return; } if (activeTabForPaging === 'my') { const totalHistoryPages = Math.ceil(history.length / myHistoryItemsPerPage); if (newPage > totalHistoryPages && totalHistoryPages > 0 && delta > 0) return; } fetchData(newPage, activeTabForPaging); }
    function showNotification(message, type = 'success', duration = 3500) { const n=document.getElementById('notification'), nt=document.getElementById('notificationText'); if(!n || !nt) return; nt.textContent = message; n.className = 'floating-notification'; const iconEl = n.querySelector('i'); if (type === 'success') { n.classList.add('success-bg'); if (iconEl) iconEl.className = 'fas fa-check-circle'; } else if (type === 'error') { n.classList.add('error-bg'); if (iconEl) iconEl.className = 'fas fa-exclamation-circle'; } else { n.classList.add('info-bg'); if (iconEl) iconEl.className = 'fas fa-info-circle'; } n.style.color = 'var(--text-on-accent)'; n.classList.add('show'); setTimeout(() => n.classList.remove('show'), duration); }
    function clearMyPredictions() { if (!currentUserRole) { showNotification("Please login to manage predictions.", "error"); return; } if (confirm("Are you sure you want to clear all your prediction history? This cannot be undone.")) { history = []; saveMyHistoryToStorage(); resetSessionStatistics(); fetchData(1, 'my', true); showNotification('My Predictions history cleared!', 'info'); } }

    // --- Admin Panel & User Management ---
    const renameUserModal = document.getElementById('renameUserModal');
    const renameUserModalCloseButton = document.getElementById('renameUserModalCloseButton');
    const currentUsernameRenameEl = document.getElementById('currentUsernameRename');
    const newUsernameInputEl = document.getElementById('newUsernameInput');
    const userAccessKeyToRenameEl = document.getElementById('userAccessKeyToRename');
    const saveRenameBtn = document.getElementById('saveRenameBtn');
    const cancelRenameBtn = document.getElementById('cancelRenameBtn');
    function openRenameModal(accessKey, currentName) {
        if (!renameUserModal || !currentUsernameRenameEl || !newUsernameInputEl || !userAccessKeyToRenameEl) return;
        currentUsernameRenameEl.textContent = currentName;
        newUsernameInputEl.value = currentName;
        userAccessKeyToRenameEl.value = accessKey;
        renameUserModal.style.display = "flex";
        newUsernameInputEl.focus();
    }
    if(renameUserModalCloseButton) renameUserModalCloseButton.onclick = () => { if(renameUserModal) renameUserModal.style.display = "none"; };
    if(cancelRenameBtn) cancelRenameBtn.onclick = () => { if(renameUserModal) renameUserModal.style.display = "none"; };
    if(saveRenameBtn) {
        saveRenameBtn.onclick = () => {
            const accessKey = userAccessKeyToRenameEl.value;
            const newUsername = newUsernameInputEl.value.trim();
            if (!accessKey || !newUsername) {
                showNotification("New username cannot be empty.", "error");
                return;
            }
            let managedUsers = getManagedUsers();
            const userIndex = managedUsers.findIndex(u => u.accessKey === accessKey);
            if (userIndex > -1) {
                managedUsers[userIndex].username = newUsername;
                saveManagedUsers(managedUsers);
                renderAdminDashboard();
                if(renameUserModal) renameUserModal.style.display = "none";
                showNotification(`User ${accessKey} renamed to ${newUsername}.`, "success");
            } else {
                showNotification("User not found for renaming.", "error");
            }
        };
    }
    function getManagedUsers() { return robustJsonParse(STORAGE_KEY_MANAGED_USERS, []); }
    function saveManagedUsers(usersArray) { robustLocalStorageSetItem(STORAGE_KEY_MANAGED_USERS, JSON.stringify(usersArray));}
    function generateAccessKey(length = 12) { const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let key = 'U_'; for (let i = 0; i < length; i++) key += chars.charAt(Math.floor(Math.random() * chars.length)); return key; }
    function calculateExpiryTimestamp(validityPeriod) { const now = Date.now(); if (validityPeriod === "lifetime") return null; let milliseconds; const unit = validityPeriod.slice(-1).toLowerCase(); const value = parseInt(validityPeriod.slice(0, -1)); if (isNaN(value)) return null; if (unit === 'm') milliseconds = value * 60 * 1000; else if (unit === 'h') milliseconds = value * 60 * 60 * 1000; else if (unit === 'd') milliseconds = value * 24 * 60 * 60 * 1000; else return null; return now + milliseconds; }
    function formatDateForDisplay(timestamp, isShort = false) { if (!timestamp) return "Lifetime"; const date = new Date(timestamp); if (isShort) { return `${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getFullYear()).slice(-2)} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`; } return date.toLocaleString([], { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false }); }
    function initializeSampleManagedUsers() { let users = getManagedUsers(); if (users.length === 0) { console.log("Initializing sample keys as managed users list is empty."); const samplePeriods = { "30m": "30Min", "1h": "1Hr", "1d": "1Day", "7d": "7Days", "60d": "60Days", "180d": "180Days", "365d": "365Days", "720d": "720Days" }; const newUsers = []; for (const periodCode in samplePeriods) { const periodLabel = samplePeriods[periodCode]; for (let i = 1; i <= 4; i++) { const newUser = { accessKey: `U_${periodLabel.toUpperCase()}_KEY${i}`, username: `User_${periodLabel}_${i}`, createdAt: Date.now(), validityPeriod: periodCode, expiresAt: calculateExpiryTimestamp(periodCode), isBanned: false, role: 'user' }; newUsers.push(newUser); } } saveManagedUsers(newUsers); console.log(`${newUsers.length} sample keys created.`); showNotification(`${newUsers.length} sample keys generated. Admins can manage them.`, 'info', 5000); } else { console.log("Managed users list not empty. Skipping sample key generation.");}}
    function renderAdminDashboard() { const totalManagedUsersEl = document.getElementById('totalManagedUsers'); const bannedManagedUsersEl = document.getElementById('bannedManagedUsers'); const listContainer = document.getElementById('managedUsersListContainer'); const createUserButton = document.getElementById('createUserKeyButton'); if (!listContainer || !totalManagedUsersEl || !bannedManagedUsersEl || !createUserButton ) { console.error("Admin panel elements not found."); return; } const managedUsers = getManagedUsers(); totalManagedUsersEl.textContent = managedUsers.length; bannedManagedUsersEl.textContent = managedUsers.filter(u => u.isBanned).length; listContainer.innerHTML = ''; const headerDiv = document.createElement('div'); headerDiv.className = 'admin-list-header';
    headerDiv.innerHTML = `<div class="history-header-item">Date & Time</div><div class="history-header-item">Username</div><div class="history-header-item">Access Key</div><div class="history-header-item">Status</div><div class="history-header-item">Expires</div><div class="history-header-item">Actions</div>`;
    listContainer.appendChild(headerDiv); if (managedUsers.length === 0) { listContainer.innerHTML += '<p style="text-align:center;padding:10px;color:var(--text-secondary);">No users created yet.</p>'; } else { managedUsers.sort((a, b) => b.createdAt - a.createdAt); managedUsers.forEach(user => { const itemDiv = document.createElement('div'); itemDiv.className = 'history-item managed-user-item'; let statusText = "Active"; let statusColor = 'var(--success)'; if (user.isBanned) { statusText = "Banned"; statusColor = 'var(--danger)'; } else if (user.expiresAt && Date.now() > user.expiresAt) { statusText = "Expired"; statusColor = 'var(--warning)';} const banButtonText = user.isBanned ? "Unban" : "Ban"; const banButtonClass = user.isBanned ? "unban-btn" : "ban-btn"; itemDiv.innerHTML = `<div class="history-value" title="${new Date(user.createdAt).toLocaleString()}">${formatDateForDisplay(user.createdAt, true)}</div><div class="history-value user-cell" title="${user.username}">${user.username}</div><div class="history-value key-cell" title="${user.accessKey}">${user.accessKey}</div><div class="history-value" style="color:${statusColor}; font-weight:bold;">${statusText}</div><div class="history-value" title="${user.expiresAt ? new Date(user.expiresAt).toLocaleString() : 'Lifetime'}">${formatDateForDisplay(user.expiresAt, true)}</div><div class="history-value"><button class="admin-action-btn rename-btn" data-key="${user.accessKey}" data-name="${user.username}" title="Rename User"><i class="fas fa-edit"></i></button><button class="${banButtonClass} admin-action-btn" data-key="${user.accessKey}" title="${banButtonText} User">${user.isBanned ? '<i class="fas fa-user-check"></i>' :'<i class="fas fa-user-slash"></i>'}</button><button class="delete-btn admin-action-btn" data-key="${user.accessKey}" title="Delete User"><i class="fas fa-trash-alt"></i></button></div>`; listContainer.appendChild(itemDiv); }); } listContainer.querySelectorAll('.rename-btn').forEach(button => { button.onclick = (e) => { const key = e.currentTarget.dataset.key; const name = e.currentTarget.dataset.name; openRenameModal(key, name); };}); listContainer.querySelectorAll('.ban-btn, .unban-btn').forEach(button => { button.onclick = (e) => { const key = e.currentTarget.dataset.key; const users = getManagedUsers(); const user = users.find(u => u.accessKey === key); if (user) { user.isBanned = !user.isBanned; saveManagedUsers(users); renderAdminDashboard(); showNotification(`User ${key} ${user.isBanned ? 'banned' : 'unbanned'}.`, 'info'); } }; }); listContainer.querySelectorAll('.delete-btn').forEach(button => { button.onclick = (e) => { if (confirm(`Delete user ${e.currentTarget.dataset.key}?`)) { let users = getManagedUsers(); users = users.filter(u => u.accessKey !== e.currentTarget.dataset.key); saveManagedUsers(users); renderAdminDashboard(); showNotification(`User ${e.currentTarget.dataset.key} deleted.`, 'info'); } }; }); createUserButton.onclick = () => { const validityPeriodSelect = document.getElementById('userValidityPeriod'); const generatedUserKeyEl = document.getElementById('generatedUserKey'); if (!validityPeriodSelect || !generatedUserKeyEl) { console.error("Create user form elements missing!"); return; } const validityPeriod = validityPeriodSelect.value; const newKey = generateAccessKey(); const createdAt = Date.now(); const expiresAt = calculateExpiryTimestamp(validityPeriod); const autoUsername = `User_${String(createdAt).slice(-5)}`; const newUser = { accessKey: newKey, username: autoUsername, createdAt, validityPeriod, expiresAt, isBanned: false, role: 'user' }; const currentManagedUsers = getManagedUsers(); currentManagedUsers.push(newUser); saveManagedUsers(currentManagedUsers); generatedUserKeyEl.textContent = `New Key: ${newKey} (User: ${autoUsername})`; renderAdminDashboard(); showNotification(`User key ${newKey} for ${autoUsername} created.`, 'success'); }; }

    // --- Authentication & Initialization ---
    function showLoginModal(show = true) { const loginModalEl = document.getElementById('loginModal'); const appContainerEl = document.getElementById('appContainer'); const loginErrorEl = document.getElementById('loginError'); if(!loginModalEl || !appContainerEl) { console.error("Login or App container not found in showLoginModal"); return; } if (loginErrorEl) loginErrorEl.style.display = 'none'; if (show) { loginModalEl.style.display = "flex"; appContainerEl.style.display = "none"; } else { loginModalEl.style.display = "none"; appContainerEl.style.display = "block"; } }
    function showLoginError(message) { const loginErrorEl = document.getElementById('loginError'); const keyInput = document.getElementById('accessKeyInput'); if (loginErrorEl) { loginErrorEl.textContent = message; loginErrorEl.style.display = 'block'; } if (keyInput) keyInput.value = ''; }
    function initializeUIBasedOnRole() { console.log("[DEBUG] initializeUIBasedOnRole: Called. CurrentUserRole:", currentUserRole); const adminTab = document.getElementById('adminDashboardTab'); const logoutBtn = document.getElementById('logoutButton'); const appContainer = document.getElementById('appContainer'); const loginModal = document.getElementById('loginModal'); if (!appContainer || !loginModal) { console.error("[DEBUG] Critical UI elements (appContainer or loginModal) not found. UI will not function correctly."); return; } if (adminTab) adminTab.style.display = (currentUserRole === 'admin') ? 'flex' : 'none'; if (logoutBtn) logoutBtn.style.display = currentUserRole ? 'inline-block' : 'none'; if (currentUserRole) { console.log("[DEBUG] initializeUIBasedOnRole: User is logged in. Showing app."); showLoginModal(false); loadMyHistoryFromStorage(); loadSessionStateFromStorage(); loadMyHistoryItemsPerPageFromStorage(); setApiStatus();
        const initialOutputArea = document.getElementById('currentResult'); if(initialOutputArea) initialOutputArea.innerHTML = '<i class="fas fa-hourglass-half fa-spin" style="color:var(--primary);"></i> Initializing AI...'; fetchOptimizedData(DEEP_HISTORY_ITEMS_PER_PAGE).then(() => { if(periodTimerInterval) clearInterval(periodTimerInterval); periodTimerInterval = setInterval(updatePeriodAndTimer, 1000); currentTab = 'game'; fetchData(1, 'game', true); updateSessionStatsBar(); updateJarvisCard(); console.log(`[DEBUG] Initialization complete. Cached: ${cachedData.length} items.`); }).catch(err => { console.error("Error during init fetch:", err); if(initialOutputArea) initialOutputArea.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Error initializing app data.'; setApiStatus(); }); } else { console.log("[DEBUG] initializeUIBasedOnRole: No user session. Showing login modal."); showLoginModal(true); if(periodTimerInterval) clearInterval(periodTimerInterval); periodTimerInterval = null; setApiStatus(); } }
    function handleLoginAttempt() { console.log("[DEBUG] handleLoginAttempt: Initiated."); const keyInput = document.getElementById('accessKeyInput'); const enteredKey = keyInput.value.trim(); let role = null; let currentKeyToStore = null; if (!enteredKey) { showLoginError("Access Key cannot be empty."); return; } console.log("[DEBUG] Attempting login with key:", enteredKey); if (enteredKey === ADMIN_ACCESS_KEY) { role = 'admin'; currentKeyToStore = ADMIN_ACCESS_KEY; console.log("[DEBUG] Admin login successful."); } else { const managedUsers = getManagedUsers(); const foundUser = managedUsers.find(u => u.accessKey === enteredKey); if (foundUser) { console.log("[DEBUG] User found:", foundUser.username); if (foundUser.isBanned) { showLoginError("This Access Key is banned."); console.log("[DEBUG] Login failed: User banned."); return; } if (foundUser.expiresAt && Date.now() > foundUser.expiresAt) { showLoginError("This Access Key has expired."); console.log("[DEBUG] Login failed: User key expired."); return; } role = 'user'; currentKeyToStore = foundUser.accessKey; resetSessionStatistics(); console.log("[DEBUG] User login successful."); } else { console.log("[DEBUG] User not found or admin key incorrect."); } } if (role) { currentUserRole = role; robustLocalStorageSetItem(STORAGE_KEY_USER_ROLE, role); robustLocalStorageSetItem(STORAGE_KEY_CURRENT_USER_KEY, currentKeyToStore); if (keyInput) keyInput.value = ''; initializeUIBasedOnRole(); showNotification(`Logged in as ${role}.`, 'success'); } else { currentUserRole = null; robustLocalStorageSetItem(STORAGE_KEY_USER_ROLE, ''); localStorage.removeItem(STORAGE_KEY_CURRENT_USER_KEY); showLoginError("Invalid Access Key."); } }
    function handleLogout() { if (confirm("Are you sure you want to logout?")) { console.log("[DEBUG] handleLogout: Logging out."); currentUserRole = null; localStorage.removeItem(STORAGE_KEY_USER_ROLE); localStorage.removeItem(STORAGE_KEY_CURRENT_USER_KEY); const adminTab = document.getElementById('adminDashboardTab'); if (adminTab) adminTab.style.display = 'none'; const logoutBtn = document.getElementById('logoutButton'); if (logoutBtn) logoutBtn.style.display = 'none'; const historyContentEl = document.getElementById('historyContent'); if (historyContentEl) historyContentEl.innerHTML = ''; const appContainerEl = document.getElementById('appContainer'); if(appContainerEl) appContainerEl.style.display = "none"; if(periodTimerInterval) clearInterval(periodTimerInterval); periodTimerInterval = null; showLoginModal(true); showNotification('Logged out successfully.', 'info'); } }

    // --- Gemini API Integration ---
    const geminiModal = document.getElementById('geminiAnalysisModal');
    const geminiModalCloseButton = document.getElementById('geminiModalCloseButton');
    const geminiAnalysisTextEl = document.getElementById('geminiAnalysisText');
    if (geminiModalCloseButton) {
        geminiModalCloseButton.onclick = () => {
            if(geminiModal) geminiModal.style.display = "none";
        };
    }
     window.onclick = (event) => {
        if (event.target == geminiModal) {
            geminiModal.style.display = "none";
        }
        const aboutModalEl = document.getElementById('aboutModal');
        if (event.target == aboutModalEl && aboutModalEl) aboutModalEl.style.display="none";
        const contactModalEl = document.getElementById('contactModal');
        if (event.target == contactModalEl && contactModalEl) contactModalEl.style.display="none";
        const renameModalEl = document.getElementById('renameUserModal');
        if (event.target == renameModalEl && renameModalEl) renameModalEl.style.display="none";
    };
    async function getGeminiAnalysis(prompt) {
        if (!geminiModal || !geminiAnalysisTextEl) return;
        geminiAnalysisTextEl.innerHTML = '<div class="gemini-loading"><i class="fas fa-spinner fa-spin"></i> Loading analysis...</div>';
        geminiModal.style.display = "flex";
        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };

        // ================================================================= //
        // == IMPORTANT: ADD YOUR GOOGLE AI GEMINI API KEY HERE           == //
        // == You can get one from https://aistudio.google.com/app/apikey == //
        const apiKey = ""; // <--- PASTE YOUR SECURE API KEY BETWEEN THESE QUOTES
        // ================================================================= //

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
        try {
             if (!apiKey) {
                 throw new Error("Gemini API Key is missing. Please add it to the script in the 'getGeminiAnalysis' function. You can obtain a key from Google AI Studio.");
             }
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                const errorData = await response.json();
                console.error("Gemini API Error Response:", errorData);
                let errorMessage = `API Error: ${response.status} ${response.statusText}.`;
                if (errorData && errorData.error && errorData.error.message) {
                    errorMessage += ` Details: ${errorData.error.message}`;
                }
                throw new Error(errorMessage);
            }
            const result = await response.json();
            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0 &&
                result.candidates[0].content.parts[0].text) {
                const text = result.candidates[0].content.parts[0].text;
                geminiAnalysisTextEl.textContent = text;
            } else if (result.candidates && result.candidates.length > 0 && result.candidates[0].finishReason === "SAFETY") {
                 geminiAnalysisTextEl.textContent = "Analysis blocked due to safety settings. The prompt or response might contain sensitive content.";
                 console.warn("Gemini Response Blocked due to SAFETY:", result.candidates[0].safetyRatings);
            } else if (result.candidates && result.candidates.length > 0 && result.candidates[0].finishReason) {
                 geminiAnalysisTextEl.textContent = `Could not generate complete analysis. Reason: ${result.candidates[0].finishReason}. Please try again.`;
                 console.warn("Gemini Response Incomplete:", result.candidates[0]);
            }
             else {
                console.error("Gemini API - Unexpected response structure:", result);
                geminiAnalysisTextEl.textContent = "Could not generate analysis (unexpected response structure). Please try again later.";
            }
        } catch (error) {
            console.error('Error fetching Gemini analysis:', error);
            geminiAnalysisTextEl.textContent = `Failed to get analysis: ${error.message}. Please check your internet connection and ensure the API Key is set correctly and has the 'Generative Language API' enabled.`;
        }
    }
    function handleDeeperAnalysis() {
        if (!lastCompletedPeriodNumber || !currentPredictionData[lastCompletedPeriodNumber]) {
            showNotification("No prediction has been generated yet.", "error");
            return;
        }
        const predData = currentPredictionData[lastCompletedPeriodNumber];
        if (!predData || predData.error) {
             showNotification("Current prediction data is invalid or contains an error.", "error");
             return;
        }
        let recentHistoryText = "Recent game history (Period: Number, B/S, Color):\n";
        cachedData.slice(0, 5).forEach(item => {
            if (item && item.issueNumber && typeof item.number !== 'undefined') {
                const details = getNumberDetails(item.number);
                recentHistoryText += `${item.issueNumber}: ${details.numberVal}, ${details.bigSmall}, ${details.rawColor}\n`;
            }
        });
        const prompt = `
            Game: Color Prediction (Red, Green, Violet; Numbers 0-9; Big/Small)
            Current Period: ${predData.period}
            My AI's Prediction:
            - Big/Small: ${predData.predictedBS}
            - Color: ${predData.predictedRawColor} (Displayed as: ${predData.predictedColorHTML ? predData.predictedColorHTML.replace(/<[^>]+>/g, '') : 'N/A'})
            - Numbers: ${predData.predictedNumbersArray ? predData.predictedNumbersArray.join(', ') : 'N/A'}
            - Confidence: ${predData.probability}%
            - Reversal Chance: ${predData.reversalChance}%
            - Strategy Note: ${predData.message}
            Recent Game History (Last 5):
            ${recentHistoryText}
            Current Time (for context of prediction timing): ${new Date().toLocaleTimeString()}
            Time Remaining in Current Period (approx): ${document.getElementById('timer') ? document.getElementById('timer').textContent : 'N/A'}
            Task: Provide a deeper textual analysis of my AI's prediction for period ${predData.period}.
            Explain the reasoning if possible, considering the confidence, reversal chance, and recent history.
            What factors might support or contradict this prediction?
            If the prediction might not be immediate (e.g., if the result isn't available right away or if the prediction is for a future round), discuss potential reasons for any delay or how game dynamics might shift.
            Offer brief advice or alternative considerations for the user for this specific period.
            Keep the analysis concise and easy to understand for a game player. Respond in simple English.
        `;
        getGeminiAnalysis(prompt);
    }

    // --- Window Load & Event Listeners ---
    let periodTimerInterval = null;
    window.onload = async () => {
        console.log('Predict VIP King Pro (v17.8 Reviewed) Initializing...');
        initializeSampleManagedUsers();
        let loadedTheme = robustLocalStorageGetItem(STORAGE_KEY_THEME, 'dark'); // Default to 'dark' if nothing is stored
        applyTheme(loadedTheme); // Apply the loaded or default theme
        currentUserRole = robustLocalStorageGetItem(STORAGE_KEY_USER_ROLE, null);
        const storedUserKey = robustLocalStorageGetItem(STORAGE_KEY_CURRENT_USER_KEY, null);
        console.log("[DEBUG] window.onload: Retrieved role:", currentUserRole, "Key:", storedUserKey);
        let sessionStillValid = false;
        if (currentUserRole === 'admin' && storedUserKey === ADMIN_ACCESS_KEY) { sessionStillValid = true; console.log("[DEBUG] Admin session valid."); }
        else if (currentUserRole === 'user' && storedUserKey) {
            const managedUsers = getManagedUsers(); const foundUser = managedUsers.find(u => u.accessKey === storedUserKey);
            if (foundUser && !foundUser.isBanned && (!foundUser.expiresAt || Date.now() <= foundUser.expiresAt)) { sessionStillValid = true; console.log("[DEBUG] User session valid for:", foundUser.username); }
            else { console.log("[DEBUG] User session invalid. Found user:", foundUser); }
        } else { console.log("[DEBUG] No valid session found."); }
        if (!sessionStillValid) {
            console.log("[DEBUG] window.onload: Session not valid, clearing role and key.");
            currentUserRole = null; localStorage.removeItem(STORAGE_KEY_USER_ROLE); localStorage.removeItem(STORAGE_KEY_CURRENT_USER_KEY);
        }
        initializeUIBasedOnRole(); // This will call setApiStatus()
        isSoundOn = robustLocalStorageGetItem(STORAGE_KEY_SOUND_ON, 'true') === 'true';
        const soundToggleBtn = document.getElementById('soundToggleBtn');
        const soundToggleIcon = soundToggleBtn ? soundToggleBtn.querySelector('i') : null;
        function updateSoundIcon() {
            if (soundToggleIcon) {
                if (isSoundOn) { soundToggleIcon.classList.remove('fa-volume-mute'); soundToggleIcon.classList.add('fa-volume-up'); if(soundToggleBtn) soundToggleBtn.title = "Mute Sound"; }
                else { soundToggleIcon.classList.remove('fa-volume-up'); soundToggleIcon.classList.add('fa-volume-mute'); if(soundToggleBtn) soundToggleBtn.title = "Unmute Sound"; }
            }
        }
        updateSoundIcon();
        if (soundToggleBtn) {
            soundToggleBtn.onclick = (e) => {
                e.preventDefault(); isSoundOn = !isSoundOn; robustLocalStorageSetItem(STORAGE_KEY_SOUND_ON, isSoundOn.toString()); updateSoundIcon();
                const soundStatusMessage = isSoundOn ? "Sound On" : "Sound Muted";
                showNotification(soundStatusMessage, "info");
                speak(soundStatusMessage.replace("Muted", "off"));
            };
        }
        const aboutModal=document.getElementById('aboutModal'), aboutModalLink=document.getElementById('aboutModalLink'), aboutModalCloseButton=document.getElementById('aboutModalCloseButton'); if(aboutModalLink && aboutModal && aboutModalCloseButton) { aboutModalLink.onclick = (e) => { e.preventDefault(); aboutModal.style.display="flex"; }; aboutModalCloseButton.onclick = () => { aboutModal.style.display="none"; }; }
        const contactModal = document.getElementById('contactModal'), contactModalLink = document.getElementById('contactModalLink'), contactModalCloseButton = document.getElementById('contactModalCloseButton'); if(contactModalLink && contactModal && contactModalCloseButton) { contactModalLink.onclick = (e) => { e.preventDefault(); contactModal.style.display="flex"; }; contactModalCloseButton.onclick = () => { contactModal.style.display="none"; }; }
        const renameModalEl = document.getElementById('renameUserModal');
        if (renameUserModalCloseButton && renameModalEl) { renameUserModalCloseButton.onclick = () => { renameModalEl.style.display = "none"; }; }
        if (cancelRenameBtn && renameModalEl) { cancelRenameBtn.onclick = () => { renameModalEl.style.display = "none"; }; }
        const clearMyPredictionsBtn = document.getElementById('clearMyPredictionsBtn'); if (clearMyPredictionsBtn) { clearMyPredictionsBtn.onclick = clearMyPredictions; }
        const loginButtonEl = document.getElementById('loginButton'); if (loginButtonEl) loginButtonEl.onclick = handleLoginAttempt;
        const accessKeyInputEl = document.getElementById('accessKeyInput'); if (accessKeyInputEl) { accessKeyInputEl.addEventListener('keypress', function(event) { if (event.key === "Enter") { event.preventDefault(); handleLoginAttempt(); } }); }
        const logoutButtonEl = document.getElementById('logoutButton'); if (logoutButtonEl) logoutButtonEl.onclick = handleLogout;
        const themeToggleBtn = document.getElementById('themeToggleBtn');
        if (themeToggleBtn) {
            themeToggleBtn.onclick = (e) => { e.preventDefault(); toggleTheme(); };
        }
        const toggleJarvisBtn = document.getElementById('toggleJarvisCard'); if (toggleJarvisBtn) { toggleJarvisBtn.onclick = (e) => { e.preventDefault(); const content = document.getElementById('jarvisAnalyticsContent'); if(content) toggleJarvisCardVisibility(content.style.display === 'none', true); }; const jarvisVisible = robustLocalStorageGetItem(STORAGE_KEY_JARVIS_VISIBLE, 'true') === 'true'; toggleJarvisCardVisibility(jarvisVisible, false); }
        const deeperAnalysisButton = document.getElementById('deeperAnalysisBtn');
        if (deeperAnalysisButton) deeperAnalysisButton.onclick = handleDeeperAnalysis;
        window.addEventListener('online', () => {
             console.log("Internet connection detected: Online.");
             setApiStatus();
             if(currentUserRole) fetchPage(1, true);
        });
        window.addEventListener('offline', () => {
             console.log("Internet connection detected: Offline.");
             setApiStatus();
        });
        if ('speechSynthesis' in window && window.speechSynthesis.getVoices) { window.speechSynthesis.getVoices(); } // Pre-load voices
        console.log("Predict VIP King Pro Script: window.onload fully executed.");
    };
</script>

</body>
</html>
