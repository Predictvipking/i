<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predict VIP King Pro - v17.9.9 (Algo Update)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Base Styles & Variables (Initial - will be overwritten by JS) --- */
        :root {
            --primary: #D4AF37;
            --secondary: #6A0DAD;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
            --info: #17a2b8;
            --violet-accent: #6A0DAD;

            --bg-main: #1A1A1A;
            --bg-card: #2A2A2A;
            --bg-header-footer: #101010;
            --bg-interactive: #383838;
            --bg-hover: #454545;
            --bg-admin-section-mobile: #303030;
            --bg-modal-overlay: rgba(0,0,0,0.88);
            --bg-gemini-modal: #252525;

            --text-primary: #E0E0E0;
            --text-secondary: #A0A0A0;
            --text-disabled: #555555;
            --text-on-accent: #FFFFFF;

            --text-win: var(--success);
            --text-loss: var(--danger);
            --text-partial: var(--secondary); 
            --text-error: var(--warning);
            --text-num-red: var(--danger);
            --text-num-green: var(--success);

            --partial-bg: rgba(106, 13, 173, 0.15); 
            --win-bg: rgba(40, 167, 69, 0.15);
            --loss-bg: rgba(220, 53, 69, 0.15);
            --error-bg: rgba(255, 193, 7, 0.15);

            --border-color: #504A4B;
            --shadow: '0 5px 18px rgba(0, 0, 0, 0.8)';
            --tick-color: var(--success);
            --cross-color: var(--danger);
            --body-bg-gradient-start: '#1A1A1A';
            --body-bg-gradient-end': '#101010';
        }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; }
        body {
            color: var(--text-primary);
            min-height: 100vh; overflow-x: hidden; font-size: 14px; line-height: 1.4;
            transition: background-color 0.3s, color 0.3s;
            background: linear-gradient(180deg, var(--body-bg-gradient-start) 0%, var(--body-bg-gradient-end) 100%);
        }
        .container { max-width: 1080px; width: 100%; margin: 0 auto; padding: 4px; }
        header { text-align: center; margin-bottom: 0.4rem; position: relative; padding: 0.4rem; background-color: var(--bg-card); border-radius: 5px; box-shadow: var(--shadow); border: 1px solid var(--border-color); }
        h1 { font-size: 1.75rem; margin-bottom: 0.1rem; color: var(--primary); font-weight: 700; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); }
        .app-logo { max-width: 50px; max-height: 50px; vertical-align: middle; margin-right: 10px; }
        .header-title-container { display: flex; align-items: center; justify-content: center; }
        .header-subtitle-container { display: flex; align-items: center; justify-content: center; gap: 0.5rem; font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.05rem; font-weight: 400; flex-wrap: wrap; }
        .header-action-icon { color: var(--text-secondary); text-decoration: none; font-size: 1em; cursor: pointer; transition: color 0.3s ease, transform 0.2s ease; padding: 0 3px; }
        .header-action-icon:hover { color: var(--primary); transform: scale(1.1); }

        .info-modal, .gemini-modal, .confirm-modal {
            display: none; position: fixed; z-index: 1050;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: var(--bg-modal-overlay);
            align-items: center; justify-content: center;
        }
        .info-modal-content, .gemini-modal-content, .confirm-modal-content {
            color: var(--text-primary); margin: auto; padding: 15px;
            border: 1px solid var(--border-color); width: 90%;
            border-radius: 8px;
            box-shadow: var(--shadow); position: relative;
        }
        .info-modal-content { background: var(--bg-card); max-width: 420px; }
        .gemini-modal-content { background: var(--bg-gemini-modal); max-width: 500px; }
        .confirm-modal-content { background: var(--bg-card); max-width: 380px; }


        .info-modal-content h3, .gemini-modal-content h3, .confirm-modal-content h3 {
            color: var(--primary); margin-top: 0; margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color); padding-bottom: 6px;
            font-size: 1rem; font-weight: 600;
            display: flex; align-items: center; gap: 8px;
        }
        .confirm-modal-content h3 .fas {
            color: var(--warning);
        }
        .info-modal-content p, .confirm-modal-content p { margin-bottom: 4px; line-height: 1.25; font-size: 0.72rem;}
        .info-modal-content ul { list-style-position: inside; padding-left: 0; margin-bottom: 4px;}
        .info-modal-content li { margin-bottom: 2.5px; font-size: 0.72rem;}
        .info-modal-content .disclaimer-icon { color: var(--warning); }
        .info-modal-content .disclaimer-text { font-weight: bold; }
        .info-modal-content .contact-item { margin-bottom: 5px; font-size: 0.75rem; }
        .info-modal-content .contact-item strong { color: var(--secondary); }

        .info-modal-close-button, .gemini-modal-close-button, .confirm-modal-close-button {
            color: #aaa; position: absolute; top: 8px; right: 12px;
            font-size: 24px; font-weight: bold; cursor: pointer;
            transition: color 0.2s ease;
        }
        .info-modal-close-button:hover, .gemini-modal-close-button:hover, .confirm-modal-close-button:hover { color: var(--primary); }

        #geminiAnalysisText {
            font-size: 0.85rem; line-height: 1.5;
            max-height: 60vh; overflow-y: auto;
            padding: 10px; margin-bottom: 10px;
            background-color: var(--bg-main);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            white-space: pre-wrap;
        }
        #geminiAnalysisText .gemini-loading {
            display: flex; align-items: center; justify-content: center;
            padding: 20px; color: var(--text-secondary);
        }
        #geminiAnalysisText .gemini-loading i { margin-right: 10px; }


        .top-info-line { display: flex; justify-content: space-around; align-items: center; flex-wrap: nowrap; gap: 0.3rem; padding: 0.3rem 0.4rem; margin-bottom: 0.4rem; border-bottom: 1px solid var(--border-color); background-color: var(--bg-header-footer); border-radius: 4px; overflow-x: auto; }
        .top-info-line::-webkit-scrollbar { height: 2.5px; }
        .top-info-line::-webkit-scrollbar-track { background: var(--bg-header-footer); }
        .top-info-line::-webkit-scrollbar-thumb { background-color: var(--primary); border-radius: 1.5px;}
        .top-info-item { display: flex; align-items: center; justify-content: center; gap: 0.2rem; font-size: 0.8rem; color: var(--text-primary); white-space: nowrap; flex-grow: 1; flex-basis: 0; text-align: center; }
        .top-info-item .value { font-weight: 600; color: var(--text-primary); padding-left: 0.1em; font-size:0.85rem; }
        .top-info-item i { color: var(--primary); font-size: 0.9rem; margin-right: 0.1em; }
        .top-info-item#periodInfoItem { min-width: 130px; flex-shrink: 0;}
        .top-info-item:not(#periodInfoItem) { min-width: 60px; }
        #apiStatus.status-online { color: var(--success); font-weight: 600; }
        #apiStatus.status-offline { color: var(--danger); font-weight: 600; }
        .card { margin-bottom: 3px; padding: 6px; background-color: var(--bg-card); border-radius: 6px; box-shadow: var(--shadow); border: 1px solid var(--border-color); }
        .prediction-card { margin-bottom: 3px; }
        .card-title { font-size: 0.95rem; margin: -6px -6px 4px -6px; padding: 6px 8px; color: var(--primary); display: flex; align-items: center; justify-content: space-between; gap: 4px; font-weight: 600; border-bottom: 1px solid var(--border-color); border-radius: 6px 6px 0 0; background-color: var(--bg-header-footer); }
        .card-title > div { display: flex; align-items: center; gap: 4px; }
        .card-title i { font-size: 1rem; margin-right: 2.5px; }
        .card-title .header-action-icon { font-size: 0.9em; }
        .clear-btn { background: var(--danger); color: var(--text-on-accent); border: none; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; font-weight: 500; transition: background-color 0.2s; }
        .clear-btn i { margin-right: 3px; }
        .clear-btn:hover { background-color: #a00020; }
        body.light-theme .clear-btn:hover { background-color: #C62828; }

        .main-interactive-area { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; padding: 0.15rem 0; }
        .output-area { flex-grow: 1; width: 100%; max-width: 100%; min-width: 250px; padding: 0; border: none; }
        #currentResult { font-size: 0.95rem; line-height: 1.4; text-align: center; white-space: nowrap; overflow-x: auto; overflow-y: hidden; padding: 0.4rem 0.3rem; background-color: var(--bg-card); border-radius: 4px; color: var(--text-primary); border: 1px solid var(--border-color); }
        #currentResult::-webkit-scrollbar { height: 2.5px; }
        #currentResult::-webkit-scrollbar-track { background: var(--bg-interactive); }
        #currentResult::-webkit-scrollbar-thumb { background-color: var(--secondary); border-radius: 1.5px; }
        .prediction-output-item { display: inline-block; margin: 0 3px; vertical-align: middle; font-size: 1em; }
        .prediction-output-label { color: var(--text-secondary); margin-right: 2px; font-size: 0.9em; }
        .prediction-output-value { font-weight: 500; color: var(--text-primary); font-size: 1em; }
        .prediction-output-item.p-bs .prediction-output-value,
        .prediction-output-item.p-color .prediction-output-value { color: var(--primary); font-weight: 600; font-size: 1.15em; }
        .prediction-output-item.p-perc .prediction-output-value { color: var(--info); font-weight: 500; }
        .prediction-output-item.p-rev .prediction-output-value { color: var(--warning); font-weight: 500; }
        .prediction-output-item.p-nums .prediction-output-value { color: var(--secondary); font-weight: 500; font-size: 1.05em;}
        .prediction-output-item.p-color .color-dot { vertical-align: middle; margin-right: 2px;}
        .prediction-output-item.p-strat .prediction-output-value { color: var(--text-secondary); font-size: 0.9em; font-style: italic; max-width: 75px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; vertical-align: middle; }

        .gemini-button {
            background-color: var(--info); color: var(--text-on-accent); border: none;
            padding: 3px 8px; border-radius: 4px; cursor: pointer;
            font-size: 0.7rem; font-weight: 500; transition: background-color 0.2s;
            margin-left: 8px; vertical-align: middle;
        }
        .gemini-button:hover { background-color: #2980B9; }
        body.light-theme .gemini-button:hover { background-color: #0277BD; }

        #aiGameTypeSelectorContainer {
            display: inline-flex;
            align-items: center;
            margin-right: 8px;
        }
        #aiGameTypeSelector {
            background-color: var(--bg-interactive);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 2px 5px;
            font-size: 0.7rem;
            font-weight: 500;
            height: auto;
            line-height: 1.2;
        }

        /* New Algorithm Card Styles */
        #newAlgoCard { margin-top: 4px; }
        .new-algo-grid {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            padding: 8px 10px;
        }
        .algo-section {
            flex: 1 1 0; /* Allow sections to grow and shrink equally */
            font-size: 0.75rem;
            padding: 6px 8px;
            background-color: var(--bg-main);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        .algo-section h4 {
            color: var(--primary);
            margin: 0 0 6px 0;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 5px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 4px;
        }
        .algo-section p {
            color: var(--text-secondary);
            margin-bottom: 6px;
            font-size: 0.7rem;
            line-height: 1.3;
            min-height: 1.3em; /* Reserve space for 1 line of analysis text */
        }
        .algo-section .algo-suggestion {
            font-size: 0.8rem;
        }
        .algo-section .algo-suggestion strong {
            color: var(--text-primary);
        }

        .tabs { display: flex; margin-bottom: 0rem; border-bottom: 1px solid var(--border-color); gap: 1.5px; background-color: var(--bg-header-footer); border-radius: 4px 4px 0 0; }
        .tabs button { flex: 1; padding: 0.35rem; background: none; border: none; color: var(--text-secondary); font-weight: 500; cursor: pointer; position: relative; transition: background-color 0.2s, color 0.2s, border-bottom-color 0.2s; display: flex; align-items: center; justify-content: center; gap: 0.2rem; border-bottom: 2px solid transparent; font-size: 0.85rem; }
        .tabs button .tab-text-short { display: none; }
        .tabs button.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: 600; background-color: var(--bg-interactive); }
        .tabs button:hover:not(.active) { color: var(--primary); background-color: var(--bg-hover); }
        .my-history-controls { padding: 4px 8px; background-color: var(--bg-header-footer); display: flex; gap: 8px; align-items: center; font-size: 0.8rem; border-bottom: 1px solid var(--border-color); margin-bottom: 1px; }
        .my-history-controls label { color: var(--text-secondary); }
        .my-history-controls select { background-color: var(--bg-interactive); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 3px; padding: 2px 4px; font-size: 0.8rem; }
        .history-header { display: none; gap: 1px 2px; padding: 3px 4px; font-weight: 500; border-bottom: 1px solid var(--border-color); font-size: 0.65rem; color: var(--text-secondary); background: var(--bg-header-footer); text-transform: uppercase; margin-bottom: 1px; }
        #gameHistoryHeader, #myHistoryHeader, #adminDashboardHeader { border-top-left-radius: 0; border-top-right-radius: 0; }

        #gameHistoryHeader { grid-template-columns: 2.2fr 0.8fr 1.2fr 2.8fr; }
        .history-item.game-result-item { grid-template-columns: 2.2fr 0.8fr 1.2fr 2.8fr; }

        #myHistoryHeader {} /* Will be set by JS */
        .history-item.my-prediction-item {
            line-height: 1.15; padding: 1.5px 2.5px; font-size: 0.78rem;
        }


        #gameHistoryHeader .history-header-item, .history-item.game-result-item .history-value { text-align: center; justify-content: center; }
        #gameHistoryHeader .history-header-item:first-child, .history-item.game-result-item .history-value:first-child { text-align: left; justify-content: flex-start; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .history-item.game-result-item .gh-num { font-weight: 600; }
        .history-item.game-result-item .gh-num-red { color: var(--text-num-red); }
        .history-item.game-result-item .gh-num-green { color: var(--text-num-green); }
        .history-item.game-result-item .gh-bs { font-weight: 600; }
        .history-item.game-result-item .gh-bs-big { color: var(--warning); }
        .history-item.game-result-item .gh-bs-small { color: var(--info); }
        .history-item.game-result-item .gh-color { display: flex; align-items: center; justify-content: center; gap: 3px; }
        .history-item.game-result-item .gh-color .color-dot { margin-right: 0px; margin-left: 2px; }
        #myHistoryHeader .history-header-item { text-align: center; white-space: nowrap; }
        #myHistoryHeader .history-header-item:first-child { text-align: left; }
        .history-item.my-prediction-item .history-value { font-size: 0.72rem; padding: 0px 1px; line-height: 1.1; }
        .history-item.my-prediction-item .history-value:first-child { text-align: left; justify-content: flex-start; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 85px; }
        .history-item.my-prediction-item .history-value.predicted-bs-value,
        .history-item.my-prediction-item .history-value.predicted-color-value .color-dot { margin-right: 2px; }
        .history-item.my-prediction-item .history-value.predicted-color-value, .history-item.my-prediction-item .history-value.status-value, .history-item.my-prediction-item .history-value.predicted-num-value { text-align: center; justify-content: center; }
        #adminDashboardHeader { display: none; }

        .history-content {
            background: var(--bg-main);
            border-radius: 0 0 5px 5px;
            padding: 0.15rem 0;
            min-height: 170px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) var(--bg-main);
            transition: max-height 0.3s ease-out;
        }
        .history-content::-webkit-scrollbar { width: 3px; }
        .history-content::-webkit-scrollbar-track { background: var(--bg-main); border-radius: 3px; }
        .history-content::-webkit-scrollbar-thumb { background-color: var(--primary); border-radius: 3px; }

        .history-item { background: var(--bg-interactive); border: 1px solid var(--border-color); border-radius: 3px; margin: 0 0.1rem 1.5px 0.1rem; display: grid; gap: 1px 2px; align-items: center; transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease; box-shadow: 0 0.5px 0.5px rgba(0,0,0,0.05); }
        .history-item:not(.my-prediction-item) { padding: 2.5px 3.5px; font-size: 0.8rem; }
        .history-item:hover { border-color: var(--primary); background-color: var(--bg-hover); }
        .history-item.my-prediction-item.row-win { background-color: var(--win-bg); border-color: rgba(76, 175, 80, 0.2); }
        .history-item.my-prediction-item.row-loss { background-color: var(--loss-bg); border-color: rgba(220, 20, 60, 0.2); }
        .history-item.my-prediction-item.row-partial { background-color: var(--partial-bg); border-color: rgba(184, 134, 11, 0.2); }
        .history-item.my-prediction-item.row-error { background-color: var(--error-bg); border-color: rgba(255, 193, 7, 0.2); }
        .history-item .history-value {
            font-weight: 400; display: flex; align-items: center;
            color: var(--text-primary); text-align: center; justify-content: center;
            padding: 0.5px 1.5px; line-height: 1.15; font-size: 0.75rem;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .history-item .history-value.action-cell { justify-content: center; }
        .history-item .status-win { color: var(--text-win); font-weight: bold; }
        .history-item .status-loss { color: var(--text-loss); font-weight: bold; }
        .history-item .status-partial { color: var(--text-partial); font-weight: 500; }
        .history-item .status-error { color: var(--text-error); font-style: italic; }
        .tick-mark { color: var(--tick-color); margin-left: 1.5px; font-weight: bold; font-size: 0.85em; }
        .cross-mark { color: var(--cross-color); margin-left: 1.5px; font-weight: bold; font-size: 0.85em; }
        .color-dot { display: inline-block; width: 6.5px; height: 6.5px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.15); vertical-align: middle; margin-right: 1px; margin-left: 1px; }
        body.light-theme .color-dot { border: 1px solid rgba(44,62,80,0.1); }
        .color-red { background-color: var(--danger); }
        .color-green { background-color: var(--success); }
        .color-violet { background-color: var(--violet-accent); }
        .stats-bar { background-color: var(--bg-header-footer); padding: 5.5px 8.5px; margin-top: 0; margin-bottom: 3.5px; border-radius: 0 0 4px 4px; border: 1px solid var(--border-color); border-top: none; box-shadow: var(--shadow); display: flex; justify-content: space-around; align-items: center; flex-wrap: nowrap; overflow-x: auto; gap: 6.5px 10.5px; font-size: 0.85rem; }
        .stats-bar-item { display: flex; align-items: center; gap: 3.5px; color: var(--text-secondary); flex-shrink: 0; }
        .stats-bar-item strong { color: var(--text-primary); font-weight: 500; }
        .stats-bar-item .value { font-weight: 500; } .stats-bar-item .win { color: var(--success); } .stats-bar-item .loss { color: var(--danger); } .stats-bar-item .acc { color: var(--primary); } .stats-bar-item .rev { color: var(--warning); } .stats-bar-item .level { color: var(--info); font-weight: bold;} .stats-bar-item .partial { color: var(--text-partial); }
        .analytics-grid { display: grid; grid-template-columns: auto auto 1fr; gap: 3px 6px; align-items: center; font-size: 0.75rem; margin-top: 3.5px; padding: 8px; background: var(--bg-interactive); border-radius: 4px; }
        .analytics-grid > div { padding: 2px 0; }
        .analytics-grid > div:nth-child(3n+1) { font-weight: 500; display: flex; align-items: center; color:var(--text-secondary); }
        .analytics-grid > div:nth-child(3n+1) strong {color: var(--text-primary);}
        .analytics-grid > div:nth-child(3n+2) { font-weight: 600; text-align: right; color:var(--text-primary); }
        .analytics-grid > div:nth-child(3n) { text-align: right; color: var(--secondary); }
        .analytics-grid h4 { grid-column: 1 / -1; margin-bottom: 6px; color: var(--primary); border-bottom: 1px solid var(--border-color); padding-bottom: 3px; font-size: 0.85rem; }
        .analytics-grid .outcome-icon { display: inline-block; width: 10.5px; height: 10.5px; line-height: 10.5px; text-align: center; border-radius: 2px; margin-right: 3.5px; font-weight: bold; color: var(--bg-card); font-size: 0.55rem;}
        .analytics-grid .outcome-icon.big { background-color: var(--warning); }
        .analytics-grid .outcome-icon.small { background-color: var(--info); }
        .analytics-grid .session-accuracy-footer { grid-column: 1 / -1; text-align: center; margin-top: 6px; padding-top: 6px; border-top: 1px solid var(--border-color); color: var(--primary); font-weight: 500; font-size: 0.8rem;}

        #jarvisAnalyticsCard { margin-top: 0; margin-bottom: 4px; background-color: var(--bg-card); }
        #jarvisAnalyticsContent { padding: 8px 10px; }
        .jarvis-stats-bar { display: flex; justify-content: flex-start; align-items: center; flex-wrap: nowrap; overflow-x: auto; background-color: var(--bg-interactive); padding: 5px 4px; border-radius: 4px; margin-bottom: 10px; }
        .jarvis-stats-bar::-webkit-scrollbar { height: 3px; }
        .jarvis-stats-bar::-webkit-scrollbar-track { background: var(--bg-interactive); }
        .jarvis-stats-bar::-webkit-scrollbar-thumb { background-color: var(--primary); border-radius: 1.5px;}
        .jarvis-stat-item { display: flex; align-items: baseline; padding: 2px 8px; font-size: 0.72rem; color: var(--text-primary); white-space: nowrap; flex-shrink: 0; border-right: 1px solid var(--border-color); }
        .jarvis-stat-item:last-child { border-right: none; }
        .jarvis-label { font-weight: 500; color: var(--text-secondary); margin-right: 3px; }
        .jarvis-value { font-weight: 600; color: var(--primary); font-size: 0.8rem; }
        .jarvis-details { font-size: 0.68rem; color: var(--text-secondary); margin-left: 3px; }
        #jarvisAlertsContainer .jarvis-alert { padding: 7px 10px; margin-top: 6px; border-radius: 4px; font-size: 0.78rem; display: flex; align-items: center; gap: 6px; border: 1px solid transparent; }
        #jarvisAlertsContainer .jarvis-alert.danger { background-color: rgba(220, 53, 69, 0.2); color: #F5C6CB; border-color: rgba(220,53,69,0.5); }
        body.light-theme #jarvisAlertsContainer .jarvis-alert.danger { background-color: rgba(211, 47, 47, 0.1); color: #C62828; border-color: rgba(211,47,47,0.4); }
        #jarvisAlertsContainer .jarvis-alert.warning { background-color: rgba(255, 193, 7, 0.2); color: #FFDA6B; border-color: rgba(255,193,7,0.5); }
        body.light-theme #jarvisAlertsContainer .jarvis-alert.warning { background-color: rgba(251, 192, 45, 0.1); color: #D35400; border-color: rgba(251,192,45,0.4); }
        #jarvisAlertsContainer .jarvis-alert i { font-size: 0.95em; }
        #jarvisOverall { font-weight: bold; }

        .pagination { display: flex; justify-content: center; gap: 0.25rem; margin-top: 0.4rem; padding-bottom: 4px; }
        .pagination button { padding: 0.25rem 0.4rem; background: var(--bg-interactive); border: 1px solid var(--border-color); border-radius: 3.5px; color: var(--primary); cursor: pointer; transition: background-color 0.3s, border-color 0.3s; font-size: 0.85rem; }
        .pagination button:hover:not(:disabled) { background-color: var(--bg-hover); border-color: var(--secondary); }
        .pagination button.active { background-color: var(--primary); color: var(--text-on-accent); border-color: var(--primary); }
        .pagination button:disabled { opacity: 0.4; cursor: not-allowed; background-color: var(--bg-interactive); color: var(--text-disabled); }
        .floating-notification { position: fixed; bottom: 8px; right: 8px; color: var(--text-on-accent); padding: 0.4rem 0.6rem; border-radius: 4px; box-shadow: var(--shadow); transform: translateY(70px); opacity: 0; transition: all 0.4s ease-out; z-index: 1050; display: flex; align-items: center; gap: 0.2rem; font-size: 0.75rem; background-color: var(--bg-header-footer); }
        .floating-notification.show { transform: translateY(0); opacity: 1; }
        .floating-notification i { margin-right: 0.2rem; }
        .floating-notification.success-bg { background-color: var(--success); }
        .floating-notification.error-bg { background-color: var(--danger); }
        .floating-notification.info-bg { background-color: var(--info); }

        /* --- Admin Panel --- */
        .admin-section {
            margin-bottom: 12px; padding: 10px; background-color: var(--bg-interactive);
            border-radius: 6px; border: 1px solid var(--border-color);
        }
        .admin-section h5 {
            color: var(--primary); margin-top: 0; margin-bottom: 8px;
            border-bottom: 1px solid var(--border-color); padding-bottom: 6px; font-size: 0.9rem;
        }
        #adminUserManagementTopControls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; align-items: flex-end; }
        #adminUserStats { display: flex; flex-wrap: wrap; gap: 8px 12px; align-items: center; background-color: var(--bg-header-footer); padding: 6px 10px; border-radius: 4px; flex-shrink: 0; margin-bottom: 6px;}
        #adminUserStats span { font-size: 0.75rem; }
        #createUserFormContainer { flex-grow: 1; display: flex; flex-direction: column; gap: 6px; background-color: var(--bg-header-footer); padding: 8px 10px; border-radius: 4px; min-width: auto; }
        #createUserFormContainer h6 { font-size: 0.75rem; margin:0 0 5px 0; color: var(--text-secondary); }

        #createUserFormControls { display: flex; flex-direction: row; align-items: center; gap: 6px; flex-wrap: nowrap; }
        #createUserFormControls label { color: var(--text-secondary); font-size: 0.7rem; margin-right: 3px; flex-shrink: 0; }
        #createUserFormControls select {
            padding: 4px 6px; background-color: var(--bg-card); color: var(--text-primary);
            border: 1px solid var(--border-color); border-radius: 3px; font-size: 0.7rem;
            flex-grow: 1; min-width: 80px; height: 28px;
        }
        #createUserFormControls button {
            padding: 4px 8px; font-size: 0.7rem; flex-shrink: 0;
            background-color: var(--success) !important; height: 28px;
            border: none; color: var(--text-on-accent); cursor: pointer;
        }
        #generatedUserKey { margin-top: 6px; font-size: 0.75rem; min-height: 1em; color: var(--success); word-break: break-all;}

        #managedUsersListContainer {
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        #managedUsersListContainer .admin-list-header,
        #managedUsersListContainer .history-item.managed-user-item {
            display: grid;
            grid-template-columns: minmax(65px, 0.75fr) minmax(65px, 0.9fr) minmax(95px, 1.4fr) minmax(35px, 0.45fr) minmax(65px, 0.75fr) minmax(45px, 0.45fr);
            gap: 0.5px;
            padding: 0px;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
        }
        #managedUsersListContainer .admin-list-header .history-header-item,
        #managedUsersListContainer .history-item.managed-user-item .history-value {
            font-size: 0.65rem;
            line-height: 1.3;
            padding: 2px 4px;
            text-align: left;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            vertical-align: middle;
        }
        #managedUsersListContainer .admin-list-header .history-header-item {
            font-weight: bold;
            color: var(--primary);
            background-color: var(--bg-header-footer) !important;
            text-transform: uppercase;
        }
        #managedUsersListContainer .history-item.managed-user-item .history-value.key-cell {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.60rem;
        }

        #managedUsersListContainer .admin-list-header .history-header-item { color: var(--primary); }
        #managedUsersListContainer .history-item.managed-user-item {
            background-color: var(--bg-interactive);
            margin-bottom: 0;
            border-radius: 0;
        }
        #managedUsersListContainer .history-item.managed-user-item:last-child {
            border-bottom: none;
        }
        #managedUsersListContainer .history-item.managed-user-item:hover { background-color: var(--bg-hover); }

        #managedUsersListContainer .admin-list-header .history-header-item:nth-child(4),
        #managedUsersListContainer .history-item.managed-user-item .history-value:nth-child(4),
        #managedUsersListContainer .admin-list-header .history-header-item:last-child,
        #managedUsersListContainer .history-item.managed-user-item .history-value:last-child {
            text-align: center;
            justify-content: center;
        }
        #managedUsersListContainer .history-item.managed-user-item .history-value button.admin-action-btn {
            font-size: 0.8em;
            padding: 1px 2.5px;
            margin: 0 0.5px;
            background-color: var(--bg-card);
            color:var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius:2px;
            cursor:pointer;
            min-width: 13px;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        #managedUsersListContainer .history-item.managed-user-item .history-value button.ban-btn { border-color: var(--danger); color: var(--danger); }
        #managedUsersListContainer .history-item.managed-user-item .history-value button.unban-btn { border-color: var(--success); color: var(--success); }
        #managedUsersListContainer .history-item.managed-user-item .history-value button.delete-btn { border-color: var(--warning); color: var(--warning); }
        #managedUsersListContainer .history-item.managed-user-item .history-value button.rename-btn { border-color: var(--info); color: var(--info); }


        @media (max-width: 768px) {
            .main-interactive-area { flex-direction: column; align-items: stretch; }
            .output-area { max-width: 100%; margin-top: 0.5rem; }
            #currentResult { white-space: normal; overflow-x: hidden; font-size: 0.9rem; }
            .admin-section { background-color: var(--bg-admin-section-mobile); padding: 8px; margin-bottom: 10px;}
            #adminUserManagementTopControls { flex-direction: column; align-items: stretch; gap: 8px; }
            .tabs button { font-size: 0.7rem; }
            .tabs button .tab-text-long { display: none; }
            .tabs button .tab-text-short { display: inline; }

            #managedUsersListContainer { max-height: 280px; }
            #managedUsersListContainer .admin-list-header,
            #managedUsersListContainer .history-item.managed-user-item {
                grid-template-columns: minmax(58px, 0.7fr) minmax(50px, 0.8fr) minmax(70px, 1.2fr) minmax(28px, 0.4fr) minmax(58px, 0.7fr) minmax(40px, 0.4fr);
            }
            #managedUsersListContainer .admin-list-header .history-header-item,
            #managedUsersListContainer .history-item.managed-user-item .history-value { font-size: 0.6rem; }
            #managedUsersListContainer .history-item.managed-user-item .history-value.key-cell { font-size: 0.58rem; }
            #managedUsersListContainer .history-item.managed-user-item .history-value button.admin-action-btn { font-size: 0.75em; min-width: 12px; padding: 0.5px 1.5px;}
        }

        @media (max-width: 576px) {
            body { font-size: 13px; }
            h1 { font-size: 1.3rem; }
            .admin-section { padding: 5px; margin-bottom: 8px; }
            .tabs button { font-size: 0.6rem; gap: 0.1rem;}
            .tabs button i { font-size: 0.7em; }
            .new-algo-grid { flex-direction: column; } /* Stack algo sections on very small screens */

            #managedUsersListContainer { max-height: 250px; }
            #managedUsersListContainer .admin-list-header,
            #managedUsersListContainer .history-item.managed-user-item {
                grid-template-columns: minmax(45px, 0.65fr) minmax(40px, 0.75fr) minmax(60px, 1.2fr) minmax(22px, 0.35fr) minmax(45px, 0.65fr) minmax(38px, 0.4fr);
                line-height: 1.1;
            }
            #managedUsersListContainer .admin-list-header .history-header-item { font-size: 0.52rem; padding: 1px;}
            #managedUsersListContainer .history-item.managed-user-item .history-value { font-size: 0.52rem; padding: 1px;}
            #managedUsersListContainer .history-item.managed-user-item .history-value.key-cell { font-size: 0.50rem; }
            #managedUsersListContainer .history-item.managed-user-item .history-value button.admin-action-btn { font-size: 0.7em; min-width: 10px; padding: 0;}
        }
    </style>
</head>
<body>
    <div id="loginModal" class="info-modal" style="display: none;">
        <div class="info-modal-content" style="width: 90%; max-width: 350px;"> <h3 style="text-align: center; color: var(--primary); font-size: 1.2rem; margin-bottom: 5px;">Predict VIP King Pro</h3>
            <p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 15px;">Enter Access Key & Select Pattern</p>

            <label for="loginPredictionPattern" style="display: block; font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 5px;">Prediction Pattern:</label>
            <select id="loginPredictionPattern" style="width: 100%; padding: 10px; margin-bottom: 12px; background-color: var(--bg-interactive); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 0.9rem;">
                <option value="bs_num">Big / Small & Number</option>
                <option value="only_col">Only Color</option>
            </select>

            <label for="accessKeyInput" style="display: block; font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 5px;">Access Key:</label>
            <input type="password" id="accessKeyInput" placeholder="Your Access Key" style="width: 100%; padding: 10px; margin-bottom: 12px; background-color: var(--bg-interactive); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 0.9rem;">

            <button id="loginButton" style="width: 100%; padding: 10px; background-color: var(--primary); color: var(--text-on-accent); border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 500;">Login</button>
            <p id="loginError" style="color: var(--danger); font-size: 0.8rem; margin-top: 8px; text-align: center; display: none;">Invalid Access Key or Pattern Mismatch</p>
        </div>
    </div>

    <div id="confirmClearModal" class="confirm-modal" style="display: none;">
        <div class="confirm-modal-content">
            <span class="confirm-modal-close-button" id="confirmClearModalCloseButton">&times;</span>
            <h3><i class="fas fa-exclamation-triangle"></i> Confirm Clear</h3>
            <p style="font-size: 0.8rem; margin-bottom: 15px;">Are you sure you want to clear all your prediction history? This action cannot be undone.</p>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button id="cancelClearBtn" class="gemini-button" style="background-color: var(--secondary);">Cancel</button>
                <button id="confirmClearExecuteBtn" class="clear-btn">Confirm Clear</button>
            </div>
        </div>
    </div>


    <div id="geminiAnalysisModal" class="gemini-modal">
        <div class="gemini-modal-content">
            <span class="gemini-modal-close-button" id="geminiModalCloseButton">&times;</span>
            <h3><i class="fas fa-magic"></i> Gemini AI Analysis</h3>
            <div id="geminiAnalysisText">
                <div class="gemini-loading"><i class="fas fa-spinner fa-spin"></i> Loading analysis...</div>
            </div>
        </div>
    </div>

    <div id="renameUserModal" class="info-modal" style="display: none;">
        <div class="info-modal-content" style="max-width: 380px;">
            <span class="info-modal-close-button" id="renameUserModalCloseButton">&times;</span>
            <h3><i class="fas fa-edit"></i> Rename User</h3>
            <p style="font-size: 0.8rem; margin-bottom: 8px;">Current User: <strong id="currentUsernameRename">N/A</strong></p>
            <input type="text" id="newUsernameInput" placeholder="Enter new username" style="width: 100%; padding: 8px; margin-bottom: 12px; background-color: var(--bg-interactive); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 0.85rem;">
            <input type="hidden" id="userAccessKeyToRename">
            <div style="display: flex; justify-content: flex-end; gap: 8px;">
                <button id="cancelRenameBtn" class="clear-btn" style="background-color: var(--secondary);">Cancel</button>
                <button id="saveRenameBtn" class="gemini-button" style="background-color: var(--success);">Save Name</button>
            </div>
        </div>
    </div>


    <div class="container" id="appContainer" style="display: none;">
        <header>
            <div class="header-title-container">
                <h1>Predict VIP King Pro</h1>
            </div>
            <div class="header-subtitle-container">
                <span>AI GOLD EDITION (v17.9.9)</span>
                <a href="https://www.bdgin03.com//#/register?invitationCode=3783710836033" target="_blank" class="header-action-icon" title="Register"> <i class="fas fa-user-plus"></i> </a>
                <a href="#" id="soundToggleBtn" class="header-action-icon" title="Mute Sound"> <i class="fas fa-volume-up"></i> </a>
                <a href="#" id="contactModalLink" class="header-action-icon" title="Contact Details"> <i class="fas fa-envelope"></i> </a>
                <a href="#" id="aboutModalLink" class="header-action-icon" title="About & How to Use"> <i class="fas fa-info-circle"></i> </a>
                <a href="#" id="themeToggleBtn" class="header-action-icon" title="Toggle Theme"> <i class="fas fa-sun"></i> </a>
                <a href="#" id="logoutButton" class="header-action-icon" title="Logout" style="display: none; margin-left: 5px;"> <i class="fas fa-sign-out-alt"></i> </a>
            </div>
        </header>

        <div id="aboutModal" class="info-modal">
            <div class="info-modal-content">
                <span class="info-modal-close-button" id="aboutModalCloseButton">&times;</span>
                <h3><i class="fas fa-info-circle"></i> How to Use Predict VIP King Pro</h3>
                <p>The system automatically analyzes game history. Select prediction pattern at login.</p>
                <ul>
                    <li><strong>Login Pattern Selection:</strong>
                        <ul>
                            <li>At login, choose "Big / Small & Number" or "Only Color".</li>
                            <li>This selection dictates the AI's prediction display and how "My History" evaluates wins/losses. Specific access keys may enforce a pattern.</li>
                            <li>Admin Key: `J0@lroy1991$` (Select pattern from dropdown)</li>
                            <li>Key for "Only Color": `J0@lroy1991$1234` (Forces "Only Color" pattern)</li>
                            <li>Key for "Big / Small & Number": `Vippredict@9876$` (Forces "Big / Small & Number" pattern)</li>
                        </ul>
                    </li>
                    <li><strong>AI Prediction Output:</strong> Display dynamically changes based on selected login pattern.
                        <ul>
                            <li>If "Big / Small & Number" selected: Shows B/S and Number(s) predictions.</li>
                            <li>If "Only Color" selected: Shows predicted Color.</li>
                            <li>Confidence, Reversal, and Strategy notes are always shown.</li>
                            <li>If consecutive losses exceed 2, the AI may internally shift its primary focus to Big/Small, and the strategy message will indicate this.</li>
                        </ul>
                    </li>
                    <li><strong>My History:</strong> Columns and win/loss evaluation adapt to the pattern selected at the time of prediction. Statuses are "Win", "Loss", or "Partial".</li>
                    <li><strong>UI Themes:</strong> Supports "Crimson Night" (dark) and "Ocean Breeze" (light).</li>
                    <li><strong>Voice Output & Gemini Analysis:</strong> Available as before.</li>
                </ul>
                <p><i class="fas fa-exclamation-triangle disclaimer-icon"></i> <span class="disclaimer-text">Disclaimer:</span> For analysis/education. Use responsibly.</p>
            </div>
        </div>
        <div id="contactModal" class="info-modal">
            <div class="info-modal-content">
                <span class="info-modal-close-button" id="contactModalCloseButton">&times;</span>
                <h3><i class="fas fa-envelope"></i> Contact Information</h3>
                <div class="contact-item"> <strong>Email:</strong> vippredictking@zohomail.in </div>
                <div class="contact-item"> <strong>Developer:</strong> Kumghato </div>
                <p style="font-size: 0.7rem; margin-top: 10px; color: var(--text-secondary);">For support or inquiries, please use the email above.</p>
            </div>
        </div>

        <div class="card" id="jarvisAnalyticsCard">
            <div class="card-title">
                <div><i class="fas fa-robot"></i> Jarvis AI Analytics</div>
                <div>
                    <a href="#" id="toggleJarvisCard" class="header-action-icon" title="Toggle Analytics">
                        <i class="fas fa-eye"></i>
                    </a>
                </div>
            </div>
            <div id="jarvisAnalyticsContent" style="padding: 8px 10px;">
                <div class="jarvis-stats-bar">
                    <div class="jarvis-stat-item">
                        <span class="jarvis-label">L10:</span>
                        <span class="jarvis-value" id="jarvisL10Rate">N/A</span>
                        <span class="jarvis-details" id="jarvisL10Details">(0W/0L/0P)</span>
                    </div>
                    <div class="jarvis-stat-item">
                        <span class="jarvis-label">L20:</span>
                        <span class="jarvis-value" id="jarvisL20Rate">N/A</span>
                        <span class="jarvis-details" id="jarvisL20Details">(0W/0L/0P)</span>
                    </div>
                    <div class="jarvis-stat-item">
                        <span class="jarvis-label">L30:</span>
                        <span class="jarvis-value" id="jarvisL30Rate">N/A</span>
                        <span class="jarvis-details" id="jarvisL30Details">(0W/0L/0P)</span>
                    </div>
                    <div class="jarvis-stat-item">
                        <span class="jarvis-label">L50:</span>
                        <span class="jarvis-value" id="jarvisL50Rate">N/A</span>
                        <span class="jarvis-details" id="jarvisL50Details">(0W/0L/0P)</span>
                    </div>
                </div>
                <div id="jarvisAlertsContainer" style="margin-top: 8px;">
                </div>
                <div style="text-align: right; margin-top: 5px; font-size: 0.75rem;">
                    Overall: <strong id="jarvisOverall" style="font-weight: bold;">N/A</strong>
                </div>
            </div>
        </div>

        <div class="top-info-line">
            <div class="top-info-item" id="timerInfoItem"> <i class="fas fa-clock"></i><span class="value" id="timer">00s</span> </div>
            <div class="top-info-item" id="periodInfoItem"> <i class="fas fa-hashtag"></i><span class="value" id="period">N/A</span> </div>
            <div class="top-info-item" id="statusInfoItem"> <i class="fas fa-bolt"></i><span class="value" id="status">Active</span> </div>
            <div class="top-info-item" id="apiStatusInfoItem"> <i class="fas fa-server"></i><span class="value" id="apiStatus">Checking...</span> </div>
        </div>

        <div class="card" id="userGameSelectionCard" style="display: none; margin-bottom: 4px;">
             <p id="userGameSelectionInfo" style="text-align:center; font-size:0.8rem; color: var(--text-secondary); padding: 10px;">Login Pattern: <strong id="currentUserFocusDisplay" style="color:var(--primary)"></strong></p>
        </div>

        <div class="prediction-section">
            <div class="card prediction-card" id="aiPredictionCard"> <div class="card-title">
                    <div><i class="fas fa-brain"></i> AI Prediction Output</div>
                    <div id="aiGameTypeSelectorContainer" style="display: none;">
                        <select id="aiGameTypeSelector" title="Select AI Analysis Focus">
                             <option value="bs_num">Big / Small & Number</option>
                             <option value="only_col">Only Color</option>
                        </select>
                    </div>
                    <button id="deeperAnalysisBtn" class="gemini-button" title="Get Deeper Analysis of AI Prediction">✨ Deeper Analysis</button>
                </div>
                <div class="main-interactive-area">
                    <div class="output-area">
                        <div class="result-display" style="margin-top:0; padding: 0.3rem;">
                            <div id="currentResult">
                                <i class="fas fa-hourglass-half fa-spin"></i> Waiting for next prediction...
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- New Algorithm Card -->
        <div class="card" id="newAlgoCard">
            <div class="card-title">
                <div><i class="fas fa-calculator"></i> New Algorithm & Calculation</div>
            </div>
            <div class="new-algo-grid">
                <div class="algo-section" id="algoColorSection">
                    <h4><i class="fas fa-palette"></i> Color Analysis (Last 10)</h4>
                    <p id="algoColorLogic">Calculating...</p>
                    <div class="algo-suggestion" id="algoColorSuggestion">
                        <strong>Suggestion:</strong> <span>N/A</span>
                    </div>
                </div>
                <div class="algo-section" id="algoNumberSection">
                    <h4><i class="fas fa-dice"></i> Number Analysis (Last 10)</h4>
                    <p id="algoNumberLogic">Calculating...</p>
                    <div class="algo-suggestion" id="algoNumberSuggestion">
                        <strong>Suggestion:</strong> <span>N/A</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 class="card-title">
                <div><i class="fas fa-history"></i> History & Analytics</div>
                <button id="clearMyPredictionsBtn" class="clear-btn" title="Clear My Predictions Log">
                    <i class="fas fa-trash-alt"></i> Clear
                </button>
            </h2>
            <div class="stats-bar" id="sessionStatsBar">
                <div class="stats-bar-item">Wins: <strong id="statsWins" class="win">0</strong></div>
                <div class="stats-bar-item">Loss: <strong id="statsLosses" class="loss">0</strong></div>
                <div class="stats-bar-item">Part: <strong id="statsPartials" class="partial">0</strong></div>
                <div class="stats-bar-item">Acc: <strong id="statsAccuracy" class="acc">0%</strong></div>
                <div class="stats-bar-item">Rev: <strong id="statsAiRev" class="rev">0%</strong></div>
                <div class="stats-bar-item">Lv: <strong id="statsLevel" class="level">Normal</strong></div>
            </div>
            <div class="tabs">
                <button class="active" onclick="fetchData(1, 'game')"> <i class="fas fa-gamepad"></i><span class="tab-text-long">Game History</span><span class="tab-text-short">Game His.</span></button>
                <button onclick="fetchData(1, 'deep')"> <i class="fas fa-layer-group"></i><span class="tab-text-long">Deep (100)</span><span class="tab-text-short">Deep</span></button>
                <button onclick="fetchData(1, 'chart')"> <i class="fas fa-chart-line"></i><span class="tab-text-long">Chart</span><span class="tab-text-short">Chart</span></button>
                <button onclick="fetchData(1, 'my')"> <i class="fas fa-user-clock"></i><span class="tab-text-long">My History</span><span class="tab-text-short">My His.</span></button>
                <button id="adminDashboardTab" onclick="fetchData(1, 'admin_dashboard')" style="display: none;"> <i class="fas fa-user-shield"></i><span class="tab-text-long">Admin Panel</span><span class="tab-text-short">Admin</span></button>
            </div>
            <div class="my-history-controls" id="myHistoryControls" style="display: none;">
                <label for="entriesPerPage">Show:</label>
                <select id="entriesPerPage" onchange="changeMyHistoryEntriesPerPage(this.value)">
                    <option value="10">10 entries</option>
                    <option value="25">25 entries</option>
                    <option value="50">50 entries</option>
                </select>
            </div>
            <div class="history-header" id="gameHistoryHeader">
            </div>
            <div class="history-header" id="myHistoryHeader"> </div>
            <div id="adminDashboardHeader" style="display: none;"></div>

            <div class="history-content" id="historyContent">
                <div style="text-align: center; padding: 2rem;"> <i class="fas fa-spinner fa-spin fa-lg" style="color: var(--primary);"></i> Loading data... </div>
            </div>
            <div class="pagination" id="paginationControls" style="display:none;">
                <button id="prevPageBtn" onclick="changePage(-1)" disabled><i class="fas fa-chevron-left"></i></button>
                <button id="currentPageBtn" class="active">1</button>
                <button id="nextPageBtn" onclick="changePage(1)"><i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
    </div>

    <div class="floating-notification" id="notification">
        <i class="fas fa-check-circle"></i>
        <span id="notificationText">Notification Text</span>
    </div>

<script>
    // --- Global Variables ---
    let lastCompletedPeriodNumber = null;
    let history = [];
    let cachedData = [];
    let currentPredictionData = {};
    let currentPage = 1;
    let currentTab = 'game';
    let isFetchingPage = false;
    let isWaitingForResult = false;
    let consecutiveLosses = 0;
    let consecutiveWins = 0;
    let sessionStats = { wins: 0, losses: 0, partials: 0 };
    let lastAiReversalChance = 0;
    let currentStrategyLevel = "Normal";
    let lastTimerUpdate = 0;
    const POLLING_INTERVAL = 750;
    const POLLING_TIMEOUT = 15000;
    const fixedSelectedServerName = 'AutoAnalysisEngine';
    let myHistoryItemsPerPage = 10;
    const GAME_HISTORY_ITEMS_PER_PAGE = 10;
    const DEEP_HISTORY_ITEMS_PER_PAGE = 100;
    let isSoundOn = true;

    let loginSelectedPattern = 'bs_num'; // Default pattern, will be updated on login

    // --- Admin & Storage Keys ---
    const ADMIN_ACCESS_KEY = "J0@lroy1991$";
    const KEY_FOR_ONLY_COL = "J0@lroy1991$1234"; // For "Only Color"
    const KEY_FOR_BS_NUM = "Vippredict@9876$";   // For "Big / Small & Number"

    let currentUserRole = null;
    const STORAGE_KEY_USER_ROLE = 'predictVIPKingPro_userRole_v3';
    const STORAGE_KEY_CURRENT_USER_KEY = 'predictVIPKingPro_currentUserKey_v2';
    const STORAGE_KEY_MANAGED_USERS = 'predictVIPKingPro_managedUsers_v3';
    const STORAGE_KEY_THEME = 'predictVIPKingPro_theme_v17';
    const STORAGE_KEY_MY_HISTORY = 'predictVIPKingPro_myHistory_v9'; 
    const STORAGE_KEY_SESSION_STATS = 'predictVIPKingPro_sessionStats_v6';
    const STORAGE_KEY_CONSECUTIVE_WINS = 'predictVIPKingPro_consecutiveWins_v2';
    const STORAGE_KEY_CONSECUTIVE_LOSSES = 'predictVIPKingPro_consecutiveLosses_v2';
    const STORAGE_KEY_MY_HISTORY_ITEMS_PER_PAGE = 'predictVIPKingPro_myHistoryItemsPerPage_v2';
    const STORAGE_KEY_JARVIS_VISIBLE = 'predictVIPKingPro_jarvisCardVisible_v1';
    const STORAGE_KEY_SOUND_ON = 'predictVIPKingPro_soundOn_v1';
    const STORAGE_KEY_LOGIN_PATTERN = 'predictVIPKingPro_loginPattern_v4';

    // --- API Status Function ---
    function setApiStatus() {
        const el = document.getElementById('apiStatus'); if (!el) return;
        const iconEl = el.previousElementSibling;
        el.classList.remove('status-online', 'status-offline', 'status-error');
        let baseStatusText = ''; let statusClass = ''; let colorVar = 'var(--text-secondary)'; let newIconClass = 'fas fa-server';
        if (navigator.onLine) { baseStatusText = 'Online'; statusClass = 'status-online'; colorVar = 'var(--success)'; newIconClass = 'fas fa-signal';}
        else { baseStatusText = 'Offline'; statusClass = 'status-offline'; colorVar = 'var(--danger)'; newIconClass = 'fas fa-times-circle';}
        el.textContent = baseStatusText; if (statusClass) el.classList.add(statusClass); el.style.color = colorVar;
        if (iconEl && iconEl.tagName === 'I') { iconEl.className = newIconClass; }
    }

    // --- Theme Management ---
    let currentTheme = 'dark';
    const themes = {
        dark: {
            '--primary': '#C62828', '--secondary': '#FF8F00', '--success': '#2E7D32', '--danger': '#D32F2F', '--warning': '#F9A825', '--info': '#0277BD', '--violet-accent': '#D84315',
            '--bg-main': '#121212', '--bg-card': '#1E1E1E', '--bg-header-footer': '#0D0D0D', '--bg-interactive': '#2C2C2C', '--bg-hover': '#383838', '--bg-admin-section-mobile': '#252525', '--bg-modal-overlay': 'rgba(0,0,0,0.9)', '--bg-gemini-modal': '#1A1A1A',
            '--text-primary': '#E0E0E0', '--text-secondary': '#B0B0B0', '--text-disabled': '#505050', '--text-on-accent': '#FFFFFF',
            '--text-win': 'var(--success)', '--text-loss': 'var(--danger)', '--text-partial': 'var(--secondary)', '--text-error': 'var(--warning)', '--text-num-red': 'var(--danger)', '--text-num-green': 'var(--success)',
            '--partial-bg': 'rgba(255, 143, 0, 0.15)', '--win-bg': 'rgba(46, 125, 50, 0.15)', '--loss-bg': 'rgba(211, 47, 47, 0.15)', '--error-bg': 'rgba(249, 168, 37, 0.15)',
            '--border-color': '#333333', '--shadow': '0 5px 20px rgba(0, 0, 0, 0.85)', '--tick-color': 'var(--success)', '--cross-color': 'var(--danger)', '--body-bg-gradient-start': '#100000', '--body-bg-gradient-end': '#000000'
        },
        light: {
            '--primary': '#00838F', '--secondary': '#FFC107', '--success': '#4CAF50', '--danger': '#F44336', '--warning': '#FFEB3B', '--info': '#2196F3', '--violet-accent': '#673AB7',
            '--bg-main': '#E0F7FA', '--bg-card': '#FFFFFF', '--bg-header-footer': '#B2EBF2', '--bg-interactive': '#CFD8DC', '--bg-hover': '#B0BEC5', '--bg-admin-section-mobile': '#D7EEF2', '--bg-modal-overlay': 'rgba(0, 77, 64, 0.6)', '--bg-gemini-modal': '#FAFAFA',
            '--text-primary': '#263238', '--text-secondary': '#546E7A', '--text-disabled': '#9E9E9E', '--text-on-accent': '#FFFFFF',
            '--text-win': 'var(--success)', '--text-loss': 'var(--danger)', '--text-partial': 'var(--secondary)', '--text-error': 'var(--warning)', '--text-num-red': 'var(--danger)', '--text-num-green': 'var(--success)',
            '--partial-bg': 'rgba(255, 193, 7, 0.1)', '--win-bg': 'rgba(76, 175, 80, 0.1)', '--loss-bg': 'rgba(244, 67, 54, 0.08)', '--error-bg': 'rgba(255, 235, 59, 0.1)',
            '--border-color': '#90A4AE', '--shadow': '0 3px 10px rgba(0, 0, 0, 0.1)', '--tick-color': 'var(--success)', '--cross-color': 'var(--danger)', '--body-bg-gradient-start': '#A7FFEB', '--body-bg-gradient-end': '#E0F2F1'
        }
    };
    function applyTheme(themeName) {
        const theme = themes[themeName];
        if (!theme) { console.warn(`Theme "${themeName}" not found. Defaulting to "dark".`); applyTheme('dark'); return; }
        document.body.classList.remove('dark-theme', 'light-theme'); document.body.classList.add(themeName + '-theme');
        for (const variable in theme) { if (variable.startsWith('--body-bg-gradient')) continue; document.documentElement.style.setProperty(variable, theme[variable]); }
        document.body.style.background = `linear-gradient(180deg, ${theme['--body-bg-gradient-start']} 0%, ${theme['--body-bg-gradient-end']} 100%)`;
        document.body.style.color = theme['--text-primary']; currentTheme = themeName; robustLocalStorageSetItem(STORAGE_KEY_THEME, themeName);
        const themeToggleIcon = document.querySelector('#themeToggleBtn i');
        if (themeToggleIcon) {
            if (themeName === 'dark') { themeToggleIcon.classList.remove('fa-moon'); themeToggleIcon.classList.add('fa-sun'); if(themeToggleIcon.parentElement) themeToggleIcon.parentElement.title = "Switch to Ocean Breeze (Light)"; }
            else { themeToggleIcon.classList.remove('fa-sun'); themeToggleIcon.classList.add('fa-moon'); if(themeToggleIcon.parentElement) themeToggleIcon.parentElement.title = "Switch to Crimson Night (Dark)"; }
        }
    }
    function toggleTheme() { applyTheme(currentTheme === 'dark' ? 'light' : 'dark'); }

    // --- Local Storage Utilities ---
    function robustJsonParse(key, defaultValue) { try { const val = localStorage.getItem(key); return val === null ? defaultValue : JSON.parse(val) || defaultValue; } catch (e) { return defaultValue; } }
    function robustLocalStorageGetItem(key, defaultValue, isNum = false) { try { const val = localStorage.getItem(key); if (val === null) return defaultValue; if (isNum) { const num = parseInt(val); return isNaN(num) ? defaultValue : num; } return val; } catch (e) { return defaultValue; } }
    function robustLocalStorageSetItem(key, value) { try { localStorage.setItem(key, value); } catch (e) { console.warn("Error setting localStorage:", e); } }
    function saveMyHistoryToStorage() { robustLocalStorageSetItem(STORAGE_KEY_MY_HISTORY, JSON.stringify(history)); }
    function loadMyHistoryFromStorage() { history = robustJsonParse(STORAGE_KEY_MY_HISTORY, []); }
    function saveSessionStateToStorage() { robustLocalStorageSetItem(STORAGE_KEY_SESSION_STATS, JSON.stringify(sessionStats)); robustLocalStorageSetItem(STORAGE_KEY_CONSECUTIVE_WINS, consecutiveWins.toString()); robustLocalStorageSetItem(STORAGE_KEY_CONSECUTIVE_LOSSES, consecutiveLosses.toString()); }
    function loadSessionStateFromStorage() { sessionStats = robustJsonParse(STORAGE_KEY_SESSION_STATS, { wins: 0, losses: 0, partials: 0 }); consecutiveWins = robustLocalStorageGetItem(STORAGE_KEY_CONSECUTIVE_WINS, 0, true); consecutiveLosses = robustLocalStorageGetItem(STORAGE_KEY_CONSECUTIVE_LOSSES, 0, true); }
    function resetSessionStatistics() { sessionStats = { wins: 0, losses: 0, partials: 0 }; consecutiveWins = 0; consecutiveLosses = 0; lastAiReversalChance = 0; currentStrategyLevel = "Normal"; saveSessionStateToStorage(); if (document.getElementById('statsWins')) { updateSessionStatsBar(); updateJarvisCard(); updateNewAlgorithmCard(); } }
    function saveMyHistoryItemsPerPageToStorage() { robustLocalStorageSetItem(STORAGE_KEY_MY_HISTORY_ITEMS_PER_PAGE, myHistoryItemsPerPage.toString()); }
    function loadMyHistoryItemsPerPageFromStorage() { myHistoryItemsPerPage = robustLocalStorageGetItem(STORAGE_KEY_MY_HISTORY_ITEMS_PER_PAGE, 10, true); const selectEl = document.getElementById('entriesPerPage'); if (selectEl) selectEl.value = myHistoryItemsPerPage; }

    function saveLoginPatternToStorage() { robustLocalStorageSetItem(STORAGE_KEY_LOGIN_PATTERN, loginSelectedPattern); }
    function loadLoginPatternFromStorage() {
        const storedPattern = robustLocalStorageGetItem(STORAGE_KEY_LOGIN_PATTERN, 'bs_num'); 
        if (['bs_num', 'only_col'].includes(storedPattern)) {
            loginSelectedPattern = storedPattern;
        } else {
            loginSelectedPattern = 'bs_num';
        }
        const loginPatternSelector = document.getElementById('loginPredictionPattern');
        if (loginPatternSelector) loginPatternSelector.value = loginSelectedPattern;

        updateUserFocusSelectionUI();
    }


    // --- API & Game Data Handling ---
    async function fetchPage(pageNoToFetch, isPriority = false) {
        if (!navigator.onLine) { setApiStatus(); return []; }
        if (isFetchingPage && !isPriority && pageNoToFetch > 1) { return []; }
        isFetchingPage = true;
        try {
            const resp = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", { method: "POST", headers: {"Content-Type": "application/json"}, body: JSON.stringify({ pageSize: 10, pageNo: pageNoToFetch, typeId: 1, language: 0, random: "4a0522c6ecd8410496260e686be2a57c", signature: "334B5E70A0C9B8918B0B15E517E2069C", timestamp: Math.floor(Date.now() / 1000) }) });
            setApiStatus();
            if (!resp.ok) { const errorText = await resp.text(); console.error(`API request failed: ${resp.status} ${resp.statusText} for page ${pageNoToFetch}. Response: ${errorText}`); return []; }
            const data = await resp.json();
            if (data.code === 0 && data.data && Array.isArray(data.data.list)) {
                const fetchedMap = new Map(data.data.list.map(item => [item.issueNumber, item]));
                const cachedMap = new Map(cachedData.map(item => [item.issueNumber, item]));
                const combinedMap = new Map([...cachedMap, ...fetchedMap]);
                cachedData = Array.from(combinedMap.values()).sort((a,b) => parseInt(b.issueNumber||0) - parseInt(a.issueNumber||0)).slice(0, DEEP_HISTORY_ITEMS_PER_PAGE + 20);
                if (isPriority && currentUserRole && (getActiveTab() === 'game' || getActiveTab() === 'deep')) { fetchData(currentPage, getActiveTab(), true); }
                return data.data.list;
            } else { console.error(`API data error (Code: ${data.code}) on page ${pageNoToFetch}:`, data); return []; }
        } catch (e) { console.error("fetchPage critical error:", e); setApiStatus(); return []; }
        finally { isFetchingPage = false; }
    }
    async function fetchOptimizedData(itemsNeeded = DEEP_HISTORY_ITEMS_PER_PAGE) {
        if (cachedData.length < itemsNeeded) {
            const pagesToFetch = Math.max(1, Math.ceil((itemsNeeded - cachedData.length) / 10));
            for (let i = 1; i <= pagesToFetch; i++) { if (cachedData.length >= itemsNeeded + 10) break; await fetchPage(i); }
        }
        return cachedData.slice(0, itemsNeeded);
    }
    function getNumberDetails(numStr) {
        const num = parseInt(numStr, 10);
        if (isNaN(num) || num === null || num < 0 || num > 9) { return { numberVal: '?', bigSmall: '?', colorDisplayHTML: '?', colorForHistory: '?', rawColor: 'Unknown', isViolet: false, numberClass: '', bsClass: '', bsResultClass: '' }; }
        const bigSmall = num >= 5 ? 'Big' : 'Small';
        let colorDisplayHTML = '', colorForHistory = '', rawColor = 'Unknown', isViolet = false, numberClass = '', bsClass = '', bsResultClass = '';
        bsClass = bigSmall === 'Big' ? 'gh-bs-big' : 'gh-bs-small'; bsResultClass = bigSmall === 'Big' ? 'result-bs-big' : 'result-bs-small';
        let colorName = ''; let dotClasses = [];
        if (num === 0) { rawColor = 'Red'; isViolet = true; numberClass = 'gh-num-red'; colorName = 'Red+Violet'; dotClasses.push('color-red', 'color-violet'); }
        else if (num === 5) { rawColor = 'Green'; isViolet = true; numberClass = 'gh-num-green'; colorName = 'Green+Violet'; dotClasses.push('color-green', 'color-violet'); }
        else if ([2,4,6,8].includes(num)) { rawColor = 'Red'; numberClass = 'gh-num-red'; colorName = 'Red'; dotClasses.push('color-red'); }
        else if ([1,3,7,9].includes(num)) { rawColor = 'Green'; numberClass = 'gh-num-green'; colorName = 'Green'; dotClasses.push('color-green'); }
        else { colorName = '?'; }
        let dotsHTML = dotClasses.map(cls => `<span class="color-dot ${cls}"></span>`).join('');
        colorDisplayHTML = `${dotsHTML}${colorName}`; colorForHistory = `${dotsHTML} ${colorName}`;
        return { numberVal: num, bigSmall, colorDisplayHTML, colorForHistory, rawColor, isViolet, numberClass, bsClass, bsResultClass };
    }
    async function fetchGameResult(period) {
        try { let found = cachedData.find(item => item.issueNumber === period); if (found && typeof found.number !== 'undefined' && found.number !== null) { return getNumberDetails(found.number); } await fetchPage(1, true); found = cachedData.find(item => item.issueNumber === period); if (found && typeof found.number !== 'undefined' && found.number !== null) { return getNumberDetails(found.number); } return null; } catch (e) { console.error(`WorkspaceGameResult err for period ${period}:`, e); return null; }
    }

    // --- AI Prediction Engine ---
    function analyzeForTypeInternal(type, gameHistory, gamesToConsider) {
        const recentGames = gameHistory.slice(0, gamesToConsider).filter(item => item && typeof item.number !== 'undefined' && item.number !== null);
        if(recentGames.length === 0) return { trend: null, probability: 0, count: 0, total: 0, streak: 0 };
        let outcomes = [];
        if (type === 'bigsmall') {
            outcomes = recentGames.map(item => getNumberDetails(item.number).bigSmall);
        } else { // Assuming 'redgreen'
            outcomes = recentGames.map(item => getNumberDetails(item.number).rawColor);
        }
        outcomes = outcomes.filter(o => o !== '?' && o !== 'Unknown');
        if (outcomes.length < Math.min(3, gamesToConsider)) return { trend: null, probability: 0, count: 0, total: outcomes.length, streak: 0 };

        const counts = outcomes.reduce((acc, value) => {
            acc[value] = (acc[value] || 0) + 1;
            return acc;
        }, {});

        let trend = null;
        let maxCount = 0;
        for (const outcome in counts) {
            if (counts[outcome] > maxCount) {
                maxCount = counts[outcome];
                trend = outcome;
            } else if (counts[outcome] === maxCount) {
                if(outcomes.length > 0 && outcomes[0] === outcome) trend = outcome;
            }
        }
        const probability = outcomes.length > 0 ? (maxCount / outcomes.length) * 100 : 0;

        let currentStreak = 0;
        if (trend && outcomes.length > 0) {
            for (let i = 0; i < outcomes.length; i++) {
                if (outcomes[i] === trend) currentStreak++;
                else break;
            }
        }
        return { trend, probability: parseFloat(probability.toFixed(1)), count: maxCount, total: outcomes.length, streak: currentStreak };
    }

    function predictNumbersForTrend(trend, type, gameHistory, gamesToConsider = 100) {
        const recentValidGames = gameHistory.filter(item => item && typeof item.number !== 'undefined' && item.number !== null).slice(0, gamesToConsider);
        let candidateNumbers = [];
        for (let item of recentValidGames) {
            const details = getNumberDetails(item.number);
            if (type === 'bigsmall' && details.bigSmall === trend) {
                candidateNumbers.push(details.numberVal);
            } else if (type === 'redgreen' && details.rawColor === trend) {
                candidateNumbers.push(details.numberVal);
            }
        }
        const numCounts = candidateNumbers.reduce((acc, value) => { acc[value] = (acc[value] || 0) + 1; return acc; }, {});
        const sortedNumbers = Object.keys(numCounts).map(num => ({ num: parseInt(num), count: numCounts[num] })).sort((a, b) => b.count - a.count).map(item => item.num);
        let finalNumbers = [...new Set(sortedNumbers)];
        const allMatchingNumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].filter(n => { const d = getNumberDetails(n); return ((type === 'bigsmall' && d.bigSmall === trend) || (type === 'redgreen' && d.rawColor === trend)) && !finalNumbers.includes(n); });
        finalNumbers.push(...allMatchingNumbers);
        finalNumbers = [...new Set(finalNumbers)];
        let fallbackOrder = [];
        if (finalNumbers.length < 3) {
            if (type === 'bigsmall') { fallbackOrder = (trend === 'Big') ? [5,6,7,8,9,0,1,2,3,4] : [0,1,2,3,4,5,6,7,8,9]; }
            else { if (trend === 'Red') { fallbackOrder = [0,2,4,6,8,1,3,5,7,9]; } else { fallbackOrder = [1,3,5,7,9,0,2,4,6,8]; } }
            let fallbackIndex = 0;
            while (finalNumbers.length < 3 && fallbackIndex < fallbackOrder.length) {
                let nextNum = fallbackOrder[fallbackIndex];
                if (!finalNumbers.includes(nextNum)) { finalNumbers.push(nextNum); }
                fallbackIndex++;
            }
        }
        let absoluteFillValue = 0;
        while (finalNumbers.length < 3) {
            let nextNum = absoluteFillValue % 10;
            if (!finalNumbers.includes(nextNum)) { finalNumbers.push(nextNum); }
            absoluteFillValue++;
        }
        return finalNumbers.slice(0, 3);
    }

    async function intelligentPredictionEngine(gameHistoryCache) {
        console.log("[Reversal Debug] intelligentPredictionEngine start. consecutiveLosses:", consecutiveLosses);
        if (!gameHistoryCache || gameHistoryCache.length === 0) {
            console.warn("intelligentPredictionEngine called with empty or invalid gameHistoryCache.");
            const defaultNums = [Math.floor(Math.random()*5), Math.floor(Math.random()*10), Math.floor(Math.random()*10)%5 + 5].sort();
            const defaultDetails = getNumberDetails(defaultNums[0]);
            return { predictedBS: defaultDetails.bigSmall, predictedRawColor: defaultDetails.rawColor, predictedColorHTML: defaultDetails.colorDisplayHTML, predictedNumber: defaultNums[0], predictedNumbersArray: defaultNums, reversalChance: 10, probability: 20, message: "InsufficientData", determinedPredictionType: 'bigsmall' };
        }

        const shortTermGamesToAnalyze = 10;
        const longTermGamesToAnalyzeForNumbers = Math.min(gameHistoryCache.length, 100);
        let applyReverseLogic = false;

        if (consecutiveLosses >= 1) {
            applyReverseLogic = true;
            currentStrategyLevel = `Auto (Rev L${consecutiveLosses} ${consecutiveLosses === 1 ? 'Strong' : 'V.Strong'})`;
        } else {
            currentStrategyLevel = "Auto";
        }
        console.log("[Reversal Debug] applyReverseLogic:", applyReverseLogic, "currentStrategyLevel:", currentStrategyLevel, "consecutiveLosses:", consecutiveLosses);

        const actualShortTermGamesToAnalyze = Math.max(1, Math.min(gameHistoryCache.length, shortTermGamesToAnalyze));
        let bsAnalysis = analyzeForTypeInternal('bigsmall', gameHistoryCache, actualShortTermGamesToAnalyze);
        let rgAnalysis = analyzeForTypeInternal('redgreen', gameHistoryCache, actualShortTermGamesToAnalyze);
        let chosenAnalysis, determinedType, primaryCategoryResult;
        let messageNote = "";
        let reversalChance = 10 + Math.random() * 15;

        if (consecutiveLosses > 2) {
            console.log(`[Reversal Debug] Losses > 2 (${consecutiveLosses}). Forcing Big/Small focus.`);
            messageNote += "(B/S Focus LStreak) ";
            determinedType = 'bigsmall';
            currentStrategyLevel = `Auto (B/S Focus L${consecutiveLosses})`;

            if (applyReverseLogic) {
                let trendToReverseBS = bsAnalysis.trend;
                if (!trendToReverseBS) {
                    const lastGameDetail = gameHistoryCache[0] ? getNumberDetails(gameHistoryCache[0].number) : null;
                    trendToReverseBS = lastGameDetail ? (lastGameDetail.bigSmall === 'Big' ? 'Big' : 'Small') : 'Small';
                    bsAnalysis.trend = trendToReverseBS;
                     bsAnalysis.probability = bsAnalysis.probability || 50;
                    console.log(`[Reversal Debug] No clear B/S trend to reverse for forced B/S focus, selected fallback: ${trendToReverseBS}`);
                }
                primaryCategoryResult = trendToReverseBS === 'Big' ? 'Small' : 'Big';
                messageNote += `(Reversing ${trendToReverseBS} to ${primaryCategoryResult}) `;

                let baseReversedProb = 60 + (Math.min(consecutiveLosses, 5) * 5); // Increased base confidence
                let probabilityImpactReduction = (3 + consecutiveLosses);
                let reversedProbability = baseReversedProb - ((bsAnalysis.probability || 50) / probabilityImpactReduction) + ((bsAnalysis.streak || 0) * 2); // Increased streak impact
                chosenAnalysis = { trend: primaryCategoryResult, probability: parseFloat(Math.min(85, Math.max(50, reversedProbability)).toFixed(1)), count: bsAnalysis.count || 0, total: bsAnalysis.total || actualShortTermGamesToAnalyze, streak: 0 };

                reversalChance = 80 + Math.min(consecutiveLosses - 2, 3) * 5; // Increased reversal chance
                reversalChance = Math.min(95, reversalChance);
            } else {
                primaryCategoryResult = bsAnalysis.trend || 'Small';
                chosenAnalysis = bsAnalysis;
                if (!bsAnalysis.trend) chosenAnalysis = { trend: primaryCategoryResult, probability: 30, count:0, total: actualShortTermGamesToAnalyze, streak:0};
            }
        } else if (applyReverseLogic) {
            console.log(`[Reversal Debug] L${consecutiveLosses} reversal activated.`);
            let trendToReverse, typeToReverse, originalAnalysis;

            if (bsAnalysis.probability > rgAnalysis.probability + 5 || (bsAnalysis.probability > rgAnalysis.probability && bsAnalysis.streak >= rgAnalysis.streak)) { originalAnalysis = bsAnalysis; typeToReverse = 'bigsmall'; }
            else if (rgAnalysis.probability > bsAnalysis.probability + 5 || (rgAnalysis.probability > bsAnalysis.probability && rgAnalysis.streak >= bsAnalysis.streak)) { originalAnalysis = rgAnalysis; typeToReverse = 'redgreen'; }
            else { originalAnalysis = (bsAnalysis.total >= rgAnalysis.total) ? bsAnalysis : rgAnalysis; typeToReverse = (bsAnalysis.total >= rgAnalysis.total) ? 'bigsmall' : 'redgreen'; }

            trendToReverse = originalAnalysis.trend;
            if (!trendToReverse) {
                typeToReverse = (bsAnalysis.total >= rgAnalysis.total && bsAnalysis.trend) ? 'bigsmall' : 'redgreen';
                const lastGameDetail = gameHistoryCache[0] ? getNumberDetails(gameHistoryCache[0].number) : null;
                trendToReverse = typeToReverse === 'bigsmall' ? (lastGameDetail ? (lastGameDetail.bigSmall === 'Big' ? 'Big' : 'Small') : 'Small') : (lastGameDetail ? lastGameDetail.rawColor : 'Green');
                if(trendToReverse === 'Unknown' || trendToReverse === '?') trendToReverse = typeToReverse === 'bigsmall' ? 'Small' : 'Green';
                originalAnalysis = { probability: 50, streak: 0, total: actualShortTermGamesToAnalyze, trend: trendToReverse};
                console.log(`[Reversal Debug] No clear trend to reverse, selected fallback: ${trendToReverse} for ${typeToReverse}`);
            }

            determinedType = typeToReverse;
            primaryCategoryResult = (determinedType === 'bigsmall') ? (trendToReverse === 'Big' ? 'Small' : 'Big') : (trendToReverse === 'Red' ? 'Green' : 'Red');

            let baseReversedProb = 60 + (Math.min(consecutiveLosses, 3) * 6); // Increased base
            let probabilityImpactReduction = (4 + consecutiveLosses);
            let reversedProbability = baseReversedProb - (originalAnalysis.probability / probabilityImpactReduction) + (originalAnalysis.streak * 2); // Increased streak impact
            chosenAnalysis = { trend: primaryCategoryResult, probability: parseFloat(Math.min(85, Math.max(50, reversedProbability)).toFixed(1)), count: originalAnalysis.count || 0, total: originalAnalysis.total || actualShortTermGamesToAnalyze, streak: 0 };

            reversalChance = 75 + Math.min(consecutiveLosses, 3) * 8; // Increased chance
            reversalChance = Math.min(95, reversalChance); // Higher cap

            messageNote = `(Reversing L${consecutiveLosses} from ${trendToReverse})`;
            console.log(`[Reversal Debug] Original Trend: ${trendToReverse}, Reversed to: ${primaryCategoryResult}. ReversedProb: ${chosenAnalysis.probability}%, ReversalChance: ${reversalChance}%`);

        } else {
            if (bsAnalysis.trend && rgAnalysis.trend) {
                if (bsAnalysis.streak > rgAnalysis.streak + 1 && bsAnalysis.probability > 55) { chosenAnalysis = bsAnalysis; determinedType = 'bigsmall'; messageNote = `(Strong B/S Strk ${bsAnalysis.streak})`; }
                else if (rgAnalysis.streak > bsAnalysis.streak + 1 && rgAnalysis.probability > 55) { chosenAnalysis = rgAnalysis; determinedType = 'redgreen'; messageNote = `(Strong R/G Strk ${rgAnalysis.streak})`; }
                else if (Math.abs(bsAnalysis.probability - rgAnalysis.probability) > 12) { chosenAnalysis = bsAnalysis.probability > rgAnalysis.probability ? bsAnalysis : rgAnalysis; determinedType = bsAnalysis.probability > rgAnalysis.probability ? 'bigsmall' : 'redgreen'; }
                else { chosenAnalysis = bsAnalysis.probability >= rgAnalysis.probability ? bsAnalysis : rgAnalysis; determinedType = bsAnalysis.probability >= rgAnalysis.probability ? 'bigsmall' : 'redgreen'; messageNote = "(Trend Mixed)"; }
                primaryCategoryResult = chosenAnalysis.trend;
            } else if (bsAnalysis.trend) { chosenAnalysis = bsAnalysis; determinedType = 'bigsmall'; primaryCategoryResult = bsAnalysis.trend; }
            else if (rgAnalysis.trend) { chosenAnalysis = rgAnalysis; determinedType = 'redgreen'; primaryCategoryResult = rgAnalysis.trend; }
            else { determinedType = 'bigsmall'; primaryCategoryResult = 'Small'; chosenAnalysis = { probability: 20, total: actualShortTermGamesToAnalyze, streak:0, trend: primaryCategoryResult }; messageNote = "(NoClearTrend/LowData)"; }

            if (chosenAnalysis.streak >= 3) { reversalChance = 50 + (chosenAnalysis.streak - 2) * 8; }
            else if (chosenAnalysis.streak === 2) { reversalChance = 30 + Math.random() * 15; }
            if (reversalChance > 80) reversalChance = 80;
        }

        if (!primaryCategoryResult || !determinedType) {
            console.warn("Primary category or type not determined, using fallback prediction.");
            primaryCategoryResult = 'Small'; determinedType = 'bigsmall';
            chosenAnalysis = { probability: 10, ...(chosenAnalysis || {}), trend: primaryCategoryResult };
            messageNote += " (FallbackUsed)";
        }
        const predictedNumbersArray = predictNumbersForTrend(primaryCategoryResult, determinedType, gameHistoryCache, longTermGamesToAnalyzeForNumbers);
        const predictedNumber = predictedNumbersArray[0];
        const numDetails = getNumberDetails(predictedNumber);

        let finalPredictedBS = numDetails.bigSmall;
        let finalPredictedRawColor = numDetails.rawColor;
        let displayableColorHTML = numDetails.colorDisplayHTML;

        let finalMessage = currentStrategyLevel;
        if (messageNote.trim() !== "") {
            finalMessage += ` ${messageNote.trim()}`;
        }
        if (finalMessage.trim() === "Auto") finalMessage = "Auto (Stable)";

        return {
            predictedBS: finalPredictedBS || '?',
            predictedRawColor: finalPredictedRawColor || '?',
            predictedColorHTML: displayableColorHTML || '?',
            predictedNumber: predictedNumber !== undefined ? predictedNumber : '?',
            predictedNumbersArray: predictedNumbersArray.length === 3 ? predictedNumbersArray : [0,1,2],
            reversalChance: parseFloat(reversalChance.toFixed(1)),
            probability: parseFloat((chosenAnalysis.probability || 0).toFixed(1)),
            message: finalMessage.trim().replace(/\(\)/g, '').replace(/\s\s+/g, ' '),
            determinedPredictionType: determinedType || 'bigsmall'
        };
    }

    async function generateAndStorePrediction(period) {
        const currentResultEl = document.getElementById('currentResult');
        if(currentResultEl) currentResultEl.innerHTML = '<i class="fas fa-cog fa-spin fa-lg" style="color: var(--primary);"></i> AI thinking...';
        let predictionInputData;
        try {
            const startTime = Date.now();
            if (cachedData.length < 3 && navigator.onLine) { await fetchOptimizedData(3); }
            if(cachedData.length === 0 && !navigator.onLine){ if(currentResultEl) currentResultEl.innerHTML = '<i class="fas fa-wifi-slash"></i> Offline. Waiting for data...'; return; }

            const enginePrediction = await intelligentPredictionEngine(cachedData);
            predictionInputData = {
                period,
                predictionFocus: loginSelectedPattern,
                predictedBS: enginePrediction.predictedBS,
                predictedRawColor: enginePrediction.predictedRawColor,
                predictedColorHTML: enginePrediction.predictedColorHTML,
                predictedNumber: enginePrediction.predictedNumber,
                predictedNumbersArray: enginePrediction.predictedNumbersArray,
                reversalChance: enginePrediction.reversalChance,
                probability: enginePrediction.probability,
                message: enginePrediction.message,
                resultType: enginePrediction.determinedPredictionType || 'auto',
                server: fixedSelectedServerName
            };
            lastAiReversalChance = enginePrediction.reversalChance || 0;
            const elapsed = Date.now() - startTime;
            await new Promise(resolve => setTimeout(resolve, Math.max(0, 250 - elapsed)));

            const prob = predictionInputData.probability || 0; const revChance = predictionInputData.reversalChance || 0; const msg = predictionInputData.message || "?"; const nums = predictionInputData.predictedNumbersArray || ['?'];
            const bsPart = `<span class="prediction-output-item p-bs"><span class="prediction-output-label">B/S:</span><span class="prediction-output-value">${predictionInputData.predictedBS || '?'}</span></span>`;
            const colorPart = `<span class="prediction-output-item p-color"><span class="prediction-output-label">Color:</span><span class="prediction-output-value">${predictionInputData.predictedColorHTML || '?'}</span></span>`;
            const numsPart = `<span class="prediction-output-item p-nums"><span class="prediction-output-label">Nums:</span><span class="prediction-output-value">${nums.join(', ')}</span></span>`;
            const percentPart = `<span class="prediction-output-item p-perc"><span class="prediction-output-label">Per:</span><span class="prediction-output-value">(${prob > 0 ? prob.toFixed(1) : 'N/A'}%)</span></span>`;
            const revPart = `<span class="prediction-output-item p-rev"><span class="prediction-output-label">Rev:</span><span class="prediction-output-value">(${revChance > 0 ? revChance.toFixed(1) : 'N/A'}%)</span></span>`;
            const strategyPart = `<span class="prediction-output-item p-strat"><span class="prediction-output-label">Stgy:</span><span class="prediction-output-value" title="${msg}">${msg}</span></span>`;

            let displayHTML = '';
            if (loginSelectedPattern === 'bs_num') {
                displayHTML = `${bsPart} ${numsPart} ${percentPart} ${revPart} ${strategyPart}`;
            } else if (loginSelectedPattern === 'only_col') {
                displayHTML = `${colorPart} ${percentPart} ${revPart} ${strategyPart}`;
            } else {
                displayHTML = `${bsPart} ${colorPart} ${numsPart} ${percentPart} ${revPart} ${strategyPart}`;
            }


            if(currentResultEl) currentResultEl.innerHTML = displayHTML;
            currentPredictionData[period] = predictionInputData;

            let notificationFocusText = "Unknown Pattern";
            if(loginSelectedPattern === 'bs_num') notificationFocusText = "Big/Small & Number";
            else if (loginSelectedPattern === 'only_col') notificationFocusText = "Only Color";

            showNotification(`Prediction for ${period} (Focus: ${notificationFocusText}): B/S: ${predictionInputData.predictedBS}, Color: ${predictionInputData.predictedRawColor}, Nums: ${nums.join(',')}`, 'info');
            speakPrediction(predictionInputData);
            updateSessionStatsBar();
            updateNewAlgorithmCard();
        } catch (error) {
            console.error("generateAndStorePrediction error:", error.message, error.stack);
            if(currentResultEl) currentResultEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Prediction Error: ${error.message}`;
            showNotification(`Prediction generation failed: ${error.message}`, 'error');
            currentPredictionData[period] = { period, error: true, message: `Generation Failed: ${error.message}`, predictionFocus: loginSelectedPattern };
            lastAiReversalChance = 0; updateSessionStatsBar();
        }
    }


    // --- Sound & UI Feedback ---
    function speak(text, lang = 'en-US') { if (!isSoundOn) return; if ('speechSynthesis' in window) { try { window.speechSynthesis.cancel(); const utterance = new SpeechSynthesisUtterance(text); utterance.lang = lang; utterance.rate = 1.0; utterance.pitch = 1.0; window.speechSynthesis.speak(utterance); } catch (e) { console.error("Speech Synthesis error:", e); } } else { console.warn("Speech Synthesis not supported by this browser."); } }
    function speakPrediction(predictionData) { if (!predictionData) return; let confidenceMsg = "Normal"; if (predictionData.message && predictionData.message.includes("Rev")) { confidenceMsg = "Reversal Active"; } else if (predictionData.probability > 75) { confidenceMsg = "High Confidence"; } else if (predictionData.probability > 60) { confidenceMsg = "Medium Confidence"; } else { confidenceMsg = "Low Confidence"; } const nums = predictionData.predictedNumbersArray || []; const speakText = `Prediction: ${predictionData.predictedBS}. ${predictionData.predictedRawColor}. Numbers: ${nums.join(', ')}. Status: ${confidenceMsg}.`; speak(speakText); }

    // --- Jarvis AI & Session Stats ---
    function calculateJarvisStats() {
        const getStatsForLimit = (limit) => { const relevantHistory = history.filter(h => h.status && (h.status === 'Win' || h.status === 'Loss' || h.status === 'Partial')).slice(0, limit); if (relevantHistory.length === 0) return { rate: '0.0', wins: 0, losses: 0, partials: 0, actualCount: 0 }; const wins = relevantHistory.filter(h => h.status === 'Win').length; const losses = relevantHistory.filter(h => h.status === 'Loss').length; const partials = relevantHistory.filter(h => h.status === 'Partial').length; const totalConsidered = wins + losses + partials; const rate = totalConsidered > 0 ? ((wins / totalConsidered) * 100).toFixed(1) : '0.0'; return { rate, wins, losses, partials, actualCount: relevantHistory.length }; }; const l10 = getStatsForLimit(10); const l20 = getStatsForLimit(20); const l30 = getStatsForLimit(30); const l50 = getStatsForLimit(50); let overallAssessment = "Low"; const overallRateNum = parseFloat(l50.rate) || parseFloat(l30.rate) || parseFloat(l20.rate) || parseFloat(l10.rate) || 0; if (overallRateNum >= 75) overallAssessment = "Excellent"; else if (overallRateNum >= 60) overallAssessment = "Good"; else if (overallRateNum >= 45) overallAssessment = "Average"; let l10LossStreak = 0; const last10Actual = history.filter(h => h.status && (h.status === 'Win' || h.status === 'Loss' || h.status === 'Partial')).slice(0, 10); for (let i = 0; i < last10Actual.length; i++) { if (last10Actual[i].status === 'Loss') { l10LossStreak++; } else { break; } } let l10StreakAlert = null; if (l10LossStreak >= 3) { l10StreakAlert = `L10 Streak: ${l10LossStreak} Losses! Play Cautiously!`; } let l50PerformanceAlert = null; if (l50.actualCount >= 20 && parseFloat(l50.rate) < 40) { l50PerformanceAlert = `L50 Performance: Low (${l50.rate}%) - High Risk!`; } else if (l50.actualCount >= 20 && parseFloat(l50.rate) < 50 && parseFloat(l50.rate) >= 40 ) { l50PerformanceAlert = `L50 Performance: Average (${l50.rate}%) - Consider Strategy.`; } return { l10, l20, l30, l50, overallAssessment, l10StreakAlert, l50PerformanceAlert };
    }
    function updateJarvisCard() {
        if(!document.getElementById('jarvisL10Rate')) return; const stats = calculateJarvisStats(); document.getElementById('jarvisL10Rate').textContent = `${stats.l10.rate}%`; document.getElementById('jarvisL10Details').textContent = `(${stats.l10.wins}W/${stats.l10.losses}L/${stats.l10.partials}P)`; document.getElementById('jarvisL20Rate').textContent = `${stats.l20.rate}%`; document.getElementById('jarvisL20Details').textContent = `(${stats.l20.wins}W/${stats.l20.losses}L/${stats.l20.partials}P)`; document.getElementById('jarvisL30Rate').textContent = `${stats.l30.rate}%`; document.getElementById('jarvisL30Details').textContent = `(${stats.l30.wins}W/${stats.l30.losses}L/${stats.l30.partials}P)`; document.getElementById('jarvisL50Rate').textContent = `${stats.l50.rate}%`; document.getElementById('jarvisL50Details').textContent = `(${stats.l50.wins}W/${stats.l50.losses}L/${stats.l50.partials}P)`; const jarvisOverallEl = document.getElementById('jarvisOverall'); if(jarvisOverallEl) { jarvisOverallEl.textContent = stats.overallAssessment; if (stats.overallAssessment === "Excellent") jarvisOverallEl.style.color = 'var(--success)'; else if (stats.overallAssessment === "Good") jarvisOverallEl.style.color = 'var(--primary)'; else if (stats.overallAssessment === "Average") jarvisOverallEl.style.color = 'var(--warning)'; else jarvisOverallEl.style.color = 'var(--danger)'; } const alertsContainer = document.getElementById('jarvisAlertsContainer'); alertsContainer.innerHTML = ''; if (stats.l10StreakAlert) { const alertDiv = document.createElement('div'); alertDiv.className = 'jarvis-alert danger'; alertDiv.innerHTML = `<i class="fas fa-triangle-exclamation"></i> ${stats.l10StreakAlert}`; alertsContainer.appendChild(alertDiv); } if (stats.l50PerformanceAlert) { const alertDiv = document.createElement('div'); alertDiv.className = `jarvis-alert ${parseFloat(stats.l50.rate) < 40 ? 'danger' : 'warning'}`; alertDiv.innerHTML = `<i class="fas fa-triangle-exclamation"></i> ${stats.l50PerformanceAlert}`; alertsContainer.appendChild(alertDiv); }
    }
    
    // --- New Algorithm Calculation ---
    function updateNewAlgorithmCard() {
        const colorSection = document.getElementById('algoColorSection');
        const numberSection = document.getElementById('algoNumberSection');

        if (!colorSection || !numberSection || !cachedData || cachedData.length < 10) {
            if (colorSection) {
                colorSection.querySelector('#algoColorLogic').textContent = "Waiting for 10+ results...";
                colorSection.querySelector('#algoColorSuggestion span').textContent = "N/A";
            }
            if (numberSection) {
                numberSection.querySelector('#algoNumberLogic').textContent = "";
                numberSection.querySelector('#algoNumberSuggestion span').textContent = "N/A";
            }
            return;
        }

        const colorLogicEl = colorSection.querySelector('#algoColorLogic');
        const colorSuggestionEl = colorSection.querySelector('#algoColorSuggestion span');
        const numberLogicEl = numberSection.querySelector('#algoNumberLogic');
        const numberSuggestionEl = numberSection.querySelector('#algoNumberSuggestion span');

        const lastTenResults = cachedData.slice(0, 10).map(item => getNumberDetails(item.number));

        // Color Calculation
        let redCount = 0;
        let greenCount = 0;
        lastTenResults.forEach(details => {
            if (details.rawColor === 'Red') redCount++;
            if (details.rawColor === 'Green') greenCount++;
        });

        colorLogicEl.innerHTML = `Analysis: <strong style="color:var(--danger);">Red: ${redCount}</strong> | <strong style="color:var(--success);">Green: ${greenCount}</strong>`;

        let colorSuggestion = '';
        if (redCount > greenCount) {
            colorSuggestion = '<span style="color:var(--danger); font-weight:bold;">RED</span> is dominant.';
        } else if (greenCount > redCount) {
            colorSuggestion = '<span style="color:var(--success); font-weight:bold;">GREEN</span> is dominant.';
        } else {
            const latestColor = lastTenResults[0].rawColor;
            const latestColorName = latestColor === '?' ? 'Unknown' : latestColor;
            const colorStyle = (latestColorName === 'Red') ? 'var(--danger)' : 'var(--success)';
            colorSuggestion = `Balanced. Latest was <strong style="color:${colorStyle};">${latestColorName}</strong>.`;
        }
        colorSuggestionEl.innerHTML = colorSuggestion;

        // Number Calculation
        const numberFrequency = {};
        lastTenResults.forEach(details => {
            if(details.numberVal !== '?') {
                 numberFrequency[details.numberVal] = (numberFrequency[details.numberVal] || 0) + 1;
            }
        });

        const sortedNumbers = Object.entries(numberFrequency)
            .sort((a, b) => b[1] - a[1]);

        if (sortedNumbers.length > 0) {
            numberLogicEl.textContent = `Frequency: ${sortedNumbers.map(([num, count]) => `${num}(${count})`).join(', ')}.`;
            const hotNumbers = sortedNumbers.slice(0, 3).map(([num]) => num).join(', ');
            numberSuggestionEl.innerHTML = `Hot Numbers: <strong style="color:var(--primary);">${hotNumbers}</strong>`;
        } else {
             numberLogicEl.textContent = "Could not calculate frequency.";
             numberSuggestionEl.textContent = "N/A";
        }
    }


    function toggleJarvisCardVisibility(show, save = true) {
        const content = document.getElementById('jarvisAnalyticsContent'); const icon = document.querySelector('#toggleJarvisCard i'); if (!content || !icon) return; if (show) { content.style.display = 'block'; icon.classList.remove('fa-eye-slash'); icon.classList.add('fa-eye'); if(save) robustLocalStorageSetItem(STORAGE_KEY_JARVIS_VISIBLE, 'true'); } else { content.style.display = 'none'; icon.classList.remove('fa-eye'); icon.classList.add('fa-eye-slash'); if(save) robustLocalStorageSetItem(STORAGE_KEY_JARVIS_VISIBLE, 'false'); }
    }
    function updateAccuracyDisplay() { if (currentUserRole) { updateSessionStatsBar(); updateJarvisCard(); updateNewAlgorithmCard(); } }
    function updateSessionStatsBar() {
        const statsWinsEl = document.getElementById('statsWins'); const statsLossesEl = document.getElementById('statsLosses'); const statsPartialsEl = document.getElementById('statsPartials'); const statsAccuracyEl = document.getElementById('statsAccuracy'); const statsAiRevEl = document.getElementById('statsAiRev'); const statsLevelEl = document.getElementById('statsLevel'); if (!statsWinsEl || !statsLossesEl || !statsPartialsEl || !statsAccuracyEl || !statsAiRevEl || !statsLevelEl) { return; } statsWinsEl.textContent = sessionStats.wins; statsLossesEl.textContent = sessionStats.losses; statsPartialsEl.textContent = sessionStats.partials || 0; const totalCompleted = sessionStats.wins + sessionStats.losses + (sessionStats.partials || 0); let accuracyText = "0%"; if (totalCompleted > 0) { const accuracy = Math.round((sessionStats.wins / totalCompleted) * 100); accuracyText = `${isNaN(accuracy) ? '0' : accuracy}%`; } statsAccuracyEl.textContent = accuracyText; statsAiRevEl.textContent = `${lastAiReversalChance.toFixed(1)}%`; let levelText = currentStrategyLevel; const lvMatch = currentStrategyLevel.match(/(?:Martingale L|Anti-Martingale L|Auto \(Rev L|Auto \(L|Auto \(B\/S Focus L)(\d+)\)?/i); if (lvMatch && lvMatch[1]) { levelText = `Lv${lvMatch[1]}`; } else if (currentStrategyLevel === "Auto" && consecutiveWins > 0 && !currentStrategyLevel.includes("Rev") ) { levelText = `Auto (W${consecutiveWins})`; } statsLevelEl.textContent = levelText;
    }
    async function finalizeAndRecordResult(periodToFinalize) {
        console.log(`[Reversal Debug] finalizeAndRecordResult for period ${periodToFinalize}. Current consecutiveLosses before update: ${consecutiveLosses}`);
        if (isWaitingForResult) return; isWaitingForResult = true;
        const predictionData = currentPredictionData[periodToFinalize];

        if (!predictionData || predictionData.error) {
            if (predictionData?.error) {
                const errorEntry = { period: periodToFinalize, predictionFocus: predictionData.predictionFocus || loginSelectedPattern, predictedBS: '?', predictedRawColor: '?', predictedColorHTML: '?', predictedNumber: '?', predictedNumbersArray: ['?'], actualNum: '?', actualBS: '?', actualRawColor: '?', actualColorForHistory: 'Prediction Error', status: 'Error', bsWin: false, colorWin: false, numWin: false, resultType: '?', server: fixedSelectedServerName, probability: 0 };
                history.unshift(errorEntry); saveMyHistoryToStorage();
                if (getActiveTab() === 'my' && currentUserRole) fetchData(1, 'my', true);
                updateAccuracyDisplay(); delete currentPredictionData[periodToFinalize];
            }
            isWaitingForResult = false; return;
        }

        let gameOutcome = null; const startTime = Date.now();
        while (Date.now() - startTime < POLLING_TIMEOUT) { gameOutcome = await fetchGameResult(periodToFinalize); if (gameOutcome) break; await new Promise(resolve => setTimeout(resolve, POLLING_INTERVAL)); }

        let historyEntry;
        if (gameOutcome) {
            const actualNum = gameOutcome.numberVal; const actualBS = gameOutcome.bigSmall; const actualRawColor = gameOutcome.rawColor;
            const bsWin = predictionData.predictedBS === actualBS;
            const colorWin = predictionData.predictedRawColor === actualRawColor;
            const numWin = predictionData.predictedNumbersArray && predictionData.predictedNumbersArray.includes(actualNum);

            let status = "Loss"; // Default status
            const focusForThisPrediction = predictionData.predictionFocus;

            let currentConsecutiveWins = consecutiveWins;
            let currentConsecutiveLosses = consecutiveLosses;

            if (focusForThisPrediction === 'bs_num') {
                if (bsWin && numWin) {
                    status = "Win";
                    sessionStats.wins++;
                    currentConsecutiveLosses = 0;
                    currentConsecutiveWins++;
                } else if (bsWin || numWin) {
                    status = "Partial";
                    if(!sessionStats.partials) sessionStats.partials = 0;
                    sessionStats.partials++;
                    currentConsecutiveWins = 0;
                    currentConsecutiveLosses = 0;
                } else {
                    status = "Loss";
                    sessionStats.losses++;
                    currentConsecutiveWins = 0;
                    currentConsecutiveLosses++;
                }
            } else if (focusForThisPrediction === 'only_col') {
                if (colorWin) {
                    status = "Win";
                    sessionStats.wins++;
                    currentConsecutiveLosses = 0;
                    currentConsecutiveWins++;
                } else {
                    status = "Loss";
                    sessionStats.losses++;
                    currentConsecutiveWins = 0;
                    currentConsecutiveLosses++;
                }
            } else {
                status = "Loss";
                sessionStats.losses++;
                currentConsecutiveWins = 0;
                currentConsecutiveLosses++;
                console.warn("Unrecognized predictionFocus in finalizeAndRecordResult:", focusForThisPrediction);
            }
            consecutiveWins = currentConsecutiveWins;
            consecutiveLosses = currentConsecutiveLosses;
            console.log(`[Reversal Debug] After update for period ${periodToFinalize}: consecutiveLosses = ${consecutiveLosses}, status = ${status}`);

            saveSessionStateToStorage();
            historyEntry = {
                period: periodToFinalize,
                predictionFocus: focusForThisPrediction,
                predictedBS: predictionData.predictedBS,
                predictedRawColor: predictionData.predictedRawColor,
                predictedColorHTML: predictionData.predictedColorHTML,
                predictedNumber: predictionData.predictedNumber,
                predictedNumbersArray: predictionData.predictedNumbersArray,
                actualNum, actualBS, actualRawColor,
                actualColorForHistory: gameOutcome.colorForHistory,
                status, bsWin, colorWin, numWin,
                resultType: predictionData.resultType,
                server: predictionData.server,
                probability: predictionData.probability
            };
            if (numWin && status === "Win") { const cheerMessages = ["Excellent! Number prediction hit!", "Fantastic! You got the number!", "Great call on the number! Jackpot!"]; speak(cheerMessages[Math.floor(Math.random() * cheerMessages.length)]); }
        } else {
            console.warn(`Result for period ${periodToFinalize} timed out.`);
            historyEntry = { period: periodToFinalize, predictionFocus: predictionData.predictionFocus || loginSelectedPattern, predictedBS: predictionData.predictedBS, predictedRawColor: predictionData.predictedRawColor, predictedColorHTML: predictionData.predictedColorHTML, predictedNumber: predictionData.predictedNumber, predictedNumbersArray: predictionData.predictedNumbersArray, actualNum: '?', actualBS: '?', actualRawColor: '?', actualColorForHistory: 'Result N/A', status: 'Error', bsWin: false, colorWin: false, numWin: false, resultType: predictionData.resultType, server: predictionData.server, probability: predictionData.probability };
            consecutiveLosses = 0; consecutiveWins = 0; saveSessionStateToStorage();
            showNotification(`Result for ${periodToFinalize} unavailable.`, 'error');
        }
        history.unshift(historyEntry); if(history.length > 200) history.splice(200); saveMyHistoryToStorage();
        delete currentPredictionData[periodToFinalize]; updateAccuracyDisplay();
        if (getActiveTab() === 'my' && currentUserRole) fetchData(1, 'my', true);
        isWaitingForResult = false;
    }


    // --- Main Loop & Tab/UI Management ---
    function updatePeriodAndTimer() {
        try { if (!currentUserRole) return; if (currentUserRole === 'user' && !loginSelectedPattern) { return; } if (currentUserRole === 'user') { const storedUserKey = robustLocalStorageGetItem(STORAGE_KEY_CURRENT_USER_KEY, null); if (storedUserKey) { const managedUsers = getManagedUsers(); const currentUserObject = managedUsers.find(u => u.accessKey === storedUserKey); if (currentUserObject) { if (currentUserObject.isBanned) { showNotification("Your access has been revoked (banned). Logging out.", "error"); handleLogout(); return; } if (currentUserObject.expiresAt && Date.now() > currentUserObject.expiresAt) { showNotification("Your session has expired. Please login again.", "error"); handleLogout(); return; } } else { if (storedUserKey !== KEY_FOR_BS_NUM && storedUserKey !== KEY_FOR_ONLY_COL) { showNotification("Your access key is no longer valid. Logging out.", "error"); handleLogout(); return; } } } else { console.warn("User role active but no key stored. Forcing logout."); handleLogout(); return; } } const now = new Date(), ct = now.getTime(); if (ct - lastTimerUpdate < 980) return; lastTimerUpdate = ct; const y = now.getUTCFullYear(), m = String(now.getUTCMonth() + 1).padStart(2, '0'), d = String(now.getUTCDate()).padStart(2, '0'); const hrs = now.getUTCHours(), mins = now.getUTCMinutes(), secsValue = now.getUTCSeconds(); const totMins = hrs * 60 + mins; const periodSuffix = 10001 + totMins; const currentPeriod = `${y}${m}${d}1000${periodSuffix}`; const secsRemaining = 60 - secsValue; const periodJustCompleted = lastCompletedPeriodNumber; if (currentPeriod !== lastCompletedPeriodNumber) { if (periodJustCompleted && currentPredictionData[periodJustCompleted]) { finalizeAndRecordResult(periodJustCompleted).catch(e => { console.error("Error in finalizeAndRecordResult:", e); isWaitingForResult = false; }); } lastCompletedPeriodNumber = currentPeriod; const periodEl = document.getElementById('period'); if (periodEl) periodEl.textContent = `${currentPeriod || 'N/A'}`; generateAndStorePrediction(currentPeriod).catch(e => { console.error("Error in generateAndStorePrediction:", e); }); fetchPage(1, true).then(() => { if (getActiveTab() === 'game' || getActiveTab() === 'deep') { fetchData(1, getActiveTab(), true); } updateNewAlgorithmCard(); }).catch(e => console.error("Error fetching page 1 on new period:", e)); } const timerEl = document.getElementById('timer'); if (timerEl) timerEl.textContent = `${String(secsRemaining).padStart(2, '0')}s`; const statusEl = document.getElementById('status'); if (statusEl) statusEl.textContent = secsRemaining < 10 ? 'Closing' : 'Active'; } catch (e) { console.error("Critical error in updatePeriodAndTimer, attempting to prevent stop:", e); }
    }
    function getActiveTab() {
        const activeButton = document.querySelector('.tabs button.active'); if (activeButton) { const onclickAttr = activeButton.getAttribute('onclick'); if (onclickAttr?.includes("'game'")) return 'game'; if (onclickAttr?.includes("'deep'")) return 'deep'; if (onclickAttr?.includes("'my'")) return 'my'; if (onclickAttr?.includes("'chart'")) return 'chart'; if (onclickAttr?.includes("'admin_dashboard'")) return 'admin_dashboard'; } return currentTab;
    }

    async function fetchData(page, tab = currentTab, forceRender = false) {
        if (!currentUserRole) { document.getElementById('historyContent').innerHTML = '<p style="text-align:center; padding:1rem; color:var(--warning);">Please login to view data.</p>'; return; }
        const contentEl = document.getElementById('historyContent'); if (!contentEl) return;
        const myHistoryControlsEl = document.getElementById('myHistoryControls'); if (myHistoryControlsEl) { myHistoryControlsEl.style.display = (tab === 'my') ? 'flex' : 'none'; }
        if (!forceRender && currentPage === page && currentTab === tab && contentEl.innerHTML !== '' && !contentEl.innerHTML.includes('Loading ')) { if (tab === 'game' || tab === 'deep') { /* Allow refresh */ } else { return; } }

        const localCallTab = tab;
        if (localCallTab !== 'my') { currentPage = 1; } else { currentPage = page; }
        currentTab = tab;
        contentEl.innerHTML = `<div style="text-align: center; padding: 2rem;"><i class="fas fa-spinner fa-spin fa-lg" style="color: var(--primary);"></i> Loading ${localCallTab}...</div>`;
        document.querySelectorAll('.tabs button').forEach(btn => btn.classList.remove('active'));
        const activeTabButton = document.querySelector(`.tabs button[onclick*="'${localCallTab}'"]`); if(activeTabButton) activeTabButton.classList.add('active');

        const gameHead = document.getElementById('gameHistoryHeader'); const myHead = document.getElementById('myHistoryHeader'); const adminHead = document.getElementById('adminDashboardHeader');
        if (gameHead) gameHead.style.display = (localCallTab === 'game' || localCallTab === 'deep') ? 'grid' : 'none';
        if (myHead) myHead.style.display = (localCallTab === 'my') ? 'grid' : 'none';
        if (adminHead) adminHead.style.display = 'none';

        const paginationEl = document.getElementById('paginationControls');
        if (paginationEl) {
            if (localCallTab === 'my') { paginationEl.style.display = 'flex'; document.getElementById('prevPageBtn').disabled = (currentPage <= 1); document.getElementById('currentPageBtn').textContent = currentPage; }
            else { paginationEl.style.display = 'none'; }
        }

        if (localCallTab === 'my') { if (myHistoryItemsPerPage == 10) contentEl.style.maxHeight = '200px'; else if (myHistoryItemsPerPage == 25) contentEl.style.maxHeight = '480px'; else if (myHistoryItemsPerPage == 50) contentEl.style.maxHeight = '920px'; else contentEl.style.maxHeight = 'none'; }
        else if (localCallTab === 'game') { contentEl.style.maxHeight = '200px'; }
        else if (localCallTab === 'deep') { contentEl.style.maxHeight = '400px'; }
        else if (localCallTab === 'admin_dashboard') { contentEl.style.maxHeight = 'none'; }
        else { contentEl.style.maxHeight = '300px'; }

        try {
            if (localCallTab === 'game' || localCallTab === 'deep') {
                if (currentTab !== localCallTab) return;
                contentEl.innerHTML = '';
                if (gameHead) { gameHead.innerHTML = `<div class="history-header-item">Period</div><div class="history-header-item">Num</div><div class="history-header-item">Big/Small</div><div class="history-header-item">Color</div>`; }
                const list = cachedData.slice(0, localCallTab === 'game' ? GAME_HISTORY_ITEMS_PER_PAGE : DEEP_HISTORY_ITEMS_PER_PAGE);
                if (list.length === 0) { contentEl.innerHTML = `<p style="text-align:center; padding:1rem;">No ${localCallTab} history available. System is fetching...</p>`; if(navigator.onLine) await fetchPage(1, true); }
                else { list.forEach(item => { const details = getNumberDetails(item.number); const div = document.createElement('div'); div.className = 'history-item game-result-item'; div.innerHTML = `<div class="history-value">${item.issueNumber||'?'}</div><div class="history-value gh-num ${details.numberClass}">${details.numberVal}</div><div class="history-value gh-bs ${details.bsClass}">${details.bigSmall}</div><div class="history-value gh-color">${details.colorForHistory}</div>`; contentEl.appendChild(div); }); }
            } else if (localCallTab === 'my') {
                if (currentTab !== localCallTab) return;
                contentEl.innerHTML = '';
                const startIndex = (currentPage - 1) * myHistoryItemsPerPage;
                const endIndex = startIndex + myHistoryItemsPerPage;
                const paginatedHistory = history.slice(startIndex, endIndex);
                document.getElementById('nextPageBtn').disabled = (endIndex >= history.length);

                let headerHTML = '';
                let itemGridTemplateColumns = '';
                const displayPatternForHeader = paginatedHistory.length > 0 ? (paginatedHistory[0].predictionFocus || loginSelectedPattern) : loginSelectedPattern;

                if (displayPatternForHeader === 'bs_num') {
                    headerHTML = `<div class="history-header-item">Period</div><div class="history-header-item">P. B/S</div><div class="history-header-item">P. Nums</div><div class="history-header-item">Actual Result</div><div class="history-header-item">Status</div>`;
                    itemGridTemplateColumns = '1.5fr 1fr 1.2fr 2fr 1fr';
                } else if (displayPatternForHeader === 'only_col') {
                    headerHTML = `<div class="history-header-item">Period</div><div class="history-header-item">P. Color</div><div class="history-header-item">Actual Result</div><div class="history-header-item">Status</div>`;
                    itemGridTemplateColumns = '1.8fr 1.2fr 2.2fr 1fr';
                } else {
                    headerHTML = `<div class="history-header-item">Period</div><div class="history-header-item">Prediction</div><div class="history-header-item">Actual</div><div class="history-header-item">Status</div>`;
                    itemGridTemplateColumns = '1.5fr 2fr 2fr 1fr';
                }
                if(myHead) { myHead.innerHTML = headerHTML; myHead.style.gridTemplateColumns = itemGridTemplateColumns;}

                if (paginatedHistory.length === 0) contentEl.innerHTML = `<p style="text-align:center; padding:1rem;">${currentPage === 1 ? 'No predictions recorded.' : 'No more predictions.'}</p>`;
                else {
                    paginatedHistory.forEach(item => {
                        const div = document.createElement('div');
                        let rowClass = 'history-item my-prediction-item';
                        if (item.status === 'Win') rowClass += ' row-win';
                        else if (item.status === 'Loss') rowClass += ' row-loss';
                        else if (item.status === 'Partial') rowClass += ' row-partial';
                        else if (item.status?.startsWith('Error')) rowClass += ' row-error';
                        div.className = rowClass;

                        const itemFocus = item.predictionFocus || loginSelectedPattern;
                        let currentItemGridTemplateColumns = itemGridTemplateColumns;
                        if (itemFocus === 'bs_num') currentItemGridTemplateColumns = '1.5fr 1fr 1.2fr 2fr 1fr';
                        else if (itemFocus === 'only_col') currentItemGridTemplateColumns = '1.8fr 1.2fr 2.2fr 1fr';
                        else currentItemGridTemplateColumns = '1.5fr 2fr 2fr 1fr';
                        div.style.gridTemplateColumns = currentItemGridTemplateColumns;
                        
                        let itemHTML = '';

                        const bsTick = item.bsWin ? '<span class="tick-mark">✅</span>' : '<span class="cross-mark">❌</span>';
                        const colorTick = item.colorWin ? '<span class="tick-mark">✅</span>' : '<span class="cross-mark">❌</span>';
                        const numTick = item.numWin ? '<span class="tick-mark">✅</span>' : '<span class="cross-mark">❌</span>';
                        const predictedNumsDisplay = item.predictedNumbersArray ? item.predictedNumbersArray.join(',') : (item.predictedNumber || '?');

                        let actualResultDisplay = 'N/A';
                        if (item.actualNum !== undefined && item.actualNum !== '?') {
                            const actualDetails = getNumberDetails(item.actualNum);
                            actualResultDisplay = `${actualDetails.bigSmall}, ${actualDetails.colorForHistory}, Num:${item.actualNum}`;
                        } else if (item.actualColorForHistory && item.actualColorForHistory !== 'Result N/A') {
                            actualResultDisplay = `${item.actualBS || '?'}, ${item.actualColorForHistory}, Num:${item.actualNum || '?'}`;
                        } else if (item.status?.startsWith('Error')) {
                            actualResultDisplay = 'Error fetching result';
                        }


                        if (itemFocus === 'bs_num') {
                            itemHTML = `
                                <div class="history-value" title="${item.period}">${item.period}</div>
                                <div class="history-value predicted-bs-value">${item.predictedBS || '?'}${bsTick}</div>
                                <div class="history-value predicted-num-value" title="Predicted Nums: ${predictedNumsDisplay}">${predictedNumsDisplay}${numTick}</div>
                                <div class="history-value actual-result-value" title="Actual: B/S: ${item.actualBS}, Color: ${item.actualRawColor}, Num: ${item.actualNum}">${actualResultDisplay}</div>
                                <div class="history-value status-value status-${item.status?.toLowerCase() || 'unknown'}">${item.status || '?'}</div>`;
                        } else if (itemFocus === 'only_col') {
                            itemHTML = `
                                <div class="history-value" title="${item.period}">${item.period}</div>
                                <div class="history-value predicted-color-value">${item.predictedColorHTML || '?'}${colorTick}</div>
                                <div class="history-value actual-result-value" title="Actual: B/S: ${item.actualBS}, Color: ${item.actualRawColor}, Num: ${item.actualNum}">${actualResultDisplay}</div>
                                <div class="history-value status-value status-${item.status?.toLowerCase() || 'unknown'}">${item.status || '?'}</div>`;
                        } else {
                            itemHTML = `
                                <div class="history-value" title="${item.period}">${item.period}</div>
                                <div class="history-value">Pred: ${item.predictedBS}, ${item.predictedColorHTML}, ${predictedNumsDisplay}</div>
                                <div class="history-value actual-result-value">${actualResultDisplay}</div>
                                <div class="history-value status-value status-${item.status?.toLowerCase() || 'unknown'}">${item.status || '?'}</div>`;
                        }
                        div.innerHTML = itemHTML; contentEl.appendChild(div);
                    });
                }
            } else if (localCallTab === 'chart') {
                const analyticsData = await fetchOptimizedData(DEEP_HISTORY_ITEMS_PER_PAGE); if (currentTab !== localCallTab) return; if (analyticsData && analyticsData.length > 0) { let rC=0, gC=0, vC=0, bC=0, sC=0; const nums = analyticsData.map(item => parseInt(item.number, 10)).filter(n => !isNaN(n) && n >=0 && n <=9); nums.forEach(n => { const details = getNumberDetails(n); if(details.rawColor === 'Red') rC++; if(details.rawColor === 'Green') gC++; if(details.isViolet) vC++; if(details.bigSmall === 'Big') bC++; else if(details.bigSmall === 'Small') sC++; }); const totalValidGames = nums.length; const pct = (count) => totalValidGames ? ((count/totalValidGames)*100).toFixed(1) : 0; const totalSessionGames = sessionStats.wins + sessionStats.losses + (sessionStats.partials || 0); const sessionAccuracyValue = totalSessionGames > 0 ? Math.round((sessionStats.wins / totalSessionGames) * 100) : 0; const sessionAccuracyDisplay = totalSessionGames > 0 ? `${sessionAccuracyValue}% (W:${sessionStats.wins} L:${sessionStats.losses} P:${sessionStats.partials || 0})` : 'N/A'; contentEl.innerHTML = `<h4 style="font-size: 0.9rem; color: var(--primary); margin:0.4rem; padding-bottom:4px; border-bottom: 1px solid var(--border-color);">Recent Trends (Last ${totalValidGames} Games)</h4><div class="analytics-grid" style="padding: 0.6rem;"><div><strong>Outcome</strong></div><div><strong>Count</strong></div><div><strong>Percent</strong></div><div><span class="color-dot color-red"></span> Red</div><div>${rC}</div><div>${pct(rC)}%</div><div><span class="color-dot color-green"></span> Green</div><div>${gC}</div><div>${pct(gC)}%</div><div><span class="color-dot color-violet"></span> Violet</div><div>${vC}</div><div>${pct(vC)}%</div><div style="grid-column: 1 / -1; height: 8px;"></div><div><span class="outcome-icon big">B</span> Big (5-9)</div><div>${bC}</div><div>${pct(bC)}%</div><div><span class="outcome-icon small">S</span> Small (0-4)</div><div>${sC}</div><div>${pct(sC)}%</div></div><div class="session-accuracy-footer"><strong>Session Accuracy:</strong> ${sessionAccuracyDisplay}</div>`; } else contentEl.innerHTML = '<p style="text-align:center; padding:1rem;">Not enough data for analytics.</p>';
            } else if (localCallTab === 'admin_dashboard') {
                if (currentUserRole !== 'admin') { contentEl.innerHTML = '<p style="text-align:center; padding:1rem; color:var(--danger);">Access Denied.</p>'; return; } if (currentTab !== localCallTab) return; contentEl.innerHTML = `<div id="adminPanelContainer" style="padding: 8px; font-size:0.75rem;"><div class="admin-section"><h5 style="font-size:0.9rem;">User Management</h5><div id="adminUserManagementTopControls"><div id="adminUserStats"><span>Total: <strong id="totalManagedUsers" style="color:var(--primary)">0</strong></span><span>Banned: <strong id="bannedManagedUsers" style="color:var(--danger)">0</strong></span></div><div id="createUserFormContainer"><h6>Create New User Access Key</h6><div id="createUserFormControls"><label for="userValidityPeriod">Validity:</label><select id="userValidityPeriod"><option value="30m">30 Min</option><option value="1h">1 Hour</option><option value="1d">1 Day</option><option value="7d">7 Day</option><option value="60d">60 Day</option><option value="180d">180 Day</option><option value="365d">365 Day</option><option value="720d">720 Day</option><option value="lifetime">Lifetime</option></select><button id="createUserKeyButton"><i class="fas fa-plus-circle"></i> Create</button></div></div></div><div id="generatedUserKey"></div></div><div class="admin-section" style="margin-top: 8px;"><h5>Managed Users List</h5><div id="managedUsersListContainer"></div></div></div>`; renderAdminDashboard();
            }
        } catch (renderError) {
            if (currentTab === localCallTab) { contentEl.innerHTML = `<p style="text-align:center; padding:1rem; color:var(--danger);">Error displaying ${localCallTab} data. Check console.</p>`; }
            console.error(`Error in fetchData for tab ${localCallTab}:`, renderError);
        }
    }
    function changeMyHistoryEntriesPerPage(value) { myHistoryItemsPerPage = parseInt(value); saveMyHistoryItemsPerPageToStorage(); if (currentUserRole) fetchData(1, 'my', true); }
    function changePage(delta) { const newPage = currentPage + delta; if (newPage <= 0) return; const activeTabForPaging = getActiveTab(); if (!currentUserRole || activeTabForPaging !== 'my') { return; } if (activeTabForPaging === 'my') { const totalHistoryPages = Math.ceil(history.length / myHistoryItemsPerPage); if (newPage > totalHistoryPages && totalHistoryPages > 0 && delta > 0) return; } fetchData(newPage, activeTabForPaging); }
    function showNotification(message, type = 'success', duration = 3500) {
        const n=document.getElementById('notification'), nt=document.getElementById('notificationText'); if(!n || !nt) return; nt.textContent = message; n.className = 'floating-notification'; const iconEl = n.querySelector('i'); if (type === 'success') { n.classList.add('success-bg'); if (iconEl) iconEl.className = 'fas fa-check-circle'; } else if (type === 'error') { n.classList.add('error-bg'); if (iconEl) iconEl.className = 'fas fa-exclamation-circle'; } else { n.classList.add('info-bg'); if (iconEl) iconEl.className = 'fas fa-info-circle'; } n.style.color = 'var(--text-on-accent)'; n.classList.add('show'); setTimeout(() => n.classList.remove('show'), duration);
    }

    function clearMyPredictions() {
        if (!currentUserRole) { showNotification("Please login to manage predictions.", "error"); return; }
        const confirmModal = document.getElementById('confirmClearModal');
        const confirmMsgEl = confirmModal.querySelector('p');
        const confirmTitleEl = confirmModal.querySelector('h3');
        const confirmExecuteBtn = document.getElementById('confirmClearExecuteBtn');

        if (confirmModal && confirmMsgEl && confirmTitleEl && confirmExecuteBtn) {
            confirmTitleEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Confirm Clear History`;
            confirmMsgEl.textContent = "Are you sure you want to clear all your prediction history? This action cannot be undone.";
            confirmExecuteBtn.textContent = "Confirm Clear";
            confirmExecuteBtn.onclick = executeClearMyPredictions;
            confirmModal.style.display = "flex";
        } else {
            console.error("Confirm clear modal elements not found!");
        }
    }

    function executeClearMyPredictions() {
        history = [];
        saveMyHistoryToStorage();
        resetSessionStatistics();
        fetchData(1, 'my', true);
        showNotification('My Predictions history cleared!', 'info');
        const confirmModal = document.getElementById('confirmClearModal');
        if (confirmModal) confirmModal.style.display = "none";
    }


    // --- Admin Panel & User Management ---
    const renameUserModal = document.getElementById('renameUserModal');
    const renameUserModalCloseButton = document.getElementById('renameUserModalCloseButton'); const currentUsernameRenameEl = document.getElementById('currentUsernameRename'); const newUsernameInputEl = document.getElementById('newUsernameInput'); const userAccessKeyToRenameEl = document.getElementById('userAccessKeyToRename'); const saveRenameBtn = document.getElementById('saveRenameBtn'); const cancelRenameBtn = document.getElementById('cancelRenameBtn'); function openRenameModal(accessKey, currentName) { if (!renameUserModal || !currentUsernameRenameEl || !newUsernameInputEl || !userAccessKeyToRenameEl) return; currentUsernameRenameEl.textContent = currentName; newUsernameInputEl.value = currentName; userAccessKeyToRenameEl.value = accessKey; renameUserModal.style.display = "flex"; newUsernameInputEl.focus(); } if(renameUserModalCloseButton) renameUserModalCloseButton.onclick = () => { if(renameUserModal) renameUserModal.style.display = "none"; }; if(cancelRenameBtn) cancelRenameBtn.onclick = () => { if(renameUserModal) renameUserModal.style.display = "none"; }; if(saveRenameBtn) { saveRenameBtn.onclick = () => { const accessKey = userAccessKeyToRenameEl.value; const newUsername = newUsernameInputEl.value.trim(); if (!accessKey || !newUsername) { showNotification("New username cannot be empty.", "error"); return; } let managedUsers = getManagedUsers(); const userIndex = managedUsers.findIndex(u => u.accessKey === accessKey); if (userIndex > -1) { managedUsers[userIndex].username = newUsername; saveManagedUsers(managedUsers); renderAdminDashboard(); if(renameUserModal) renameUserModal.style.display = "none"; showNotification(`User ${accessKey} renamed to ${newUsername}.`, "success"); } else { showNotification("User not found for renaming.", "error"); } }; }
    function getManagedUsers() { return robustJsonParse(STORAGE_KEY_MANAGED_USERS, []); }
    function saveManagedUsers(usersArray) { robustLocalStorageSetItem(STORAGE_KEY_MANAGED_USERS, JSON.stringify(usersArray));}
    function getValidityLabel(validityPeriodValue) { const map = { "30m": "30Min", "1h": "1Hr", "1d": "1Day", "7d": "7Day", "60d": "60Day", "180d": "180Day", "365d": "1Yr", "720d": "2Yr", "lifetime": "Life" }; return map[validityPeriodValue] || "Gen"; }
    function generateAccessKey(validityPeriodValue, randomLength = 6) { const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_!'; let randomPart = ''; for (let i = 0; i < randomLength; i++) { randomPart += chars.charAt(Math.floor(Math.random() * chars.length)); } const validityLabel = getValidityLabel(validityPeriodValue); let expiryIdentifier = 'LIFE'; if (validityPeriodValue !== "lifetime") { const expiryTimestamp = calculateExpiryTimestamp(validityPeriodValue); if (expiryTimestamp) { const expiryDate = new Date(expiryTimestamp); const month = String(expiryDate.getMonth() + 1).padStart(2, '0'); const day = String(expiryDate.getDate()).padStart(2, '0'); const hour = String(expiryDate.getHours()).padStart(2,'0'); const minute = String(expiryDate.getMinutes()).padStart(2,'0'); expiryIdentifier = `${month}${day}${hour}${minute}`; } else { expiryIdentifier = 'UNKN'; } } return `VKP_${validityLabel}${expiryIdentifier}_${randomPart}`; }
    function calculateExpiryTimestamp(validityPeriod) { const now = Date.now(); if (validityPeriod === "lifetime") return null; let milliseconds; const unit = validityPeriod.slice(-1).toLowerCase(); const value = parseInt(validityPeriod.slice(0, -1)); if (isNaN(value)) return null; if (unit === 'm') milliseconds = value * 60 * 1000; else if (unit === 'h') milliseconds = value * 60 * 60 * 1000; else if (unit === 'd') milliseconds = value * 24 * 60 * 60 * 1000; else return null; return now + milliseconds; }
    function formatDateForDisplay(timestamp, isShort = false) { if (!timestamp) return "Lifetime"; const date = new Date(timestamp); if (isShort) { return `${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getFullYear()).slice(-2)} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`; } return date.toLocaleString([], { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false }); }
    function initializeSampleManagedUsers() {
        let users = getManagedUsers(); if (users.length === 0) { console.log("Initializing sample keys as managed users list is empty."); const sampleUserConfigs = [ { usernameBase: "SampleUser", validityPeriod: "30m" }, { usernameBase: "SampleUser", validityPeriod: "1d"}, { usernameBase: "SampleUser", validityPeriod: "7d"} ]; const newUsers = []; let userCounter = 1; sampleUserConfigs.forEach(config => { for (let i = 1; i <= 2; i++) { const validityLabel = getValidityLabel(config.validityPeriod); const createdAt = Date.now() - (userCounter * 1000 * 60 * 10); const expiresAt = calculateExpiryTimestamp(config.validityPeriod); const newUser = { accessKey: generateAccessKey(config.validityPeriod), username: `${config.usernameBase}_${validityLabel}_${i}`, createdAt: createdAt, validityPeriod: config.validityPeriod, expiresAt: expiresAt, isBanned: false, role: 'user' }; newUsers.push(newUser); userCounter++; } }); saveManagedUsers(newUsers); console.log(`${newUsers.length} sample keys created with new format.`); showNotification(`${newUsers.length} sample keys generated. Admins can manage them.`, 'info', 5000); } else { console.log("Managed users list not empty. Skipping sample key generation."); }
    }
    function renderAdminDashboard() {
        const totalManagedUsersEl = document.getElementById('totalManagedUsers'); const bannedManagedUsersEl = document.getElementById('bannedManagedUsers'); const listContainer = document.getElementById('managedUsersListContainer'); const createUserButton = document.getElementById('createUserKeyButton'); if (!listContainer || !totalManagedUsersEl || !bannedManagedUsersEl || !createUserButton ) { console.error("Admin panel elements not found."); return; } const managedUsers = getManagedUsers(); totalManagedUsersEl.textContent = managedUsers.length; bannedManagedUsersEl.textContent = managedUsers.filter(u => u.isBanned).length; listContainer.innerHTML = ''; const headerDiv = document.createElement('div'); headerDiv.className = 'admin-list-header'; headerDiv.innerHTML = `<div class="history-header-item">Date & Time</div><div class="history-header-item">Username</div><div class="history-header-item">Access Key</div><div class="history-header-item">Status</div><div class="history-header-item">Expires</div><div class="history-header-item">Actions</div>`; listContainer.appendChild(headerDiv); if (managedUsers.length === 0) { listContainer.innerHTML += '<p style="text-align:center;padding:10px;color:var(--text-secondary);">No users created yet.</p>'; } else { managedUsers.sort((a, b) => b.createdAt - a.createdAt); managedUsers.forEach(user => { const itemDiv = document.createElement('div'); itemDiv.className = 'history-item managed-user-item'; let statusText = "Active"; let statusColor = 'var(--success)'; if (user.isBanned) { statusText = "Banned"; statusColor = 'var(--danger)'; } else if (user.expiresAt && Date.now() > user.expiresAt) { statusText = "Expired"; statusColor = 'var(--warning)';} const banButtonText = user.isBanned ? "Unban" : "Ban"; const banButtonClass = user.isBanned ? "unban-btn" : "ban-btn"; itemDiv.innerHTML = `<div class="history-value" title="${new Date(user.createdAt).toLocaleString()}">${formatDateForDisplay(user.createdAt, true)}</div><div class="history-value user-cell" title="${user.username}">${user.username}</div><div class="history-value key-cell" title="${user.accessKey}">${user.accessKey}</div><div class="history-value" style="color:${statusColor}; font-weight:bold;">${statusText}</div><div class="history-value" title="${user.expiresAt ? new Date(user.expiresAt).toLocaleString() : 'Lifetime'}">${formatDateForDisplay(user.expiresAt, true)}</div><div class="history-value"><button class="admin-action-btn rename-btn" data-key="${user.accessKey}" data-name="${user.username}" title="Rename User"><i class="fas fa-edit"></i></button><button class="${banButtonClass} admin-action-btn" data-key="${user.accessKey}" title="${banButtonText} User">${user.isBanned ? '<i class="fas fa-user-check"></i>' :'<i class="fas fa-user-slash"></i>'}</button><button class="delete-btn admin-action-btn" data-key="${user.accessKey}" title="Delete User"><i class="fas fa-trash-alt"></i></button></div>`; listContainer.appendChild(itemDiv); }); } listContainer.querySelectorAll('.rename-btn').forEach(button => { button.onclick = (e) => { const key = e.currentTarget.dataset.key; const name = e.currentTarget.dataset.name; openRenameModal(key, name); };}); listContainer.querySelectorAll('.ban-btn, .unban-btn').forEach(button => { button.onclick = (e) => { const key = e.currentTarget.dataset.key; const users = getManagedUsers(); const user = users.find(u => u.accessKey === key); if (user) { user.isBanned = !user.isBanned; saveManagedUsers(users); renderAdminDashboard(); showNotification(`User ${key} ${user.isBanned ? 'banned' : 'unbanned'}.`, 'info'); } }; }); listContainer.querySelectorAll('.delete-btn').forEach(button => { button.onclick = (e) => { const key = e.currentTarget.dataset.key; const confirmModal = document.getElementById('confirmClearModal'); const confirmMsgEl = confirmModal.querySelector('p'); const confirmTitleEl = confirmModal.querySelector('h3'); const confirmExecuteBtn = document.getElementById('confirmClearExecuteBtn'); if (confirmModal && confirmMsgEl && confirmTitleEl && confirmExecuteBtn) { confirmTitleEl.innerHTML = `<i class="fas fa-user-times" style="color: var(--danger);"></i> Confirm Delete User`; confirmMsgEl.textContent = `Are you sure you want to delete user ${key}? This cannot be undone.`; confirmExecuteBtn.textContent = "Confirm Delete"; confirmExecuteBtn.onclick = () => { let users = getManagedUsers(); users = users.filter(u => u.accessKey !== key); saveManagedUsers(users); renderAdminDashboard(); showNotification(`User ${key} deleted.`, 'info'); confirmModal.style.display = 'none'; }; document.getElementById('cancelClearBtn').onclick = () => {confirmModal.style.display = 'none';}; confirmModal.style.display = 'flex'; } else { console.error("Confirmation modal elements not found for user deletion."); if(confirm(`Fallback: Delete user ${key}?`)) { let users = getManagedUsers(); users = users.filter(u => u.accessKey !== key); saveManagedUsers(users); renderAdminDashboard(); showNotification(`User ${key} deleted.`, 'info');} } }; }); createUserButton.onclick = () => { const validityPeriodSelect = document.getElementById('userValidityPeriod'); const generatedUserKeyEl = document.getElementById('generatedUserKey'); if (!validityPeriodSelect || !generatedUserKeyEl) { console.error("Create user form elements missing!"); return; } const validityPeriod = validityPeriodSelect.value; const validityLabel = getValidityLabel(validityPeriod); const timestampSuffix = String(Date.now()).slice(-5); const newKey = generateAccessKey(validityPeriod); const createdAt = Date.now(); const expiresAt = calculateExpiryTimestamp(validityPeriod); const autoUsername = `User_${validityLabel}_${timestampSuffix}`; const newUser = { accessKey: newKey, username: autoUsername, createdAt, validityPeriod, expiresAt, isBanned: false, role: 'user' }; const currentManagedUsers = getManagedUsers(); currentManagedUsers.push(newUser); saveManagedUsers(currentManagedUsers); generatedUserKeyEl.textContent = `New Key: ${newKey} (User: ${autoUsername})`; renderAdminDashboard(); showNotification(`User key ${newKey} for ${autoUsername} created.`, 'success'); };
    }

    // --- Authentication & Initialization ---
    function showLoginModal(show = true) {
        const loginModalEl = document.getElementById('loginModal'); const appContainerEl = document.getElementById('appContainer'); const loginErrorEl = document.getElementById('loginError'); if(!loginModalEl || !appContainerEl) { console.error("Login or App container not found in showLoginModal"); return; } if (loginErrorEl) loginErrorEl.style.display = 'none'; if (show) { loginModalEl.style.display = "flex"; appContainerEl.style.display = "none"; } else { loginModalEl.style.display = "none"; appContainerEl.style.display = "block"; }
    }
    function showLoginError(message) {
        const loginErrorEl = document.getElementById('loginError'); const keyInput = document.getElementById('accessKeyInput'); if (loginErrorEl) { loginErrorEl.textContent = message; loginErrorEl.style.display = 'block'; } if (keyInput) keyInput.value = '';
    }

    function updateUserFocusSelectionUI() {
        const userGameSelectionCard = document.getElementById('userGameSelectionCard');
        const currentUserFocusDisplay = document.getElementById('currentUserFocusDisplay');
        const aiPredictionCard = document.getElementById('aiPredictionCard');
        const aiGameTypeSelectorContainer = document.getElementById('aiGameTypeSelectorContainer');

        if (currentUserRole === 'user') {
            if (userGameSelectionCard) userGameSelectionCard.style.display = 'block';
            if (aiGameTypeSelectorContainer) aiGameTypeSelectorContainer.style.display = 'none';

            let focusText = "Not Selected";
            if (loginSelectedPattern === 'bs_num') focusText = "Big / Small & Number";
            else if (loginSelectedPattern === 'only_col') focusText = "Only Color";

            if (currentUserFocusDisplay) currentUserFocusDisplay.textContent = focusText;
            if (aiPredictionCard) aiPredictionCard.style.display = 'block';

        } else if (currentUserRole === 'admin') {
            if (userGameSelectionCard) userGameSelectionCard.style.display = 'none';
            if (aiGameTypeSelectorContainer) aiGameTypeSelectorContainer.style.display = 'none';
            if (aiPredictionCard) aiPredictionCard.style.display = 'block';
        } else {
            if (userGameSelectionCard) userGameSelectionCard.style.display = 'none';
            if (aiGameTypeSelectorContainer) aiGameTypeSelectorContainer.style.display = 'none';
            if (aiPredictionCard) aiPredictionCard.style.display = 'block';
        }
    }


    function initializeUIBasedOnRole() {
        console.log("[DEBUG] initializeUIBasedOnRole: Called. CurrentUserRole:", currentUserRole, "LoginSelectedPattern:", loginSelectedPattern);
        const adminTab = document.getElementById('adminDashboardTab');
        const logoutBtn = document.getElementById('logoutButton');
        const appContainer = document.getElementById('appContainer');
        const loginModal = document.getElementById('loginModal');
        const tabButtons = document.querySelectorAll('.tabs button');


        if (!appContainer || !loginModal) { console.error("[DEBUG] Critical UI elements not found."); return; }

        if (currentUserRole === 'admin') {
            if (adminTab) adminTab.style.display = 'flex';
            tabButtons.forEach(btn => {
                const onclickAttr = btn.getAttribute('onclick');
                if (btn.id === 'adminDashboardTab') return;

                if (onclickAttr) {
                    if (onclickAttr.includes("'deep'")) {
                        btn.style.display = 'flex';
                    } else {
                        btn.style.display = 'none';
                    }
                }
            });
        } else { 
            if (adminTab) adminTab.style.display = 'none';
            tabButtons.forEach(btn => {
                 if (btn.id === 'adminDashboardTab') return; 
                btn.style.display = 'flex'; 
            });
        }


        if (logoutBtn) logoutBtn.style.display = currentUserRole ? 'inline-block' : 'none';
        updateUserFocusSelectionUI();

        if (currentUserRole) {
            console.log("[DEBUG] User is logged in. Showing app.");
            showLoginModal(false);
            loadMyHistoryFromStorage();
            loadSessionStateFromStorage();
            loadMyHistoryItemsPerPageFromStorage();
            setApiStatus();

            const initialOutputArea = document.getElementById('currentResult');
            if(initialOutputArea) initialOutputArea.innerHTML = '<i class="fas fa-hourglass-half fa-spin" style="color:var(--primary);"></i> Initializing AI...';

            fetchOptimizedData(DEEP_HISTORY_ITEMS_PER_PAGE).then(() => {
                if(periodTimerInterval) clearInterval(periodTimerInterval);
                periodTimerInterval = setInterval(updatePeriodAndTimer, 1000);

                const defaultTabToLoad = currentUserRole === 'admin' ? 'deep' : 'game';
                
                document.querySelectorAll('.tabs button').forEach(btn => btn.classList.remove('active'));
                
                const activeTabButton = document.querySelector(`.tabs button[onclick*="'${defaultTabToLoad}'"]`);
                
                if (activeTabButton && activeTabButton.style.display !== 'none') {
                     fetchData(1, defaultTabToLoad, true);
                } else if (currentUserRole === 'admin') {
                    const adminPanelButton = document.getElementById('adminDashboardTab');
                    if (adminPanelButton && adminPanelButton.style.display !== 'none') {
                        fetchData(1, 'admin_dashboard', true);
                    }
                }
                
                updateAccuracyDisplay();
                console.log(`[DEBUG] Initialization complete. Cached: ${cachedData.length} items. Default tab: ${getActiveTab()}`);
            }).catch(err => {
                console.error("Error during init fetch:", err);
                if(initialOutputArea) initialOutputArea.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Error initializing app data.';
                setApiStatus();
            });
        } else {
            console.log("[DEBUG] No user session. Showing login modal.");
            showLoginModal(true);
            if(periodTimerInterval) clearInterval(periodTimerInterval);
            periodTimerInterval = null;
            setApiStatus();
        }
    }
    function handleLoginAttempt() {
        console.log("[DEBUG] handleLoginAttempt: Initiated.");
        const keyInput = document.getElementById('accessKeyInput');
        const patternSelector = document.getElementById('loginPredictionPattern');
        const enteredKey = keyInput.value.trim();
        let selectedPatternByDropdown = patternSelector.value;

        let role = null;
        let currentKeyToStore = null;
        let finalPatternToUse = selectedPatternByDropdown;

        if (!enteredKey) { showLoginError("Access Key cannot be empty."); return; }
        if (!selectedPatternByDropdown) { showLoginError("Please select a prediction pattern."); return; }

        console.log("[DEBUG] Attempting login with key:", enteredKey, "Dropdown Pattern:", selectedPatternByDropdown);

        if (enteredKey === ADMIN_ACCESS_KEY) {
            role = 'admin';
            currentKeyToStore = ADMIN_ACCESS_KEY;
            console.log("[DEBUG] Admin login successful.");
            finalPatternToUse = selectedPatternByDropdown;
        } else if (enteredKey === KEY_FOR_ONLY_COL) {
            role = 'user';
            currentKeyToStore = KEY_FOR_ONLY_COL;
            finalPatternToUse = 'only_col';
            console.log("[DEBUG] User login with KEY_FOR_ONLY_COL. Pattern forced to only_col.");
        } else if (enteredKey === KEY_FOR_BS_NUM) {
            role = 'user';
            currentKeyToStore = KEY_FOR_BS_NUM;
            finalPatternToUse = 'bs_num';
            console.log("[DEBUG] User login with KEY_FOR_BS_NUM. Pattern forced to bs_num.");
        } else {
            const managedUsers = getManagedUsers();
            const foundUser = managedUsers.find(u => u.accessKey === enteredKey);
            if (foundUser) {
                console.log("[DEBUG] User found:", foundUser.username);
                if (foundUser.isBanned) { showLoginError("This Access Key is banned."); console.log("[DEBUG] Login failed: User banned."); return; }
                if (foundUser.expiresAt && Date.now() > foundUser.expiresAt) { showLoginError("This Access Key has expired."); console.log("[DEBUG] Login failed: User key expired."); return; }
                role = 'user';
                currentKeyToStore = foundUser.accessKey;
                resetSessionStatistics();
                console.log("[DEBUG] User login successful.");
                finalPatternToUse = selectedPatternByDropdown;
            } else {
                console.log("[DEBUG] User not found or admin key incorrect.");
            }
        }

        if (role) {
            currentUserRole = role;
            loginSelectedPattern = finalPatternToUse;
            robustLocalStorageSetItem(STORAGE_KEY_USER_ROLE, role);
            robustLocalStorageSetItem(STORAGE_KEY_CURRENT_USER_KEY, currentKeyToStore);
            if (keyInput) keyInput.value = '';
            saveLoginPatternToStorage();
            initializeUIBasedOnRole();
            let patternText = "Unknown";
            if(loginSelectedPattern === 'bs_num') patternText = "Big/Small & Number";
            else if (loginSelectedPattern === 'only_col') patternText = "Only Color";
            showNotification(`Logged in as ${role}. Pattern: ${patternText}`, 'success');
        } else {
            currentUserRole = null;
            robustLocalStorageSetItem(STORAGE_KEY_USER_ROLE, '');
            localStorage.removeItem(STORAGE_KEY_CURRENT_USER_KEY);
            showLoginError("Invalid Access Key.");
        }
    }
    function handleLogout() {
            console.log("[DEBUG] handleLogout: Logging out.");
            currentUserRole = null;
            localStorage.removeItem(STORAGE_KEY_USER_ROLE);
            localStorage.removeItem(STORAGE_KEY_CURRENT_USER_KEY);
            localStorage.removeItem(STORAGE_KEY_LOGIN_PATTERN);
            loginSelectedPattern = 'bs_num';
            const adminTab = document.getElementById('adminDashboardTab'); if (adminTab) adminTab.style.display = 'none';
            const logoutBtn = document.getElementById('logoutButton'); if (logoutBtn) logoutBtn.style.display = 'none';
            const historyContentEl = document.getElementById('historyContent'); if (historyContentEl) historyContentEl.innerHTML = '';
            const appContainerEl = document.getElementById('appContainer'); if(appContainerEl) appContainerEl.style.display = "none";
            if(periodTimerInterval) clearInterval(periodTimerInterval); periodTimerInterval = null;
            
            const tabButtons = document.querySelectorAll('.tabs button');
             tabButtons.forEach(btn => {
                 if (btn.id === 'adminDashboardTab') {
                    btn.style.display = 'none';
                 } else {
                    btn.style.display = 'flex';
                 }
            });

            showLoginModal(true);
            showNotification('Logged out successfully.', 'info');
    }

    // --- Gemini API Integration ---
    const geminiModal = document.getElementById('geminiAnalysisModal');
    const geminiModalCloseButton = document.getElementById('geminiModalCloseButton');
    const geminiAnalysisTextEl = document.getElementById('geminiAnalysisText');
    if (geminiModalCloseButton) { geminiModalCloseButton.onclick = () => { if(geminiModal) geminiModal.style.display = "none"; }; }

    async function getGeminiAnalysis(prompt) {
        if (!geminiModal || !geminiAnalysisTextEl) return;
        geminiAnalysisTextEl.innerHTML = '<div class="gemini-loading"><i class="fas fa-spinner fa-spin"></i> Loading analysis...</div>';
        geminiModal.style.display = "flex";
        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;

        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: { message: "Unknown API error, non-JSON response." }}));
                console.error("Gemini API Error Response:", errorData);
                let errorMessage = `API Error: ${response.status} ${response.statusText}.`;
                if (errorData && errorData.error && errorData.error.message) { errorMessage += ` Details: ${errorData.error.message}`; }
                if (response.status === 400 && errorData.error.message.toLowerCase().includes("api key not valid")) {
                    errorMessage += " Please ensure a valid Google AI Gemini API Key is configured if you are running this outside the intended platform, or check platform key provisioning.";
                }
                throw new Error(errorMessage);
            }
            const result = await response.json();
            if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0 && result.candidates[0].content.parts[0].text) {
                const text = result.candidates[0].content.parts[0].text;
                geminiAnalysisTextEl.textContent = text;
            } else if (result.candidates && result.candidates.length > 0 && result.candidates[0].finishReason === "SAFETY") {
                geminiAnalysisTextEl.textContent = "Analysis blocked due to safety settings. The prompt or response might contain sensitive content.";
                console.warn("Gemini Response Blocked due to SAFETY:", result.candidates[0].safetyRatings);
            } else if (result.candidates && result.candidates.length > 0 && result.candidates[0].finishReason) {
                geminiAnalysisTextEl.textContent = `Could not generate complete analysis. Reason: ${result.candidates[0].finishReason}. Please try again.`;
                console.warn("Gemini Response Incomplete:", result.candidates[0]);
            } else {
                console.error("Gemini API - Unexpected response structure:", result);
                geminiAnalysisTextEl.textContent = "Could not generate analysis (unexpected response structure). Please try again later.";
            }
        } catch (error) {
            console.error('Error fetching Gemini analysis:', error);
            geminiAnalysisTextEl.textContent = `Failed to get analysis: ${error.message}. Please check your internet connection. If using your own key, ensure it's valid and the 'Generative Language API' is enabled. If on platform, check key provisioning.`;
        }
    }
    function handleDeeperAnalysis() {
        if (!lastCompletedPeriodNumber || !currentPredictionData[lastCompletedPeriodNumber]) { showNotification("No prediction has been generated yet.", "error"); return; }
        const predData = currentPredictionData[lastCompletedPeriodNumber]; if (!predData || predData.error) { showNotification("Current prediction data is invalid or contains an error.", "error"); return; }
        let recentHistoryText = "Recent game history (Period: Number, B/S, Color):\n"; cachedData.slice(0, 5).forEach(item => { if (item && item.issueNumber && typeof item.number !== 'undefined') { const details = getNumberDetails(item.number); recentHistoryText += `${item.issueNumber}: ${details.numberVal}, ${details.bigSmall}, ${details.rawColor}\n`; } });

        let focusDescription = "Overall (Big/Small, Color, and Numbers)";
        if (loginSelectedPattern === 'bs_num') focusDescription = "Big/Small and Number";
        else if (loginSelectedPattern === 'only_col') focusDescription = "Only Color";

        const prompt = `
            Game: Color Prediction (Red, Green, Violet; Numbers 0-9; Big/Small)
            User's Selected Prediction Pattern: ${focusDescription}
            Current Period: ${predData.period}
            My AI's Prediction (provides all components, but user is focused on the pattern above):
            - Big/Small: ${predData.predictedBS}
            - Color: ${predData.predictedRawColor} (Displayed as: ${predData.predictedColorHTML ? predData.predictedColorHTML.replace(/<[^>]+>/g, '') : 'N/A'})
            - Numbers: ${predData.predictedNumbersArray ? predData.predictedNumbersArray.join(', ') : 'N/A'}
            - Confidence: ${predData.probability}%
            - Reversal Chance: ${predData.reversalChance}%
            - Strategy Note: ${predData.message}
            Recent Game History (Last 5):
            ${recentHistoryText}
            Task: Provide a deeper textual analysis of my AI's prediction for period ${predData.period}, specifically focusing on the user's selected pattern: "${focusDescription}".
            Explain the reasoning if possible for the elements relevant to this pattern. What factors might support or contradict this focused prediction?
            Offer brief advice or alternative considerations for the user for this specific period based on their selected pattern.
            Keep the analysis concise and easy to understand for a game player. Respond in simple English.
        `;
        getGeminiAnalysis(prompt);
    }

    // --- Window Load & Event Listeners ---
    let periodTimerInterval = null;
    window.onload = async () => {
        console.log('Predict VIP King Pro Script Initializing...');
        initializeSampleManagedUsers();
        let loadedTheme = robustLocalStorageGetItem(STORAGE_KEY_THEME, 'dark'); applyTheme(loadedTheme);
        currentUserRole = robustLocalStorageGetItem(STORAGE_KEY_USER_ROLE, null);
        const storedUserKey = robustLocalStorageGetItem(STORAGE_KEY_CURRENT_USER_KEY, null);
        loadLoginPatternFromStorage();

        console.log("[DEBUG] window.onload: Retrieved role:", currentUserRole, "Key:", storedUserKey, "LoginPattern from storage:", loginSelectedPattern);
        let sessionStillValid = false;
        if (currentUserRole === 'admin' && storedUserKey === ADMIN_ACCESS_KEY) {
            sessionStillValid = true; console.log("[DEBUG] Admin session valid.");
        }
        else if (currentUserRole === 'user' && storedUserKey) {
            const managedUsers = getManagedUsers(); const foundUser = managedUsers.find(u => u.accessKey === storedUserKey);
            if (foundUser && !foundUser.isBanned && (!foundUser.expiresAt || Date.now() <= foundUser.expiresAt)) {
                sessionStillValid = true;
                console.log("[DEBUG] User session valid for:", foundUser.username);
            } else if (storedUserKey === KEY_FOR_ONLY_COL) {
                sessionStillValid = true;
                loginSelectedPattern = 'only_col';
                saveLoginPatternToStorage();
                console.log("[DEBUG] User session valid for KEY_FOR_ONLY_COL. Pattern forced to only_col.");
            } else if (storedUserKey === KEY_FOR_BS_NUM) {
                sessionStillValid = true;
                loginSelectedPattern = 'bs_num';
                saveLoginPatternToStorage();
                console.log("[DEBUG] User session valid for KEY_FOR_BS_NUM. Pattern forced to bs_num.");
            }
            else { console.log("[DEBUG] User session invalid. Found user (if any):", foundUser); }
        } else { console.log("[DEBUG] No valid session found."); }

        if (!sessionStillValid) {
            console.log("[DEBUG] window.onload: Session not valid, clearing role and key.");
            currentUserRole = null; localStorage.removeItem(STORAGE_KEY_USER_ROLE); localStorage.removeItem(STORAGE_KEY_CURRENT_USER_KEY);
        }
        initializeUIBasedOnRole();

        isSoundOn = robustLocalStorageGetItem(STORAGE_KEY_SOUND_ON, 'true') === 'true';
        const soundToggleBtn = document.getElementById('soundToggleBtn'); const soundToggleIcon = soundToggleBtn ? soundToggleBtn.querySelector('i') : null;
        function updateSoundIcon() { if (soundToggleIcon) { if (isSoundOn) { soundToggleIcon.classList.remove('fa-volume-mute'); soundToggleIcon.classList.add('fa-volume-up'); if(soundToggleBtn) soundToggleBtn.title = "Mute Sound"; } else { soundToggleIcon.classList.remove('fa-volume-up'); soundToggleIcon.classList.add('fa-volume-mute'); if(soundToggleBtn) soundToggleBtn.title = "Unmute Sound"; } } }
        updateSoundIcon(); if (soundToggleBtn) { soundToggleBtn.onclick = (e) => { e.preventDefault(); isSoundOn = !isSoundOn; robustLocalStorageSetItem(STORAGE_KEY_SOUND_ON, isSoundOn.toString()); updateSoundIcon(); const soundStatusMessage = isSoundOn ? "Sound On" : "Sound Muted"; showNotification(soundStatusMessage, "info"); if(isSoundOn) speak(soundStatusMessage); }; }

        const aboutModal=document.getElementById('aboutModal'), aboutModalLink=document.getElementById('aboutModalLink'), aboutModalCloseButton=document.getElementById('aboutModalCloseButton'); if(aboutModalLink && aboutModal && aboutModalCloseButton) { aboutModalLink.onclick = (e) => { e.preventDefault(); aboutModal.style.display="flex"; }; aboutModalCloseButton.onclick = () => { aboutModal.style.display="none"; }; }
        const contactModal = document.getElementById('contactModal'), contactModalLink = document.getElementById('contactModalLink'), contactModalCloseButton = document.getElementById('contactModalCloseButton'); if(contactModalLink && contactModal && contactModalCloseButton) { contactModalLink.onclick = (e) => { e.preventDefault(); contactModal.style.display="flex"; }; contactModalCloseButton.onclick = () => { contactModal.style.display="none"; }; }

        const confirmClearModalEl = document.getElementById('confirmClearModal');
        const confirmClearModalCloseBtn = document.getElementById('confirmClearModalCloseButton');
        const cancelClearBtn = document.getElementById('cancelClearBtn');

        if(confirmClearModalCloseBtn && confirmClearModalEl) confirmClearModalCloseBtn.onclick = () => { confirmClearModalEl.style.display = "none"; };
        if(cancelClearBtn && confirmClearModalEl) cancelClearBtn.onclick = () => { confirmClearModalEl.style.display = "none"; };


        if (renameUserModalCloseButton && renameUserModal) { renameUserModalCloseButton.onclick = () => { renameUserModal.style.display = "none"; }; }
        if (cancelRenameBtn && renameUserModal) { cancelRenameBtn.onclick = () => { renameUserModal.style.display = "none"; }; }
        const clearMyPredictionsBtn = document.getElementById('clearMyPredictionsBtn'); if (clearMyPredictionsBtn) { clearMyPredictionsBtn.onclick = clearMyPredictions; }
        const loginButtonEl = document.getElementById('loginButton'); if (loginButtonEl) loginButtonEl.onclick = handleLoginAttempt;
        const accessKeyInputEl = document.getElementById('accessKeyInput'); if (accessKeyInputEl) { accessKeyInputEl.addEventListener('keypress', function(event) { if (event.key === "Enter") { event.preventDefault(); handleLoginAttempt(); } }); }
        const logoutButtonEl = document.getElementById('logoutButton'); if (logoutButtonEl) logoutButtonEl.onclick = handleLogout;
        const themeToggleBtn = document.getElementById('themeToggleBtn'); if (themeToggleBtn) { themeToggleBtn.onclick = (e) => { e.preventDefault(); toggleTheme(); }; }
        const toggleJarvisBtn = document.getElementById('toggleJarvisCard'); if (toggleJarvisBtn) { toggleJarvisBtn.onclick = (e) => { e.preventDefault(); const content = document.getElementById('jarvisAnalyticsContent'); if(content) toggleJarvisCardVisibility(content.style.display === 'none', true); }; const jarvisVisible = robustLocalStorageGetItem(STORAGE_KEY_JARVIS_VISIBLE, 'true') === 'true'; toggleJarvisCardVisibility(jarvisVisible, false); }
        const deeperAnalysisButton = document.getElementById('deeperAnalysisBtn'); if (deeperAnalysisButton) deeperAnalysisButton.onclick = handleDeeperAnalysis;

        const aiGameTypeSelector = document.getElementById('aiGameTypeSelector');
        if (aiGameTypeSelector) {
            aiGameTypeSelector.onchange = (e) => {
                const tempDisplayFocus = e.target.value;
                showNotification(`Display focus temporarily set to: ${e.target.options[e.target.selectedIndex].text.replace('Focus: ','')}`, 'info');
                if (lastCompletedPeriodNumber && currentPredictionData[lastCompletedPeriodNumber]) {
                    const predData = currentPredictionData[lastCompletedPeriodNumber];
                    const currentResultEl = document.getElementById('currentResult');
                    if (currentResultEl && predData && !predData.error) {
                        const prob = predData.probability || 0; const revChance = predData.reversalChance || 0; const msg = predData.message || "?"; const nums = predData.predictedNumbersArray || ['?'];
                        const bsPart = `<span class="prediction-output-item p-bs"><span class="prediction-output-label">B/S:</span><span class="prediction-output-value">${predData.predictedBS || '?'}</span></span>`;
                        const colorPart = `<span class="prediction-output-item p-color"><span class="prediction-output-label">Color:</span><span class="prediction-output-value">${predData.predictedColorHTML || '?'}</span></span>`;
                        const numsPart = `<span class="prediction-output-item p-nums"><span class="prediction-output-label">Nums:</span><span class="prediction-output-value">${nums.join(', ')}</span></span>`;
                        const percentPart = `<span class="prediction-output-item p-perc"><span class="prediction-output-label">Per:</span><span class="prediction-output-value">(${prob > 0 ? prob.toFixed(1) : 'N/A'}%)</span></span>`;
                        const revPart = `<span class="prediction-output-item p-rev"><span class="prediction-output-label">Rev:</span><span class="prediction-output-value">(${revChance > 0 ? revChance.toFixed(1) : 'N/A'}%)</span></span>`;
                        const strategyPart = `<span class="prediction-output-item p-strat"><span class="prediction-output-label">Stgy:</span><span class="prediction-output-value" title="${msg}">${msg}</span></span>`;
                        let displayHTML = '';
                        if (tempDisplayFocus === 'bs_num') { displayHTML = `${bsPart} ${numsPart} ${percentPart} ${revPart} ${strategyPart}`; }
                        else if (tempDisplayFocus === 'only_col') { displayHTML = `${colorPart} ${percentPart} ${revPart} ${strategyPart}`; }
                        else { displayHTML = `${bsPart} ${colorPart} ${numsPart} ${percentPart} ${revPart} ${strategyPart}`; }
                        currentResultEl.innerHTML = displayHTML;
                    }
                }
            };
        }

        window.onclick = (event) => {
            if (event.target == geminiModal && geminiModal) geminiModal.style.display="none";
            const aboutModalEl = document.getElementById('aboutModal');
            if (event.target == aboutModalEl && aboutModalEl) aboutModalEl.style.display="none";
            const contactModalEl = document.getElementById('contactModal');
            if (event.target == contactModalEl && contactModalEl) contactModalEl.style.display="none";
            const renameModalEl = document.getElementById('renameUserModal');
            if (event.target == renameModalEl && renameModalEl) renameModalEl.style.display="none";
            const confirmClearModalEl = document.getElementById('confirmClearModal');
            if (event.target == confirmClearModalEl && confirmClearModalEl) confirmClearModalEl.style.display = "none";
        };


        window.addEventListener('online', () => { console.log("Internet connection detected: Online."); setApiStatus(); if(currentUserRole) fetchPage(1, true); });
        window.addEventListener('offline', () => { console.log("Internet connection detected: Offline."); setApiStatus(); });
        if ('speechSynthesis' in window && window.speechSynthesis.getVoices) { window.speechSynthesis.getVoices(); }
        console.log("Predict VIP King Pro Script: window.onload fully executed.");
    };
</script>

</body>
</html>
