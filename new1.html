<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predictor v5.7 - Advanced AI Loss Recovery</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #1e1e2f, #2a2a4a, #1e1e2f);
            background-size: 400% 400%;
            animation: gradientAnimation 15s ease infinite;
            color: #e0e0e0;
            padding: 1rem;
            overflow-x: hidden;
            position: relative;
            min-height: 100vh;
        }
        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .particle-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }
        .particle {
            position: absolute;
            background-color: rgba(100, 200, 255, 0.5);
            border-radius: 50%;
            opacity: 0;
            animation: particleFall 8s linear infinite;
        }
        @keyframes particleFall {
            0% { transform: translateY(-10vh) scale(0.5); opacity: 0; }
            10% { opacity: 0.7; }
            80% { opacity: 0.3; }
            100% { transform: translateY(110vh) scale(0.5); opacity: 0; }
        }
        .container {
            max-width: 32rem;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        .header {
            text-align: center;
            margin: 2rem 0;
            animation: fadeIn 1s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .card {
            background: rgba(30, 30, 47, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 25px rgba(100, 200, 255, 0.4);
        }
        .mode-btn, .tab-btn {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            font-weight: 500;
            border-radius: 6px;
            border: 1px solid #64c8ff;
            background: transparent;
            color: #64c8ff;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .mode-btn.active, .tab-btn.active {
            background: #64c8ff;
            color: #1e1e2f;
            border-color: #64c8ff;
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.6);
        }
        .mode-btn:hover, .tab-btn:hover {
            background: rgba(100, 200, 255, 0.2);
        }
        .info-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
        }
        .info-label {
            font-size: 0.8rem;
            color: #a0a0c0;
            display: flex;
            align-items: center;
        }
        .info-label svg {
            width: 1rem;
            height: 1rem;
            margin-right: 0.5rem;
            color: #64c8ff;
        }
        .info-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: #e0e0e0;
        }
        .ai-sparkle {
            width: 1.2rem;
            height: 1.2rem;
            color: #ffd700;
            margin-left: 0.4rem;
            animation: sparkle 1.5s infinite alternate;
        }
        @keyframes sparkle {
            0% { transform: scale(1); opacity: 0.7; }
            100% { transform: scale(1.2); opacity: 1; }
        }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #2a2a4a;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        .progress-fill {
            height: 100%;
            background: #64c8ff;
            transition: width 1s linear;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .table-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 6px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        th, td {
            padding: 0.5rem;
            text-align: center;
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
            color: #e0e0e0;
        }
        th {
            background: #2a2a4a;
            text-transform: uppercase;
            font-size: 0.7rem;
            letter-spacing: 0.05em;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .status-btn {
            width: 24px;
            height: 24px;
            border: 1px solid #64c8ff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.7rem;
        }
        .btn-win { color: #00ff7f; }
        .btn-win:hover { background: rgba(0, 255, 127, 0.2); }
        .btn-loss { color: #ff4d4d; margin-left: 0.3rem; }
        .btn-loss:hover { background: rgba(255, 77, 77, 0.2); }
        .status-pill {
            padding: 3px 6px;
            border-radius: 9999px;
            font-size: 0.7rem;
            font-weight: 500;
        }
        .status-win { background: rgba(0, 255, 127, 0.2); color: #00ff7f; }
        .status-loss { background: rgba(255, 77, 77, 0.2); color: #ff4d4d; }
        .status-pending { background: rgba(100, 200, 255, 0.2); color: #64c8ff; }
        .color-red { color: #ff4d4d; }
        .color-green { color: #00ff7f; }
        .color-violet { color: #b04dff; }
        .color-big { color: #ff9500; }
        .color-small { color: #64c8ff; }
        .chart-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .stat-item {
            background: #2a2a4a;
            padding: 0.75rem;
            border-radius: 6px;
            text-align: center;
        }
        .stat-label {
            font-size: 0.7rem;
            color: #a0a0c0;
            margin-bottom: 0.25rem;
        }
        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #e0e0e0;
        }
        .stat-value.win { color: #00ff7f; }
        .stat-value.loss { color: #ff4d4d; }
        .stat-value.accuracy { color: #64c8ff; }
        .stat-value.revenue { color: #ffd700; }
        .stat-value.revenue.negative { color: #ff4d4d; }
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .toggle-switch input {
            appearance: none;
            width: 2rem;
            height: 1rem;
            background: #2a2a4a;
            border-radius: 9999px;
            position: relative;
            cursor: pointer;
            outline: none;
        }
        .toggle-switch input::before {
            content: '';
            position: absolute;
            width: 0.8rem;
            height: 0.8rem;
            background: #64c8ff;
            border-radius: 50%;
            top: 0.1rem;
            left: 0.1rem;
            transition: transform 0.2s;
        }
        .toggle-switch input:checked::before {
            transform: translateX(1rem);
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: #1e1e2f;
            padding: 1.5rem;
            border-radius: 8px;
            text-align: center;
            max-width: 20rem;
            width: 90%;
        }
        .modal-btn {
            padding: 0.5rem 1rem;
            margin: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
        }
        @media (max-width: 600px) {
            body { padding: 0.5rem; }
            .header { margin: 1.5rem 0; }
            .card { padding: 0.75rem; margin-bottom: 0.75rem; }
            .mode-btn, .tab-btn { font-size: 0.8rem; padding: 0.4rem 0.8rem; }
            .info-line { padding: 0.4rem 0; }
            .info-label { font-size: 0.7rem; }
            .info-label svg { width: 0.9rem; height: 0.9rem; }
            .info-value { font-size: 0.8rem; }
            .table-container { max-height: 250px; }
            th, td { padding: 0.4rem; font-size: 0.7rem; }
            .status-btn { width: 22px; height: 22px; font-size: 0.6rem; }
            .status-pill { font-size: 0.6rem; }
            .chart-stats-grid { gap: 0.5rem; }
            .stat-item { padding: 0.5rem; }
            .stat-label { font-size: 0.6rem; }
            .stat-value { font-size: 1rem; }
        }
    </style>
</head>
<body>
    <div class="particle-bg"></div>
    <div class="container">
        <div class="header">
            <h1 class="text-3xl md:text-4xl font-bold">Predictor <span class="text-blue-400">v5.7</span></h1>
            <p class="text-sm text-gray-400 mt-2">Advanced AI Loss Recovery</p>
        </div>
        <div class="card flex justify-center space-x-2 md:space-x-4">
            <button id="btn30s" class="mode-btn active" onclick="selectMode('30s')">30s</button>
            <button id="btn1m" class="mode-btn" onclick="selectMode('1m')">1m</button>
        </div>
        <div class="card">
            <div class="toggle-switch">
                <input type="checkbox" id="ai-insights-toggle" checked>
                <label for="ai-insights-toggle" class="text-sm text-gray-400">Show AI Insights</label>
            </div>
            <div class="info-line">
                <span class="info-label">
                    <svg fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0v-7.5A2.25 2.25 0 015.25 9h13.5A2.25 2.25 0 0121 11.25v7.5" /></svg>Period
                </span>
                <p id="period" class="info-value">Select Mode</p>
            </div>
            <div class="info-line">
                <span class="info-label">
                    <svg fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>Timer
                </span>
                <p id="timer" class="info-value text-red-400 font-bold text-lg">--:--</p>
            </div>
            <div class="progress-bar">
                <div id="progress-fill" class="progress-fill" style="width: 0%;"></div>
            </div>
            <div class="info-line">
                <span class="info-label">
                    <svg fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z" /></svg>AI Predict
                    <svg class="ai-sparkle" viewBox="0 0 24 24" fill="currentColor" id="ai-sparkle-icon" style="display: none;">
                        <path fill-rule="evenodd" d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.007z" clip-rule="evenodd" />
                    </svg>
                </span>
                <p id="prediction-text" class="info-value font-bold text-lg"></p>
            </div>
            <div class="info-line" id="insight-container">
                <span class="info-label">
                    <svg fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3v11.25A2.25 2.25 0 006 16.5h2.25M3.75 3h-1.5m1.5 0h16.5m-16.5 0H6M6 3v11.25A2.25 2.25 0 008.25 16.5h7.5M6 3h7.5M12 3v11.25m0 0A2.25 2.25 0 0114.25 16.5h2.25M12 3h7.5m0 0h-1.5m1.5 0v11.25A2.25 2.25 0 0118 16.5h-2.25m-7.5 0h7.5" /></svg>Insight
                </span>
                <p id="insight-text" class="info-value text-sm text-blue-400"></p>
            </div>
        </div>
        <div class="card">
            <div class="flex justify-center space-x-2 md:space-x-4 mb-4">
                <button id="tab-history-btn" class="tab-btn active" onclick="selectTab('history')">History</button>
                <button id="tab-chart-btn" class="tab-btn" onclick="selectTab('chart')">Chart</button>
            </div>
            <div id="history-tab-content" class="tab-content active">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-lg font-semibold flex items-center">
                        <svg fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-2"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 12h16.5m-16.5 3.75h16.5M3.75 19.5h16.5M5.625 4.5h12.75a1.875 1.875 0 010 3.75H5.625a1.875 1.875 0 010-3.75z" /></svg>Prediction History
                    </h2>
                    <button id="clear-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-md text-sm">Clear</button>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Period</th>
                                <th>Prediction</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="predictions-table"></tbody>
                    </table>
                </div>
            </div>
            <div id="chart-tab-content" class="tab-content">
                <h2 class="text-lg font-semibold flex items-center mb-3">
                    <svg fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-2"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6a7.5 7.5 0 107.5 7.5h-7.5V6z" /><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5H21A7.5 7.5 0 0013.5 3v7.5z" /></svg>AI Performance
                </h2>
                <div class="chart-stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Total Wins</div>
                        <div id="chart-total-wins" class="stat-value win">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Total Losses</div>
                        <div id="chart-total-losses" class="stat-value loss">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Accuracy</div>
                        <div id="chart-accuracy" class="stat-value accuracy">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Net Revenue</div>
                        <div id="chart-revenue" class="stat-value revenue">0</div>
                    </div>
                </div>
                <h3 class="text-md font-semibold mb-2">Strategy Performance</h3>
                <canvas id="strategy-chart" height="200"></canvas>
            </div>
        </div>
        <div id="clear-modal" class="modal">
            <div class="modal-content">
                <p class="text-sm mb-4">Are you sure you want to clear all data?</p>
                <button id="confirm-clear" class="modal-btn bg-red-600 hover:bg-red-700 text-white">Confirm</button>
                <button id="cancel-clear" class="modal-btn bg-gray-600 hover:bg-gray-700 text-white">Cancel</button>
            </div>
        </div>
    </div>
    <script>
        const elements = {
            period: document.getElementById('period'),
            timer: document.getElementById('timer'),
            predictionText: document.getElementById('prediction-text'),
            insightText: document.getElementById('insight-text'),
            insightContainer: document.getElementById('insight-container'),
            predictionsTable: document.getElementById('predictions-table'),
            clearButton: document.getElementById('clear-button'),
            aiSparkleIcon: document.getElementById('ai-sparkle-icon'),
            tabHistoryBtn: document.getElementById('tab-history-btn'),
            tabChartBtn: document.getElementById('tab-chart-btn'),
            historyTabContent: document.getElementById('history-tab-content'),
            chartTabContent: document.getElementById('chart-tab-content'),
            chartTotalWins: document.getElementById('chart-total-wins'),
            chartTotalLosses: document.getElementById('chart-total-losses'),
            chartAccuracy: document.getElementById('chart-accuracy'),
            chartRevenue: document.getElementById('chart-revenue'),
            aiInsightsToggle: document.getElementById('ai-insights-toggle'),
            progressFill: document.getElementById('progress-fill'),
            particleBg: document.querySelector('.particle-bg'),
            clearModal: document.getElementById('clear-modal'),
            confirmClear: document.getElementById('confirm-clear'),
            cancelClear: document.getElementById('cancel-clear')
        };

        let masterInterval;
        let currentMode = null;
        let currentTab = 'history';
        let strategyChart = null;

        const initialStateTemplate = {
            history: [],
            predictions: [],
            currentPeriod: null,
            lastPredictionLost: false,
            stats: {
                totalWins: 0,
                totalLosses: 0,
                revenue: 0,
                strategyMetrics: {
                    "Collecting data...": { w: 0, l: 0 },
                    "Alternating Color (ABAB)": { w: 0, l: 0 },
                    "Double Color (AABB)": { w: 0, l: 0 },
                    "Triple Color (AAABBB)": { w: 0, l: 0 },
                    "Color (AABAAB)": { w: 0, l: 0 },
                    "Color (AAAB)": { w: 0, l: 0 },
                    "Color (AAABB)": { w: 0, l: 0 },
                    "Long Alternating (ABABAB)": { w: 0, l: 0 },
                    "Quad Color (AAAABBBB)": { w: 0, l: 0 },
                    "Staggered Color (AABAB)": { w: 0, l: 0 },
                    "Alternating Size (SBSB)": { w: 0, l: 0 },
                    "Double Size (BBSS)": { w: 0, l: 0 },
                    "Triple Size (SSSBBB)": { w: 0, l: 0 },
                    "Quadra Size (BBBBSSSS)": { w: 0, l: 0 },
                    "Long Alternating Size (SBSBSB)": { w: 0, l: 0 },
                    "Staggered Size (SSBSB)": { w: 0, l: 0 },
                    "Following Red Trend": { w: 0, l: 0 },
                    "Following Green Trend": { w: 0, l: 0 },
                    "Attempting Break Red": { w: 0, l: 0 },
                    "Attempting Break Green": { w: 0, l: 0 },
                    "Following Trend": { w: 0, l: 0 },
                    "Attempting Break": { w: 0, l: 0 },
                    "Loss Recovery": { w: 0, l: 0 },
                    "Random Guess": { w: 0, l: 0 },
                    "Last 2 Same (Color)": { w: 0, l: 0 },
                    "Last 2 Same (Size)": { w: 0, l: 0 },
                    "Last 2 Same (Color & Size)": { w: 0, l: 0 }
                }
            }
        };

        let state = {
            '30s': JSON.parse(JSON.stringify(initialStateTemplate)),
            '1m': JSON.parse(JSON.stringify(initialStateTemplate))
        };

        function saveState() {
            try {
                localStorage.setItem('predictorState', JSON.stringify(state));
            } catch (e) {
                console.error("Error saving to localStorage", e);
            }
        }

        function loadState() {
            try {
                const savedState = localStorage.getItem('predictorState');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    for (const mode in state) {
                        if (parsedState[mode]) {
                            state[mode].history = parsedState[mode].history || [];
                            state[mode].predictions = parsedState[mode].predictions || [];
                            state[mode].currentPeriod = parsedState[mode].currentPeriod || null;
                            state[mode].lastPredictionLost = parsedState[mode].lastPredictionLost || false;
                            state[mode].stats.strategyMetrics = {
                                ...initialStateTemplate.stats.strategyMetrics,
                                ...parsedState[mode].stats?.strategyMetrics
                            };
                            state[mode].stats.totalWins = parsedState[mode].stats?.totalWins || 0;
                            state[mode].stats.totalLosses = parsedState[mode].stats?.totalLosses || 0;
                            state[mode].stats.revenue = parsedState[mode].stats?.revenue || 0;
                        }
                    }
                }
            } catch (e) {
                console.error("Error loading from localStorage", e);
                state = {
                    '30s': JSON.parse(JSON.stringify(initialStateTemplate)),
                    '1m': JSON.parse(JSON.stringify(initialStateTemplate))
                };
            }
        }

        function selectMode(mode) {
            if (currentMode === mode) return;
            clearInterval(masterInterval);
            currentMode = mode;
            document.getElementById('btn30s').classList.toggle('active', mode === '30s');
            document.getElementById('btn1m').classList.toggle('active', mode === '1m');
            render();
            initOfflineGame();
        }

        function selectTab(tabName) {
            currentTab = tabName;
            elements.tabHistoryBtn.classList.toggle('active', tabName === 'history');
            elements.tabChartBtn.classList.toggle('active', tabName === 'chart');
            elements.historyTabContent.classList.toggle('active', tabName === 'history');
            elements.chartTabContent.classList.toggle('active', tabName === 'chart');
            render();
        }

        function generatePeriodNumber() {
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0].replace(/-/g, '');
            const istOffsetMinutes = 330;
            const currentUtcTime = now.getTime() + (now.getTimezoneOffset() * 60 * 1000);
            const istTime = new Date(currentUtcTime + (istOffsetMinutes * 60 * 1000));
            const h = istTime.getHours();
            const m = istTime.getMinutes();
            const s = istTime.getSeconds();
            const startH = 5;
            const startM = 30;
            let elapsedS = (h * 3600 + m * 60 + s) - (startH * 3600 + startM * 60);
            if (elapsedS < 0) elapsedS = (24 * 3600) + elapsedS;
            if (currentMode === '1m') {
                const elapsedMinutes = Math.floor(elapsedS / 60);
                return `${dateStr}10001${String(elapsedMinutes + 1).padStart(4, '0')}`;
            } else {
                const periodCounter = Math.floor(elapsedS / 30) + 1;
                return dateStr + "100005" + String(periodCounter).padStart(4, '0');
            }
        }

        function checkPatternMatch(historyValues, pattern) {
            if (historyValues.length < pattern.length) return { matches: false, nextPrediction: null };
            const relevantHistory = historyValues.slice(-pattern.length);
            const A_val = relevantHistory[0];
            const B_val = (A_val === 'Red') ? 'Green' : ((A_val === 'Green') ? 'Red' : ((A_val === 'Big') ? 'Small' : 'Big'));
            for (let i = 0; i < pattern.length; i++) {
                const expectedChar = pattern[i];
                const actualValue = relevantHistory[i];
                if ((expectedChar === 'A' && actualValue !== A_val) || (expectedChar === 'B' && actualValue !== B_val)) {
                    return { matches: false, nextPrediction: null };
                }
            }
            const nextIdxInPattern = historyValues.length % pattern.length;
            const nextExpectedChar = pattern[nextIdxInPattern];
            const nextPrediction = (nextExpectedChar === 'A') ? A_val : B_val;
            return { matches: true, nextPrediction };
        }

        function checkLastTwoSame(historyValues) {
            if (historyValues.length < 2) return { matches: false, nextPrediction: null };
            const last = historyValues[historyValues.length - 1];
            const secondLast = historyValues[historyValues.length - 2];
            if (last === secondLast) return { matches: true, nextPrediction: last };
            return { matches: false, nextPrediction: null };
        }

        function runPredictionEngine(history) {
            if (history.length < 3) {
                elements.aiSparkleIcon.style.display = 'none';
                const randomNum = Math.random();
                const randomColor = randomNum < 0.5 ? 'Red' : 'Green';
                const randomBigSmall = Math.random() < 0.5 ? 'Small' : 'Big';
                return { 
                    prediction: { bigSmall: randomBigSmall, color: randomColor }, 
                    strategy: 'Collecting data...', 
                    strategyKey: "Collecting data..." 
                };
            }

            elements.aiSparkleIcon.style.display = 'inline-block';
            const lastResult = history[history.length - 1];
            const lastResultColor = lastResult.color.split('-')[0];
            const lastResultBigSmall = lastResult.bigSmall;
            const oppositeColor = lastResultColor === 'Red' ? 'Green' : 'Red';
            const oppositeBigSmall = lastResultBigSmall === 'Big' ? 'Small' : 'Big';

            let bestPrediction = { color: null, bigSmall: null };
            let bestStrategyName = "Analyzing...";
            let bestStrategyKey = "Random Guess";
            let highestConfidence = 0.5;

            const colorHistoryValues = history.map(h => h.color.split('-')[0]);
            const bigSmallHistoryValues = history.map(h => h.bigSmall);
            const stats = state[currentMode].stats;

            const colorPatterns = [
                { name: "Alternating Color (ABAB)", pattern: ['A', 'B', 'A', 'B'], type: 'color', baseConfidence: 0.85 },
                { name: "Double Color (AABB)", pattern: ['A', 'A', 'B', 'B'], type: 'color', baseConfidence: 0.80 },
                { name: "Triple Color (AAABBB)", pattern: ['A', 'A', 'A', 'B', 'B', 'B'], type: 'color', baseConfidence: 0.90 },
                { name: "Color (AABAAB)", pattern: ['A', 'A', 'B', 'A', 'A', 'B'], type: 'color', baseConfidence: 0.75 },
                { name: "Color (AAAB)", pattern: ['A', 'A', 'A', 'B'], type: 'color', baseConfidence: 0.70 },
                { name: "Color (AAABB)", pattern: ['A', 'A', 'A', 'B', 'B'], type: 'color', baseConfidence: 0.75 },
                { name: "Long Alternating (ABABAB)", pattern: ['A', 'B', 'A', 'B', 'A', 'B'], type: 'color', baseConfidence: 0.88 },
                { name: "Quad Color (AAAABBBB)", pattern: ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'B'], type: 'color', baseConfidence: 0.92 },
                { name: "Staggered Color (AABAB)", pattern: ['A', 'A', 'B', 'A', 'B'], type: 'color', baseConfidence: 0.78 }
            ];

            const bigSmallPatterns = [
                { name: "Alternating Size (SBSB)", pattern: ['S', 'B', 'S', 'B'], type: 'bigSmall', baseConfidence: 0.85 },
                { name: "Double Size (BBSS)", pattern: ['B', 'B', 'S', 'S'], type: 'bigSmall', baseConfidence: 0.80 },
                { name: "Triple Size (SSSBBB)", pattern: ['S', 'S', 'S', 'B', 'B', 'B'], type: 'bigSmall', baseConfidence: 0.90 },
                { name: "Quadra Size (BBBBSSSS)", pattern: ['B', 'B', 'B', 'B', 'S', 'S', 'S', 'S'], type: 'bigSmall', baseConfidence: 0.92 },
                { name: "Long Alternating Size (SBSBSB)", pattern: ['S', 'B', 'S', 'B', 'S', 'B'], type: 'bigSmall', baseConfidence: 0.88 },
                { name: "Staggered Size (SSBSB)", pattern: ['S', 'S', 'B', 'S', 'B'], type: 'bigSmall', baseConfidence: 0.78 }
            ];

            function detectDragonTrend(historyValues, type = 'color') {
                let streak = 1;
                const lastValue = historyValues[historyValues.length - 1];
                for (let i = historyValues.length - 2; i >= 0; i--) {
                    if (historyValues[i] === lastValue) streak++;
                    else break;
                }
                const isDragon = streak >= 4;
                const breakProbability = streak > 4 ? 0.3 + (streak - 4) * 0.1 : 0.2;
                return {
                    isDragon,
                    streak,
                    nextPrediction: isDragon && Math.random() < breakProbability 
                        ? (type === 'color' ? oppositeColor : oppositeBigSmall)
                        : lastValue,
                    confidence: isDragon ? (0.9 - breakProbability) : 0.7,
                    strategyName: isDragon 
                        ? `Dragon Trend (${streak}x ${lastValue})${Math.random() < breakProbability ? ' - Break' : ''}`
                        : `Following ${type === 'color' ? lastValue + ' Trend' : lastValue + ' Size'}`
                };
            }

            let strategyScores = [];

            const lastTwoSameColor = checkLastTwoSame(colorHistoryValues);
            const lastTwoSameBigSmall = checkLastTwoSame(bigSmallHistoryValues);
            if (lastTwoSameColor.matches && lastTwoSameBigSmall.matches) {
                const strategyKey = "Last 2 Same (Color & Size)";
                const wins = stats.strategyMetrics[strategyKey]?.w || 0;
                const losses = stats.strategyMetrics[strategyKey]?.l || 0;
                const total = wins + losses;
                const historicalAccuracy = total > 0 ? wins / total : 0.5;
                strategyScores.push({
                    prediction: { color: lastTwoSameColor.nextPrediction, bigSmall: lastTwoSameBigSmall.nextPrediction },
                    strategyName: "Last 2 Same (Color & Size)",
                    strategyKey,
                    confidence: 0.95 * (total > 5 ? historicalAccuracy : 1)
                });
            } else if (lastTwoSameColor.matches) {
                const strategyKey = "Last 2 Same (Color)";
                const wins = stats.strategyMetrics[strategyKey]?.w || 0;
                const losses = stats.strategyMetrics[strategyKey]?.l || 0;
                const total = wins + losses;
                const historicalAccuracy = total > 0 ? wins / total : 0.5;
                strategyScores.push({
                    prediction: { color: lastTwoSameColor.nextPrediction, bigSmall: lastResultBigSmall },
                    strategyName: "Last 2 Same (Color)",
                    strategyKey,
                    confidence: 0.90 * (total > 5 ? historicalAccuracy : 1)
                });
            } else if (lastTwoSameBigSmall.matches) {
                const strategyKey = "Last 2 Same (Size)";
                const wins = stats.strategyMetrics[strategyKey]?.w || 0;
                const losses = stats.strategyMetrics[strategyKey]?.l || 0;
                const total = wins + losses;
                const historicalAccuracy = total > 0 ? wins / total : 0.5;
                strategyScores.push({
                    prediction: { color: lastResultColor, bigSmall: lastTwoSameBigSmall.nextPrediction },
                    strategyName: "Last 2 Same (Size)",
                    strategyKey,
                    confidence: 0.90 * (total > 5 ? historicalAccuracy : 1)
                });
            }

            for (const p of colorPatterns) {
                const result = checkPatternMatch(colorHistoryValues, p.pattern);
                if (result.matches) {
                    const strategyKey = p.name;
                    const wins = stats.strategyMetrics[strategyKey]?.w || 0;
                    const losses = stats.strategyMetrics[strategyKey]?.l || 0;
                    const total = wins + losses;
                    const historicalAccuracy = total > 0 ? wins / total : 0.5;
                    strategyScores.push({
                        prediction: { color: result.nextPrediction, bigSmall: lastResultBigSmall },
                        strategyName: `Color: ${p.name}`,
                        strategyKey,
                        confidence: p.baseConfidence * (total > 5 ? historicalAccuracy : 1)
                    });
                }
            }

            for (const p of bigSmallPatterns) {
                const result = checkPatternMatch(bigSmallHistoryValues, p.pattern);
                if (result.matches) {
                    const strategyKey = p.name;
                    const wins = stats.strategyMetrics[strategyKey]?.w || 0;
                    const losses = stats.strategyMetrics[strategyKey]?.l || 0;
                    const total = wins + losses;
                    const historicalAccuracy = total > 0 ? wins / total : 0.5;
                    strategyScores.push({
                        prediction: { color: lastResultColor, bigSmall: result.nextPrediction },
                        strategyName: `Size: ${p.name}`,
                        strategyKey,
                        confidence: p.baseConfidence * (total > 5 ? historicalAccuracy : 1)
                    });
                }
            }

            const colorDragon = detectDragonTrend(colorHistoryValues, 'color');
            const strategyKeyColorDragon = colorDragon.strategyName;
            const winsColorDragon = stats.strategyMetrics[strategyKeyColorDragon]?.w || 0;
            const lossesColorDragon = stats.strategyMetrics[strategyKeyColorDragon]?.l || 0;
            const totalColorDragon = winsColorDragon + lossesColorDragon;
            const historicalAccuracyColorDragon = totalColorDragon > 0 ? winsColorDragon / totalColorDragon : 0.5;
            strategyScores.push({
                prediction: { color: colorDragon.nextPrediction, bigSmall: lastResultBigSmall },
                strategyName: colorDragon.strategyName,
                strategyKey: strategyKeyColorDragon,
                confidence: colorDragon.confidence * (totalColorDragon > 5 ? historicalAccuracyColorDragon : 1)
            });

            const bigSmallDragon = detectDragonTrend(bigSmallHistoryValues, 'bigSmall');
            const strategyKeyBigSmallDragon = bigSmallDragon.strategyName;
            const winsBigSmallDragon = stats.strategyMetrics[strategyKeyBigSmallDragon]?.w || 0;
            const lossesBigSmallDragon = stats.strategyMetrics[strategyKeyBigSmallDragon]?.l || 0;
            const totalBigSmallDragon = winsBigSmallDragon + lossesBigSmallDragon;
            const historicalAccuracyBigSmallDragon = totalBigSmallDragon > 0 ? winsBigSmallDragon / totalBigSmallDragon : 0.5;
            strategyScores.push({
                prediction: { color: lastResultColor, bigSmall: bigSmallDragon.nextPrediction },
                strategyName: bigSmallDragon.strategyName,
                strategyKey: strategyKeyBigSmallDragon,
                confidence: bigSmallDragon.confidence * (totalBigSmallDragon > 5 ? historicalAccuracyBigSmallDragon : 1)
            });

            if (state[currentMode].lastPredictionLost) {
                const recentLosses = state[currentMode].predictions.slice(-3).filter(p => p.status === 'Loss').length;
                const recoveryConfidence = 0.6 + (recentLosses * 0.1);
                const flipColor = Math.random() < (0.5 + recentLosses * 0.1) ? oppositeColor : lastResultColor;
                const flipBigSmall = Math.random() < (0.5 + recentLosses * 0.1) ? oppositeBigSmall : lastResultBigSmall;
                strategyScores.push({
                    prediction: { color: flipColor, bigSmall: flipBigSmall },
                    strategyName: `Loss Recovery (Recent Losses: ${recentLosses})`,
                    strategyKey: "Loss Recovery",
                    confidence: recoveryConfidence
                });
            }

            if (strategyScores.length > 0) {
                strategyScores.sort((a, b) => b.confidence - a.confidence);
                const topStrategy = strategyScores[0];
                bestPrediction = topStrategy.prediction;
                bestStrategyName = topStrategy.strategyName;
                bestStrategyKey = topStrategy.strategyKey;
                highestConfidence = topStrategy.confidence;

                const highConfidenceStrategies = strategyScores.filter(s => s.confidence > 0.75);
                if (highConfidenceStrategies.length > 1) {
                    const combinedColor = highConfidenceStrategies.every(s => s.prediction.color === highConfidenceStrategies[0].prediction.color)
                        ? highConfidenceStrategies[0].prediction.color
                        : lastResultColor;
                    const combinedBigSmall = highConfidenceStrategies.every(s => s.prediction.bigSmall === highConfidenceStrategies[0].prediction.bigSmall)
                        ? highConfidenceStrategies[0].prediction.bigSmall
                        : lastResultBigSmall;
                    bestPrediction = { color: combinedColor, bigSmall: combinedBigSmall };
                    bestStrategyName = `Combined: ${highConfidenceStrategies.map(s => s.strategyName).join(' & ')}`;
                    bestStrategyKey = `Combined: ${highConfidenceStrategies.map(s => s.strategyKey).join(' & ')}`;
                    highestConfidence = Math.max(...highConfidenceStrategies.map(s => s.confidence));
                }
            } else {
                const trendStats = stats.strategyMetrics["Following Trend"] || { w: 0, l: 0 };
                const breakingStats = stats.strategyMetrics["Attempting Break"] || { w: 0, l: 0 };
                const trendAccuracy = (trendStats.w + trendStats.l > 0) ? trendStats.w / (trendStats.w + trendStats.l) : 0.5;
                const breakingAccuracy = (breakingStats.w + breakingStats.l > 0) ? breakingStats.w / (breakingStats.w + breakingStats.l) : 0.5;

                let currentStreakColor = 0;
                for (let i = history.length - 1; i >= 0; i--) {
                    if (history[i].color.includes(lastResultColor)) currentStreakColor++;
                    else break;
                }

                if (currentStreakColor >= 3 && breakingAccuracy > trendAccuracy && (breakingStats.w + breakingStats.l > 2)) {
                    bestPrediction.color = oppositeColor;
                    highestConfidence = breakingAccuracy;
                    bestStrategyName = `Attempting Break ${currentStreakColor}x ${lastResultColor}`;
                    bestStrategyKey = `Attempting Break ${lastResultColor}`;
                } else {
                    bestPrediction.color = lastResultColor;
                    highestConfidence = trendAccuracy;
                    bestStrategyName = `Following ${lastResultColor} Trend`;
                    bestStrategyKey = `Following ${lastResultColor} Trend`;
                }
                bestPrediction.bigSmall = lastResultBigSmall;
            }

            if (!stats.strategyMetrics[bestStrategyKey]) {
                stats.strategyMetrics[bestStrategyKey] = { w: 0, l: 0 };
            }

            bestStrategyName += ` | Conf: ${(highestConfidence * 100).toFixed(0)}%`;
            return { prediction: bestPrediction, strategy: bestStrategyName, strategyKey: bestStrategyKey };
        }

        function updateStrategyStats(actualResult) {
            const stats = state[currentMode].stats;
            const predictionForThisPeriod = state[currentMode].predictions.find(p => p.period === actualResult.period);
            if (!predictionForThisPeriod || predictionForThisPeriod.status !== 'Pending') return;

            const predictedColor = predictionForThisPeriod.prediction.color;
            const actualColor = actualResult.color;
            const predictedBigSmall = predictionForThisPeriod.prediction.bigSmall;
            const actualBigSmall = actualResult.bigSmall;
            let isWin = false;
            if (predictedColor.includes('-')) {
                const [predCol1, predCol2] = predictedColor.split('-');
                isWin = (actualColor.includes(predCol1) || actualColor.includes(predCol2)) && (predictedBigSmall === actualBigSmall);
            } else {
                isWin = (predictedColor === actualColor) && (predictedBigSmall === actualBigSmall);
            }
            predictionForThisPeriod.status = isWin ? 'Win' : 'Loss';
            if (isWin) {
                stats.totalWins++;
                stats.revenue++;
                state[currentMode].lastPredictionLost = false;
            } else {
                stats.totalLosses++;
                stats.revenue--;
                state[currentMode].lastPredictionLost = true;
            }
            const strategyKey = predictionForThisPeriod.strategyKey;
            if (!stats.strategyMetrics[strategyKey]) stats.strategyMetrics[strategyKey] = { w: 0, l: 0 };
            if (isWin) stats.strategyMetrics[strategyKey].w++;
            else stats.strategyMetrics[strategyKey].l++;
            saveState();
        }

        function setPredictionStatus(period, status) {
            if (!currentMode) return;
            const p = state[currentMode].predictions.find(p => p.period == period);
            if (p && p.status !== status) {
                const oldStatus = p.status;
                p.status = status;
                const stats = state[currentMode].stats;
                const strategyKey = p.strategyKey;
                if (oldStatus === 'Win') {
                    stats.totalWins--;
                    stats.revenue--;
                    if (stats.strategyMetrics[strategyKey]) stats.strategyMetrics[strategyKey].w--;
                } else if (oldStatus === 'Loss') {
                    stats.totalLosses--;
                    stats.revenue++;
                    if (stats.strategyMetrics[strategyKey]) stats.strategyMetrics[strategyKey].l--;
                }
                if (status === 'Win') {
                    stats.totalWins++;
                    stats.revenue++;
                    if (!stats.strategyMetrics[strategyKey]) stats.strategyMetrics[strategyKey] = { w: 0, l: 0 };
                    stats.strategyMetrics[strategyKey].w++;
                    state[currentMode].lastPredictionLost = false;
                } else if (status === 'Loss') {
                    stats.totalLosses++;
                    stats.revenue--;
                    if (!stats.strategyMetrics[strategyKey]) stats.strategyMetrics[strategyKey] = { w: 0, l: 0 };
                    stats.strategyMetrics[strategyKey].l++;
                    state[currentMode].lastPredictionLost = true;
                }
                saveState();
                render();
            }
        }

        function renderResultInHTML(result) {
            if (!result) return '...';
            const { bigSmall, color } = result;
            let colorHTML = `<strong class="color-${color?.toLowerCase() || ''}">${color}</strong>`;
            if (color && color.includes('-')) {
                const [c1, c2] = color.split('-');
                colorHTML = `<strong class="color-${c1.toLowerCase()}">${c1}</strong>+<strong class="color-${c2.toLowerCase()}">${c2}</strong>`;
            }
            return `${colorHTML} | <strong class="color-${bigSmall?.toLowerCase() || ''}">${bigSmall}</strong>`;
        }

        function renderChart() {
            const stats = state[currentMode].stats;
            elements.chartTotalWins.textContent = stats.totalWins;
            elements.chartTotalLosses.textContent = stats.totalLosses;
            const totalPredictions = stats.totalWins + stats.totalLosses;
            const accuracy = totalPredictions > 0 ? ((stats.totalWins / totalPredictions) * 100).toFixed(2) : 0;
            elements.chartAccuracy.textContent = `${accuracy}%`;
            elements.chartRevenue.textContent = stats.revenue;
            elements.chartRevenue.classList.toggle('negative', stats.revenue < 0);
            elements.chartRevenue.classList.toggle('win', stats.revenue > 0);
            elements.chartRevenue.classList.toggle('text-yellow-400', stats.revenue === 0);

            if (strategyChart) strategyChart.destroy();
            const ctx = document.getElementById('strategy-chart').getContext('2d');
            const sortedStrategies = Object.keys(stats.strategyMetrics)
                .filter(key => stats.strategyMetrics[key].w + stats.strategyMetrics[key].l > 0)
                .sort((a, b) => {
                    const accA = stats.strategyMetrics[a].w / (stats.strategyMetrics[a].w + stats.strategyMetrics[a].l);
                    const accB = stats.strategyMetrics[b].w / (stats.strategyMetrics[b].w + stats.strategyMetrics[b].l);
                    return accB - accA;
                });
            strategyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedStrategies,
                    datasets: [{
                        label: 'Accuracy (%)',
                        data: sortedStrategies.map(key => {
                            const total = stats.strategyMetrics[key].w + stats.strategyMetrics[key].l;
                            return total > 0 ? (stats.strategyMetrics[key].w / total * 100).toFixed(2) : 0;
                        }),
                        backgroundColor: 'rgba(100, 200, 255, 0.6)',
                        borderColor: '#64c8ff',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, max: 100, ticks: { color: '#e0e0e0' } },
                        x: { ticks: { color: '#e0e0e0', autoSkip: false, maxRotation: 45, minRotation: 45 } }
                    },
                    plugins: {
                        legend: { labels: { color: '#e0e0e0' } },
                        tooltip: {
                            callbacks: {
                                label: context => {
                                    const key = sortedStrategies[context.dataIndex];
                                    const metric = stats.strategyMetrics[key];
                                    return `${key}: ${context.raw}% (${metric.w}/${metric.w + metric.l})`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function render() {
            if (!currentMode) {
                elements.period.textContent = 'Select Mode';
                elements.timer.textContent = '--:--';
                elements.predictionText.textContent = '...';
                elements.insightText.textContent = '...';
                elements.aiSparkleIcon.style.display = 'none';
                elements.predictionsTable.innerHTML = '';
                elements.progressFill.style.width = '0%';
                return;
            }

            const activeState = state[currentMode];
            const currentPrediction = activeState.predictions[activeState.predictions.length - 1];

            if (currentPrediction) {
                elements.predictionText.innerHTML = renderResultInHTML(currentPrediction.prediction);
                elements.insightText.textContent = elements.aiInsightsToggle.checked ? currentPrediction.strategy : '';
                elements.aiSparkleIcon.style.display = (activeState.history.length >= 3) ? 'inline-block' : 'none';
            } else {
                elements.predictionText.textContent = '...';
                elements.insightText.textContent = '...';
                elements.aiSparkleIcon.style.display = 'none';
            }
            elements.insightContainer.style.display = elements.aiInsightsToggle.checked ? 'flex' : 'none';
            elements.predictionsTable.innerHTML = activeState.predictions.slice().reverse().map(item => {
                let s;
                const isPeriodResultAvailable = activeState.history.some(h => h.period === item.period);
                if (item.status === 'Pending' && isPeriodResultAvailable) {
                    s = `<div class="flex justify-center items-center">
                            <button class="status-btn btn-win" onclick="setPredictionStatus('${item.period}', 'Win')">W</button>
                            <button class="status-btn btn-loss" onclick="setPredictionStatus('${item.period}', 'Loss')">L</button>
                        </div>`;
                } else {
                    s = `<span class="status-pill status-${item.status?.toLowerCase() || 'pending'}">${item.status || 'Pending'}</span>`;
                }
                return `<tr><td>${String(item.period).slice(-6)}</td><td>${renderResultInHTML(item.prediction)}</td><td>${s}</td></tr>`;
            }).join('');
            if (currentTab === 'chart') renderChart();
        }

        function generateSmartSimulatedResult(history) {
            if (history.length < 2) {
                const num = Math.floor(Math.random() * 10);
                return {
                    number: num,
                    bigSmall: num >= 5 ? 'Big' : 'Small',
                    color: (num % 2 === 0) ? 'Red' : 'Green',
                    ...(currentMode === '30s' && (num === 0 || num === 5)) && { color: (num === 0 ? 'Red-Violet' : 'Green-Violet') }
                };
            }

            const lastResult = history[history.length - 1];
            const lastColor = lastResult.color.split('-')[0];
            const lastBigSmall = lastResult.bigSmall;
            const oppositeColor = lastColor === 'Red' ? 'Green' : 'Red';
            const oppositeBigSmall = lastBigSmall === 'Big' ? 'Small' : 'Big';
            let nextColor = null;
            let nextBigSmall = null;

            const colorHistoryValues = history.map(h => h.color.split('-')[0]);
            const colorPatternsForSim = [
                { check: checkPatternMatch(colorHistoryValues, ['A', 'B', 'A', 'B']), next: (lastColor === 'Red' ? 'Green' : 'Red'), chance: 0.7 },
                { check: checkPatternMatch(colorHistoryValues, ['A', 'A', 'B', 'B']), next: (lastColor === 'Red' ? 'Green' : 'Red'), chance: 0.65 },
                { check: checkPatternMatch(colorHistoryValues, ['A', 'A', 'A', 'B', 'B', 'B']), next: (lastColor === 'Red' ? 'Green' : 'Red'), chance: 0.6 },
                { check: checkPatternMatch(colorHistoryValues, ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'B']), next: (lastColor === 'Red' ? 'Green' : 'Red'), chance: 0.7 },
                { check: checkPatternMatch(colorHistoryValues, ['A', 'A', 'B', 'A', 'B']), next: (lastColor === 'Red' ? 'Red' : 'Green'), chance: 0.65 }
            ];

            let currentStreakColor = 0;
            for (let i = colorHistoryValues.length - 1; i >= 0; i--) {
                if (colorHistoryValues[i] === lastColor) currentStreakColor++;
                else break;
            }
            const isDragonColor = currentStreakColor >= 4;
            const breakProbabilityColor = isDragonColor ? 0.3 + (currentStreakColor - 4) * 0.1 : 0.2;

            const simLastTwoSameColor = checkLastTwoSame(colorHistoryValues);
            if (simLastTwoSameColor.matches && Math.random() < 0.8) {
                nextColor = simLastTwoSameColor.nextPrediction;
            } else if (isDragonColor && Math.random() < breakProbabilityColor) {
                nextColor = oppositeColor;
            } else {
                for (const p of colorPatternsForSim) {
                    if (p.check.matches && Math.random() < p.chance) {
                        nextColor = p.check.nextPrediction;
                        break;
                    }
                }
            }

            if (nextColor === null) {
                if (currentStreakColor >= 3 && Math.random() < 0.4) {
                    nextColor = oppositeColor;
                } else if (currentStreakColor >= 2 && Math.random() < 0.6) {
                    nextColor = lastColor;
                } else {
                    nextColor = Math.random() < 0.5 ? 'Red' : 'Green';
                }
            }

            const bigSmallHistoryValues = history.map(h => h.bigSmall);
            const bigSmallPatternsForSim = [
                { check: checkPatternMatch(bigSmallHistoryValues, ['S', 'B', 'S', 'B']), next: (lastBigSmall === 'Small' ? 'Big' : 'Small'), chance: 0.7 },
                { check: checkPatternMatch(bigSmallHistoryValues, ['B', 'B', 'S', 'S']), next: (lastBigSmall === 'Small' ? 'Big' : 'Small'), chance: 0.65 },
                { check: checkPatternMatch(bigSmallHistoryValues, ['S', 'S', 'S', 'B', 'B', 'B']), next: (lastBigSmall === 'Small' ? 'Big' : 'Small'), chance: 0.6 },
                { check: checkPatternMatch(bigSmallHistoryValues, ['S', 'S', 'B', 'S', 'B']), next: (lastBigSmall === 'Small' ? 'Big' : 'Small'), chance: 0.65 }
            ];

            let currentStreakBigSmall = 0;
            for (let i = bigSmallHistoryValues.length - 1; i >= 0; i--) {
                if (bigSmallHistoryValues[i] === lastBigSmall) currentStreakBigSmall++;
                else break;
            }
            const isDragonBigSmall = currentStreakBigSmall >= 4;
            const breakProbabilityBigSmall = isDragonBigSmall ? 0.3 + (currentStreakBigSmall - 4) * 0.1 : 0.2;

            const simLastTwoSameBigSmall = checkLastTwoSame(bigSmallHistoryValues);
            if (simLastTwoSameBigSmall.matches && Math.random() < 0.8) {
                nextBigSmall = simLastTwoSameBigSmall.nextPrediction;
            } else if (isDragonBigSmall && Math.random() < breakProbabilityBigSmall) {
                nextBigSmall = oppositeBigSmall;
            } else {
                for (const p of bigSmallPatternsForSim) {
                    if (p.check.matches && Math.random() < p.chance) {
                        nextBigSmall = p.check.nextPrediction;
                        break;
                    }
                }
            }

            if (nextBigSmall === null) {
                if (currentStreakBigSmall >= 3 && Math.random() < 0.4) {
                    nextBigSmall = oppositeBigSmall;
                } else if (currentStreakBigSmall >= 2 && Math.random() < 0.6) {
                    nextBigSmall = lastBigSmall;
                } else {
                    nextBigSmall = Math.random() < 0.5 ? 'Small' : 'Big';
                }
            }

            let finalNumber;
            let finalColor = nextColor;
            if (nextBigSmall === 'Big') {
                finalNumber = Math.floor(Math.random() * 5) + 5;
            } else {
                finalNumber = Math.floor(Math.random() * 5);
            }

            if (currentMode === '30s' && Math.random() < 0.15) {
                if (Math.random() < 0.5) {
                    finalNumber = 0;
                    finalColor = 'Red-Violet';
                } else {
                    finalNumber = 5;
                    finalColor = 'Green-Violet';
                }
            } else {
                if (finalColor === 'Red' && finalNumber % 2 === 0) finalNumber = (finalNumber + 1) % 10;
                else if (finalColor === 'Green' && finalNumber % 2 !== 0) finalNumber = (finalNumber + 1) % 10;
                if (nextBigSmall === 'Big' && finalNumber < 5) finalNumber += 5;
                else if (nextBigSmall === 'Small' && finalNumber >= 5) finalNumber -= 5;

                if ((finalColor === 'Red' && finalNumber % 2 === 0) || (finalColor === 'Green' && finalNumber % 2 !== 0)) {
                    if (Math.random() < 0.5) {
                        finalColor = (finalColor === 'Red') ? 'Green' : 'Red';
                    } else {
                        finalNumber = (finalNumber + 1) % 10;
                    }
                }
            }

            return {
                number: finalNumber,
                bigSmall: nextBigSmall,
                color: finalColor
            };
        }

        function offlineGameLoop() {
            if (!currentMode) return;
            const activeState = state[currentMode];
            if (activeState.currentPeriod) {
                const actualResult = generateSmartSimulatedResult(activeState.history);
                actualResult.period = activeState.currentPeriod;
                updateStrategyStats(actualResult);
                activeState.history.push(actualResult);
                if (activeState.history.length > 50) activeState.history.shift();
            }
            const newPeriod = generatePeriodNumber();
            activeState.currentPeriod = newPeriod;
            const { prediction, strategy, strategyKey } = runPredictionEngine(activeState.history);
            activeState.predictions.push({ period: newPeriod, prediction, strategy, strategyKey, status: 'Pending' });
            if (activeState.predictions.length > 50) activeState.predictions.shift();
            elements.period.textContent = newPeriod;
            saveState();
            render();
        }

        function masterClock() {
            if (!currentMode) return;
            const now = new Date();
            const duration = (currentMode === '30s') ? 30 : 60;
            const istOffsetMinutes = 330;
            const currentUtcTime = now.getTime() + (now.getTimezoneOffset() * 60 * 1000);
            const istTime = new Date(currentUtcTime + (istOffsetMinutes * 60 * 1000));
            const seconds = istTime.getSeconds();
            let remainingTime;
            if (currentMode === '30s') {
                const currentSecondInCycle = seconds % 30;
                remainingTime = (29 - currentSecondInCycle);
                if (remainingTime < 0) remainingTime += 30;
            } else {
                remainingTime = (59 - seconds);
                if (remainingTime < 0) remainingTime += 60;
            }
            elements.timer.textContent = `${String(Math.floor(remainingTime / 60)).padStart(2, '0')}:${String(Math.floor(remainingTime % 60)).padStart(2, '0')}`;
            elements.progressFill.style.width = `${((duration - remainingTime) / duration * 100).toFixed(2)}%`;
            const triggerSecond = (currentMode === '30s') ? (seconds % 30 === 0) : (seconds === 0);
            if (triggerSecond) {
                const debounceKey = currentMode + 'Trigger';
                if (!this[debounceKey] || (now.getTime() - this[debounceKey] > 500)) {
                    offlineGameLoop();
                    this[debounceKey] = now.getTime();
                }
            }
        }

        function initOfflineGame() {
            offlineGameLoop();
            masterInterval = setInterval(masterClock, 1000);
        }

        function createParticle() {
            const particle = document.createElement('div');
            particle.classList.add('particle');
            const size = Math.random() * 4 + 2;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.left = `${Math.random() * 100}%`;
            particle.style.animationDuration = `${Math.random() * 4 + 6}s`;
            particle.style.animationDelay = `-${Math.random() * 8}s`;
            elements.particleBg.appendChild(particle);
            particle.addEventListener('animationend', () => {
                particle.remove();
                createParticle();
            });
        }

        function initParticles() {
            for (let i = 0; i < 40; i++) createParticle();
        }

        elements.aiInsightsToggle.addEventListener('change', render);
        elements.clearButton.addEventListener('click', () => {
            elements.clearModal.style.display = 'flex';
        });
        elements.confirmClear.addEventListener('click', () => {
            if (!currentMode) return;
            state[currentMode] = JSON.parse(JSON.stringify(initialStateTemplate));
            saveState();
            render();
            elements.clearModal.style.display = 'none';
        });
        elements.cancelClear.addEventListener('click', () => {
            elements.clearModal.style.display = 'none';
        });

        loadState();
        selectMode('30s');
        selectTab('history');
        initParticles();
        initOfflineGame();
    </script>
</body>
</html>
